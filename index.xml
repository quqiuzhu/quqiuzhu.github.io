<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>看见未来</title>
        <link>https://quqiuzhu.com/</link>
        <description>Recent content on 看见未来</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-CN</language>
        <lastBuildDate>Thu, 30 May 2019 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://quqiuzhu.com/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Ubuntu Wechat</title>
            <link>https://quqiuzhu.com/2019/ubuntu-wechat/</link>
            <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2019/ubuntu-wechat/</guid>
            <description>一直以来，Linux不太适合日常工作，其中一个原因就是微信没有Linux版本。有很多不靠谱的第三方客户端，有这样那样的问题，这里就不推荐了。这里推荐微信的网页版，可以直接浏览器输入网址 wx.qq.com，这样的话微信只是浏览器中的一个 Tab，由于和其他网页混在一起， 不方便找，提供两个解决方案。
google-chrome 如果你的机器上装有 Chrome 浏览器， 就装了 google-chrome 这个命令行工具，输入下列命令
google-chrome --app=&amp;#34;https://wx.qq.com&amp;#34; 可将网页单独作为一个 App 运行在一个进程中， 并且隐藏掉了顶部的搜索框。 在 Launcher 上微信网页版和 Chrome 浏览器是两个分开的图标。 但是 Icon 还是一样的，有时候容易混淆。
nativefier 你也许听说过 Electron 可以通过Web技术开发桌面应用。 推荐一个工具，可以将任何的的在线网页变成一个桌面应用。首先你需要安装 Node 环境，然后安装 Electron 和 Nativefier。
npm install electron nativefier -g 然后运行下列命令，将微信网页版转换为本地应用，请先下载一张微信的图标，假如保存路径为 /tmp/wechat.png。
nativefier --name &amp;#34;wechat&amp;#34; --icon &amp;#34;/tmp/wechat.png&amp;#34; &amp;#34;https://wx.qq.com&amp;#34; 这样就在当前路径下生成了微信的本地应用， 目录为 wechat-linux-x64，执行./wechat打开微信应用，打开之后，以后就可以在 Launcher 打开了， 不需要每次都执行命令。
  制作脚本，请将 icon 换成你自己的路径
#!/usr/bin/bash  # install nodejs sudo apt install nodejs # install electron sudo ELECTRON_MIRROR=&amp;#34;https://npm.</description>
            <content type="html"><![CDATA[

<figure>
    <img src="https://quqiuzhu-com.oss-cn-beijing.aliyuncs.com/img/2019-05-30-wechat-desktop.png?Expires=1563682493&amp;OSSAccessKeyId=TMP.hY1Rks4nFtEbn2ikYCcCUBXRArhLj38dbXFR1fQhzeTSxf6e49HTUE6K5oc7Qpf2V5wcNuCQ5YqqNiRUFkKFmfCdvTD7z98qY7YwNcghNb6E22XjC4dbM64Pccyv6B.tmp&amp;Signature=N9z1as%2FBqVm%2BTfPGNpbhBeKeBZc%3D"/> 
</figure>


<p>一直以来，Linux不太适合日常工作，其中一个原因就是微信没有Linux版本。有很多不靠谱的第三方客户端，有这样那样的问题，这里就不推荐了。这里推荐微信的网页版，可以直接浏览器输入网址 <a href="https://wx.qq.com">wx.qq.com</a>，这样的话微信只是浏览器中的一个 Tab，由于和其他网页混在一起， 不方便找，提供两个解决方案。</p>

<h4 id="google-chrome">google-chrome</h4>

<p>如果你的机器上装有 Chrome 浏览器， 就装了 <code>google-chrome</code> 这个命令行工具，输入下列命令</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">google-chrome --app=<span style="font-style:italic">&#34;https://wx.qq.com&#34;</span></code></pre></div>
<p>可将网页单独作为一个 App 运行在一个进程中， 并且隐藏掉了顶部的搜索框。 在 <code>Launcher</code> 上微信网页版和 Chrome 浏览器是两个分开的图标。 但是 Icon 还是一样的，有时候容易混淆。</p>

<h4 id="nativefier">nativefier</h4>

<p>你也许听说过 <a href="https://github.com/electron/electron">Electron</a> 可以通过Web技术开发桌面应用。 推荐一个<a href="https://github.com/jiahaog/nativefier">工具</a>，可以将任何的的在线网页变成一个桌面应用。首先你需要安装 <code>Node</code> 环境，然后安装 <code>Electron</code> 和 <code>Nativefier</code>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">npm install electron nativefier -g</code></pre></div>
<p>然后运行下列命令，将微信网页版转换为本地应用，请先下载一张微信的图标，假如保存路径为 /tmp/wechat.png。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">nativefier --name <span style="font-style:italic">&#34;wechat&#34;</span> --icon <span style="font-style:italic">&#34;/tmp/wechat.png&#34;</span> <span style="font-style:italic">&#34;https://wx.qq.com&#34;</span></code></pre></div>
<p>这样就在当前路径下生成了微信的本地应用， 目录为 <code>wechat-linux-x64</code>，执行<code>./wechat</code>打开微信应用，打开之后，以后就可以在 Launcher 打开了， 不需要每次都执行命令。</p>

<figure>
    <img src="https://quqiuzhu-com.oss-cn-beijing.aliyuncs.com/img/2019-05-30-wechat-files.png?Expires=1563682577&amp;OSSAccessKeyId=TMP.hY1Rks4nFtEbn2ikYCcCUBXRArhLj38dbXFR1fQhzeTSxf6e49HTUE6K5oc7Qpf2V5wcNuCQ5YqqNiRUFkKFmfCdvTD7z98qY7YwNcghNb6E22XjC4dbM64Pccyv6B.tmp&amp;Signature=y37%2BPDPUD3g62t1%2BRoKqtFYaYmg%3D"/> 
</figure>


<p>制作脚本，请将 icon 换成你自己的路径</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="">#!/usr/bin/bash
</span><span style=""></span>
<span style="font-style:italic"># install nodejs</span>
sudo apt install nodejs

<span style="font-style:italic"># install electron</span>
sudo ELECTRON_MIRROR=<span style="font-style:italic">&#34;https://npm.taobao.org/mirrors/electron/&#34;</span> <span style="font-weight:bold;font-style:italic">\
</span><span style="font-weight:bold;font-style:italic"></span>npm install -g electron --unsafe-perm=true --allow-root

<span style="font-style:italic"># install nativefier</span>
sudo ELECTRON_MIRROR=<span style="font-style:italic">&#34;https://npm.taobao.org/mirrors/electron/&#34;</span> <span style="font-weight:bold;font-style:italic">\
</span><span style="font-weight:bold;font-style:italic"></span>npm install -g nativefier --unsafe-perm=true --allow-root

<span style="font-style:italic"># make wechat app</span>
nativefier --name <span style="font-style:italic">&#34;wechat&#34;</span> <span style="font-weight:bold;font-style:italic">\
</span><span style="font-weight:bold;font-style:italic"></span>--icon <span style="font-style:italic">&#34;/data/deps/wechat/1200px-WeChat_logo.svg.png&#34;</span> <span style="font-weight:bold;font-style:italic">\
</span><span style="font-weight:bold;font-style:italic"></span><span style="font-style:italic">&#34;https://wx.qq.com&#34;</span> --unsafe-perm=true --allow-root

<span style="font-style:italic"># launch wechat</span>
cd wechat-linux-x64
./wechat</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>打造一款直播硬件</title>
            <link>https://quqiuzhu.com/2017/build-yunxibox/</link>
            <pubDate>Sun, 04 Jun 2017 15:26:03 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2017/build-yunxibox/</guid>
            <description>离上次写博客已经过去6个月了， 这段时间我一直在做一款直播硬件「云犀BOX」，现在产品已经日臻完善，开始对外销售了。在我们公司云犀直播的官网上可以看到它的一些介绍。
与一般的手机直播不一样，我们追求的是专业级的高质量的直播。 手机摄像头因为诸多限制，应用在稍微大一些的场景的话效果会差很多。 专业直播的应用场景一开始是一些电视媒体，体育赛事直播等。在我们发布「云犀BOX」之前，专业直播是比较困难，花费人力和财力的事情。 一般专业直播的流程是这样的:
 A公司要准备一场发布会直播，它先去找企业直播服务公司B建立一个直播活动(直播间)，设置好直播间的封面，和其他一些公司宣传的内容。 之后B公司派员工C到直播现场执行直播，员工C带上摄像机、upmost(视频采集卡)和笔记本电脑，摄像机连接视频采集卡，视频采集卡连接到电脑，配置电脑上的OBS(专业直播软件)，设置好RTMP推流地址，然后开始直播。
 对于需求方和提供直播服务的公司来说，人都是一个瓶颈。近两年来，直播作为一种内容形式被广泛接受，一些公司已经用直播作为其日常与用户沟通的渠道，比如「得到」的周会直播。这些公司和团体并没有专业的知识，搭建一个公司的直播频道的有可能只是初入职场的一个运营实习生，所以直播应该更加简单，让普通人第一次上手就会用。
所以我们做了这款「云犀BOX」，只需要一个摄像机，一根HDMI线，一个比手机稍大的「云犀BOX」连上之后点击开始直播就好了。摄像机和「云犀BOX」可以通过热靴云台连在一起，如果扛摄像机直播的话也会非常方便。
「云犀BOX」是由完全自主研发的一款产品，能自己做的都自己做了，包括直播推流SDK、板卡设计、外观设计等，当然也包含了里面的软件，我们就此申请了3款专利。
其中软件部分最核心的是推流SDK，我们花了很长时间优化，前三个月一直在搞推流SDK，后面也一直有优化。其实各个视频云平台都有推流SDK，比如七牛、阿里云。为了能够针对我们的硬件进行优化，我们选择重新实现，现在推流的流畅性与稳定性比平均水平高很多的。
硬件部分，从包装到电源板卡芯片，任何可能出错的地方都出错过，不可能出错的地方也出错过，因此推出时间比我们预想的要迟一个半月左右。即便这样，这款硬件能在半年内做出来并上市，让我感受到了中国硬件产业链的成熟。
人工智能时代，科技公司不应该只玩软件了，还需要会玩硬件和算法的。</description>
            <content type="html"><![CDATA[<p>离上次写博客已经过去6个月了， 这段时间我一直在做一款直播硬件「云犀BOX」，现在产品已经日臻完善，开始对外销售了。在我们公司<a href="http://yunxi.tv/site/box">云犀直播</a>的官网上可以看到它的一些介绍。</p>

<!-- more -->

<p>与一般的手机直播不一样，我们追求的是专业级的高质量的直播。 手机摄像头因为诸多限制，应用在稍微大一些的场景的话效果会差很多。 专业直播的应用场景一开始是一些电视媒体，体育赛事直播等。在我们发布「云犀BOX」之前，专业直播是比较困难，花费人力和财力的事情。 一般专业直播的流程是这样的:</p>

<blockquote>
<p>A公司要准备一场发布会直播，它先去找企业直播服务公司B建立一个直播活动(直播间)，设置好直播间的封面，和其他一些公司宣传的内容。 之后B公司派员工C到直播现场执行直播，员工C带上摄像机、upmost(视频采集卡)和笔记本电脑，摄像机连接视频采集卡，视频采集卡连接到电脑，配置电脑上的OBS(专业直播软件)，设置好RTMP推流地址，然后开始直播。</p>
</blockquote>

<p>对于需求方和提供直播服务的公司来说，人都是一个瓶颈。近两年来，直播作为一种内容形式被广泛接受，一些公司已经用直播作为其日常与用户沟通的渠道，比如「得到」的周会直播。这些公司和团体并没有专业的知识，搭建一个公司的直播频道的有可能只是初入职场的一个运营实习生，所以直播应该更加简单，让普通人第一次上手就会用。</p>

<p>所以我们做了这款「云犀BOX」，只需要一个摄像机，一根HDMI线，一个比手机稍大的「云犀BOX」连上之后点击开始直播就好了。摄像机和「云犀BOX」可以通过热靴云台连在一起，如果扛摄像机直播的话也会非常方便。</p>

<p>「云犀BOX」是由完全自主研发的一款产品，能自己做的都自己做了，包括直播推流SDK、板卡设计、外观设计等，当然也包含了里面的软件，我们就此申请了3款专利。</p>

<p>其中软件部分最核心的是推流SDK，我们花了很长时间优化，前三个月一直在搞推流SDK，后面也一直有优化。其实各个视频云平台都有推流SDK，比如七牛、阿里云。为了能够针对我们的硬件进行优化，我们选择重新实现，现在推流的流畅性与稳定性比平均水平高很多的。</p>

<p>硬件部分，从包装到电源板卡芯片，任何可能出错的地方都出错过，不可能出错的地方也出错过，因此推出时间比我们预想的要迟一个半月左右。即便这样，这款硬件能在半年内做出来并上市，让我感受到了中国硬件产业链的成熟。</p>

<p>人工智能时代，科技公司不应该只玩软件了，还需要会玩硬件和算法的。</p>
]]></content>
        </item>
        
        <item>
            <title>再见路口</title>
            <link>https://quqiuzhu.com/2016/goodbye-lukou/</link>
            <pubDate>Sat, 26 Nov 2016 03:58:25 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/goodbye-lukou/</guid>
            <description>今天办完离职手续，退出路口的微信群和QQ群，我正式离开了我的第一家公司。
14年12月，刚创立4个月的路口团队去浙大校招，那时候去听宣讲会的人只有11人，其中3人来了路口。子扬和小萌都相继离开了，这次我离职之后，我们那一批校招进来的人，都走了。
我是当天面试完就签了三方协议，但因为学校有考试，春节之后的3月9日才正式入职。入职之后一个月，我和带我的老大君涵开发了路口 android 1.1 版。那时的我，虽然是一个实习生，但我觉得我干了一个正式员工的活。那时候，我的自行车还没有被偷，我常常和子扬在晚上10:30之后一起骑车回学校。那时候Uber刚开始在杭州宣传，我3月15日注册了Uber。11月14号Uber发信息给我，说我已经注册610天了，今天25号，我正式离职，所以推算下来，我在路口的时间是627天。
此后，我请两个月假回学校写毕业论文。在此期间，公司也发生了一些事情，导致君涵，子扬，刀哥相继离开。后来我回到公司继续实习，但浙大的毕业程序非常烦，我得经常从学校跑，再加上我需要准备一些考试，很累。直到7月初拿到毕业证，我从实习生转正，正式入职路口。
公司地址也从城市心境的住宅搬到了数字娱乐产业园。那时网络总是掉线，大家都一直抱怨，东哥叫我来负责这件事情，我压力很大，后来我找到了思科的专业设备，解决了网络掉线的问题。在数字娱乐产业园的时间非常短，就从6月到9月，在那里开发了路口 android 2.0版，增加了专辑功能。我记得清楚，是因为那是15年的中秋，公司正要从数字娱乐产业园搬出来，我们去高技街的beta咖啡开发了2.0版。因为嫌他们太吵，我们还刻意躲着运营团队的人。
之后公司搬到了文二西路，我个人做了一个比较失败的项目，hadoop项目。然后做了路口的 android 3.0版，这一版相当难产，前前后后拖了一个半月，上线之后效果也不好，留存率一直往下掉。此后，路口暂停产品更新。
年终时，公司组织了去日本旅游，去买了好多东西。我和博士去镰仓看了拍摄「灌篮高手」的中学，去海滩边坐了坐，然后在附近找吃的。还去了江之岛，我们到那时，正是日落时分，海边吹来温暖的风。
16年春节之后，由于hadoop项目不成功，我们决定不搭建自己的云平台，转而采用阿里的大数据计算服务。我做了ODPS项目，把路口的离线数据分析转移到了云端。之后我开始做后端，后端有好多事情，除了写API之外，还有后台管理，反垃圾，抓取，性能优化等事情。
10月之后，公司决定做一款新产品「熊猫海淘」，我又回来做android了，开发了1.0版，用了很多之前没用的技术。
11月开发完之后我决定辞职，对我来说这是职业上的选择，但却很舍不得路口的人。好多人都一起吃过饭，没吃饭的也大多有过沟通。都说继续保持联系，但离职实实在在的就是一场告别。我问过之前离职的同事，他们都慢慢地减少了和路口的联系；从我个人经验上来说，每次毕业之后，最好的朋友也联系得非常少了。是的，路口最好的朋友也会慢慢走远。
今天去办理离职手续，跟主管和高层有非常友好的沟通，中午跟路口的好朋友一起喝咖啡，听了技术部的分享，晚上跟路口的朋友一起吃饭、看电影。这个让我发恼骚想离开的公司，在离别之际竟然给我如此多的感动。
再见路口！</description>
            <content type="html"><![CDATA[<p>今天办完离职手续，退出路口的微信群和QQ群，我正式离开了我的第一家公司。</p>

<!-- more -->

<p>14年12月，刚创立4个月的路口团队去浙大校招，那时候去听宣讲会的人只有11人，其中3人来了路口。子扬和小萌都相继离开了，这次我离职之后，我们那一批校招进来的人，都走了。</p>

<p>我是当天面试完就签了三方协议，但因为学校有考试，春节之后的3月9日才正式入职。入职之后一个月，我和带我的老大君涵开发了路口 android 1.1 版。那时的我，虽然是一个实习生，但我觉得我干了一个正式员工的活。那时候，我的自行车还没有被偷，我常常和子扬在晚上10:30之后一起骑车回学校。那时候Uber刚开始在杭州宣传，我3月15日注册了Uber。11月14号Uber发信息给我，说我已经注册610天了，今天25号，我正式离职，所以推算下来，我在路口的时间是627天。</p>

<p>此后，我请两个月假回学校写毕业论文。在此期间，公司也发生了一些事情，导致君涵，子扬，刀哥相继离开。后来我回到公司继续实习，但浙大的毕业程序非常烦，我得经常从学校跑，再加上我需要准备一些考试，很累。直到7月初拿到毕业证，我从实习生转正，正式入职路口。</p>

<p>公司地址也从城市心境的住宅搬到了数字娱乐产业园。那时网络总是掉线，大家都一直抱怨，东哥叫我来负责这件事情，我压力很大，后来我找到了思科的专业设备，解决了网络掉线的问题。在数字娱乐产业园的时间非常短，就从6月到9月，在那里开发了路口 android 2.0版，增加了专辑功能。我记得清楚，是因为那是15年的中秋，公司正要从数字娱乐产业园搬出来，我们去高技街的beta咖啡开发了2.0版。因为嫌他们太吵，我们还刻意躲着运营团队的人。</p>

<p>之后公司搬到了文二西路，我个人做了一个比较失败的项目，hadoop项目。然后做了路口的 android 3.0版，这一版相当难产，前前后后拖了一个半月，上线之后效果也不好，留存率一直往下掉。此后，路口暂停产品更新。</p>

<p>年终时，公司组织了去日本旅游，去买了好多东西。我和博士去镰仓看了拍摄「灌篮高手」的中学，去海滩边坐了坐，然后在附近找吃的。还去了江之岛，我们到那时，正是日落时分，海边吹来温暖的风。</p>

<p>16年春节之后，由于hadoop项目不成功，我们决定不搭建自己的云平台，转而采用阿里的大数据计算服务。我做了ODPS项目，把路口的离线数据分析转移到了云端。之后我开始做后端，后端有好多事情，除了写API之外，还有后台管理，反垃圾，抓取，性能优化等事情。</p>

<p>10月之后，公司决定做一款新产品「熊猫海淘」，我又回来做android了，开发了1.0版，用了很多之前没用的技术。</p>

<p>11月开发完之后我决定辞职，对我来说这是职业上的选择，但却很舍不得路口的人。好多人都一起吃过饭，没吃饭的也大多有过沟通。都说继续保持联系，但离职实实在在的就是一场告别。我问过之前离职的同事，他们都慢慢地减少了和路口的联系；从我个人经验上来说，每次毕业之后，最好的朋友也联系得非常少了。是的，路口最好的朋友也会慢慢走远。</p>

<p>今天去办理离职手续，跟主管和高层有非常友好的沟通，中午跟路口的好朋友一起喝咖啡，听了技术部的分享，晚上跟路口的朋友一起吃饭、看电影。这个让我发恼骚想离开的公司，在离别之际竟然给我如此多的感动。</p>

<p>再见路口！</p>
]]></content>
        </item>
        
        <item>
            <title>React Native</title>
            <link>https://quqiuzhu.com/2016/react-native/</link>
            <pubDate>Sun, 30 Oct 2016 02:09:53 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/react-native/</guid>
            <description>最近公司开发了一款叫「熊猫洋货」的APP，学习了一些 React Native 的知识，在这里进行一下总结
 环境搭建 React Native 页面 原生应用集成  环境搭建 因为我是一名使用 Mac 的 Android 开发者，所以 Mac下的 Android 环境、HomeBrew 包管理器都已具备。只需要装 Node 和 React Native 命令行工具即可。 安装 Node 主要是希望使用其包管理工具 npm 。安装命令如下
brew install node npm install -g react-native-cli 在此提醒一下，请注意 HomeBrew 的提示，如果有命令没有安装成功，按照 HomeBrew 的提示操作。
React Native 页面 React 推荐使用 JSX 语法来写页面，因为其可读性较强。因为 JSX 是一种类 XML 的语法，对于习惯于使用布局文件的 Android 开发者来说并不陌生。 使用 React Component 来开发我们的应用界面
class Greeting extends Component { render() { return ( &amp;lt;Text&amp;gt;Hello world!</description>
            <content type="html"><![CDATA[

<p>最近公司开发了一款叫「熊猫洋货」的APP，学习了一些 React Native 的知识，在这里进行一下总结</p>

<ol>
<li>环境搭建</li>
<li>React Native 页面</li>
<li>原生应用集成</li>
</ol>

<!-- more -->

<h2 id="环境搭建">环境搭建</h2>

<p>因为我是一名使用 Mac 的 Android 开发者，所以 Mac下的 Android 环境、HomeBrew 包管理器都已具备。只需要装 Node 和 React Native 命令行工具即可。 安装 Node 主要是希望使用其包管理工具 npm 。安装命令如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">brew install node
npm install -g react-native-cli</pre></div>
<p>在此提醒一下，请注意 HomeBrew 的提示，如果有命令没有安装成功，按照 HomeBrew 的提示操作。</p>

<h2 id="react-native-页面">React Native 页面</h2>

<p>React 推荐使用 JSX 语法来写页面，因为其可读性较强。因为 JSX 是一种类 XML 的语法，对于习惯于使用布局文件的 Android 开发者来说并不陌生。 使用 React Component 来开发我们的应用界面</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class Greeting extends Component {
  render() {
    return (
      &lt;Text&gt;Hello world!&lt;/Text&gt;
    );
  }
}</pre></div>
<p>通过 XML 能给 Componet 传递属性，Component 内部能够通过 <code>this.props</code> 获取到该属性。比如从上面的例子改为从外部接受属性参数的形式。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class Greeting extends Component {
  render() {
    return (
      &lt;Text&gt;this.props.words&lt;/Text&gt;
    );
  }
}

class App extends Component {
  render() {
    return (
      &lt;Greeting words=&#39;Hello world!&#39;/&gt;
      &lt;Greeting words=&#39;你好!&#39;/&gt;
    );
  }
}</pre></div>
<p>在一个 Component 里面，props 的值是不会变的，如果在 Component 的生命周期内需要改变样式，需要使用 state。 下面该组件一会显示 Hello world!， 一会又显示 你好!</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class Greeting extends Component {
  constructor(props) {
    super(props);
    this.state = { engish: true };

    setInterval(() =&gt; {
      this.setState({ engish: !this.state.engish });
    }, 1000);
  }
  
  render() {
    return (
      &lt;Text&gt;this.state.english ? &#39;Hello world!&#39; : &#39;你好!&#39; &lt;/Text&gt;
    );
  }
}</pre></div>
<p>Component 能通过 StyleSheet 指定样式, flexbox 布局进行定位元素位置。 上述页面使用 StyleSheet</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class Greeting extends Component {
  render() {
    return (
      &lt;Text style={styles.bigblue}&gt;Hello world!&lt;/Text&gt;
    );
  }
}

const styles = StyleSheet.create({
  bigblue: {
    color: &#39;blue&#39;,
    fontWeight: &#39;bold&#39;,
    fontSize: 30,
    flex: 1,
    alignSelf: &#39;center&#39;
  }
)</pre></div>
<h2 id="原生应用集成">原生应用集成</h2>

<p>在 Application 中加入下列代码，并将 React 写成的页面打成 bundle 放到 src/assets 下, 并命名为 index.android.js。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"> ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
   @Override
   public boolean getUseDeveloperSupport() {
       return false;
   }

   @Override
   public List&lt;ReactPackage&gt; getPackages() {
       return Arrays.&lt;ReactPackage&gt;asList(
               new MainReactPackage(),
               new YourReactPackage()
       );
   }
};

@Override
public ReactNativeHost getReactNativeHost() {
   return mReactNativeHost;
}</pre></div>
<p>然后在需要使用 React 的页面使用 ReactRootView 代替，并在该页面维持 ReactInstanceManager 的状态。使用下面的就能展示 React 写的页面了。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">mReactRootView.startReactApplication(reactInstancemanager, moduleName, bundle);</pre></div>
<p>reactInstancemanager 为 Application 中维护的同一个 reactInstancemanager 可以通过 getReactNativeHost.getReactInstanceManager() 获取。</p>

<p>moduleName 为当前页面的模块名</p>

<p>bundle 为 Native 传给 React 的参数</p>

<h3 id="react-如何调用-native-方法">React 如何调用 Native 方法</h3>

<p>可以在 ReactPackage 中返回给 React 一些 Native 实现的 module 实例如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class YourReactPackage implements ReactPackage {

    @Override
    public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() {
        return Collections.emptyList();
    }

    @Override
    public List&lt;ViewManager&gt; createViewManagers(
    		ReactApplicationContext reactContext) {
        return Collections.emptyList();
    }

    @Override
    public List&lt;NativeModule&gt; createNativeModules(
            ReactApplicationContext reactContext) {
        List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;();
        modules.add(new YourModule(reactContext));
        return modules;
    }
}

public class YourModule extends ReactContextBaseJavaModule {

    public YourModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    public YourModule(ReactApplicationContext reactContext, 
    							Context context) {
        super(reactContext);
    }

    @ReactMethod
    public void event(String name){
    }</pre></div>
<p>然后在 React 中可以通过 <code>NativeModules.YourModule</code> 访问到 Native 方法，比如上面实现的 event 方法。</p>

<h3 id="native-如何调用-react-方法">Native 如何调用 React 方法</h3>

<p>Native 主动与 React 沟通的方式，不是调用 React 方法，而是用事件通知的方式。首先看 Native 如何发通知。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public void sendReactEvent(String eventName， WriteableMap params) {
   reactInstanceManager.getCurrentReactContext()
   		.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
			.emit(eventName, params);
}</pre></div>
<p>Reac 方面，使用下面的方法监听 Native 发来的事件并作出反应。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">DeviceEventEmitter.addListener(eventName, (params) =&gt; {
	// Do Something
})</pre></div>]]></content>
        </item>
        
        <item>
            <title>Dagger 2 学习笔记</title>
            <link>https://quqiuzhu.com/2016/dagger2/</link>
            <pubDate>Sun, 09 Oct 2016 08:31:11 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/dagger2/</guid>
            <description>国庆假期学习了 Dagger 2, 在这里进行一些总结。 Dagger 2 是一个由 Google 工程师开发的依赖注入库，该项目 fork 自在 Square 工作的前 Google 工程师开发的 Dagger 1。
如果你想了解 Dagger 2 的基本概念和使用方式，推荐看 Codepath 的这篇文章 Dependency Injection with Dagger 2。Dagger 2 通过注解 @Module 和 @Provide 标注提供依赖的类和方法, 通过 @Inject 标注请求依赖的实例, 通过 @Component 将两者连接起来, 而且提供了其他的一些 Feature。看完这些之后，你可能会有两个问题
 为什么要重新开发 Dagger 2, Dagger 1 哪里不好？ 我现在知道怎么用了, 但是它是怎么实现的？  第一个问题，在 Google 开发者大会上，Dagger 2 的开发者的演讲 DAGGER 2 - A New Type of dependency injection 中，不仅讲了 Dagger 1的优缺点，还讲了依赖注入如何从 Spring -&amp;gt; Guice -&amp;gt; Dagger 1 -&amp;gt; Dagger 2。 Spring 主要的缺点是繁琐, 那段替代复杂的依赖注入的 XML 和原来的 Java 代码一样丑陋；Guice 的缺点是图错误在运行时才能发现，并且开发者难以调试；Dagger 1 的缺点是，生成的代码丑陋，出错难以调试，并且运行时开销不可忽视；Dagger 2在 Dagger 1 的基础上，解决了性能问题，并且生成的代码更加优雅。</description>
            <content type="html"><![CDATA[

<p>国庆假期学习了 <a href="https://github.com/google/dagger">Dagger 2</a>, 在这里进行一些总结。 Dagger 2 是一个由 Google 工程师开发的依赖注入库，该项目 fork 自在 Square 工作的前 Google 工程师开发的 <a href="https://github.com/square/dagger">Dagger 1</a>。</p>

<p>如果你想了解 Dagger 2 的基本概念和使用方式，推荐看 Codepath 的这篇文章 <a href="https://github.com/codepath/android_guides/wiki/Dependency-Injection-with-Dagger-2">Dependency Injection with Dagger 2</a>。Dagger 2 通过注解 <code>@Module</code> 和 <code>@Provide</code> 标注提供依赖的类和方法, 通过 <code>@Inject</code> 标注请求依赖的实例, 通过 <code>@Component</code> 将两者连接起来, 而且提供了其他的一些 Feature。看完这些之后，你可能会有两个问题</p>

<ol>
<li>为什么要重新开发 Dagger 2, Dagger 1 哪里不好？</li>
<li>我现在知道怎么用了, 但是它是怎么实现的？</li>
</ol>

<p>第一个问题，在 Google 开发者大会上，Dagger 2 的开发者的演讲 <a href="https://www.youtube.com/watch?v=oK_XtfXPkqw">DAGGER 2 - A New Type of dependency injection</a> 中，不仅讲了 Dagger 1的优缺点，还讲了依赖注入如何从 Spring -&gt; Guice -&gt; Dagger 1 -&gt; Dagger 2。 Spring 主要的缺点是繁琐, 那段替代复杂的依赖注入的 XML 和原来的 Java 代码一样丑陋；Guice 的缺点是图错误在运行时才能发现，并且开发者难以调试；Dagger 1 的缺点是，生成的代码丑陋，出错难以调试，并且运行时开销不可忽视；Dagger 2在 Dagger 1 的基础上，解决了性能问题，并且生成的代码更加优雅。</p>

<p>第二个问题，其实在上面提到的 <a href="https://www.youtube.com/watch?v=oK_XtfXPkqw">DAGGER 2 - A New Type of dependency injection</a> 的演讲中，Dagger 2 的开发者已经解释了他们是如何设计 Dagger 2 的。但他使用CoffeeMaker 来举例，而我对 CoffeeMaker 并不熟悉，因此每当看到 Heater 和 Pump 的时候就在想它到底是什么，也许我应该好好玩一下公司的咖啡机。相比之下，我更喜欢 <a href="http://jakewharton.com">Jake Wharton</a>的演讲 <a href="https://www.youtube.com/watch?v=plK0zyRLIP8">Jake Wharton&rsquo;s Devoxx Dagger 2 Talk</a>。</p>

<!-- more -->

<h2 id="dagger使用">Dagger使用</h2>

<ul>
<li>时间安排2天, 包含玩一下 dagger 项目中的例子程序</li>
<li>annotation processors compile-time checks 在编译时检测, 所以运行时很高效</li>
<li>简化共享实例的访问</li>
<li>易于配置复杂依赖</li>
<li>更容易的单元测试和集成测试</li>
<li>限定实例, 易于管理实例的生成和销毁</li>
</ul>

<h3 id="creating-singletons">Creating Singletons</h3>

<ul>
<li>@Module Dagger 模块, Dagger 在此寻找可以构造某个对象的实例的方法</li>
<li>@Module 可以用来解决依赖关系, 定义所依赖的对象</li>
<li>@Provides 提供类的实例的构造方式</li>
<li>@Singleton 告诉 Dagger 编译器, 在某个周期内, 只能创建一次实例</li>
<li>@Provides 修饰的方法, 根据参数来实例化某个对象, 而实例提供者, 是某个 @Module 中的一个返回值与参数相同的方法(同样被 @Provides 修饰)</li>
<li>@Component(modules={AppModule.class, NetModule.class}) 注解组件, 参数注明提供注解的类, 需要为所有需要被注解的类, 写不同的 inject()方法, 如以下代码所示</li>
<li>Dagger 注解不能修饰父类, 其依赖强类型</li>
<li>@Component 修饰的接口, 最终会生成一个以 Dagger 开始的一个类, 比如以下代码生成 DaggerNetComponent 类</li>
<li>在 Application 中初始化相关 Component</li>

<li><p>在需要注入的类中, 使用已经实例化的 Component, 调用其 inject() 方法</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Singleton
@Component(modules={AppModule.class, NetModule.class})
<span style="font-weight:bold">public</span> interface NetComponent {
<span style="">void</span> inject(MainActivity activity);
<span style="font-style:italic">// void inject(MyFragment fragment);
</span><span style="font-style:italic">// void inject(MyService service);
</span><span style="font-style:italic"></span>}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-weight:bold">public</span> class MyApp extends Application {

<span style="font-weight:bold">private</span> NetComponent mNetComponent;

@Override
<span style="font-weight:bold">public</span> void onCreate() {
    <span style="font-weight:bold">super</span>.onCreate();

    <span style="font-style:italic">// Dagger%COMPONENT_NAME%
</span><span style="font-style:italic"></span>    mNetComponent = DaggerNetComponent.builder()
            <span style="font-style:italic">// list of modules that are part of this component need to be created here too
</span><span style="font-style:italic"></span>            .appModule(<span style="font-weight:bold">new</span> AppModule(<span style="font-weight:bold">this</span>)) <span style="font-style:italic">// This also corresponds to the name of your module: %component_name%Module
</span><span style="font-style:italic"></span>            .netModule(<span style="font-weight:bold">new</span> NetModule(<span style="font-style:italic">&#34;https://api.github.com&#34;</span>))
            .build();

    <span style="font-style:italic">// If a Dagger 2 component does not have any constructor arguments for any of its modules,
</span><span style="font-style:italic"></span>    <span style="font-style:italic">// then we can use .create() as a shortcut instead:
</span><span style="font-style:italic"></span>    <span style="font-style:italic">//  mNetComponent = com.codepath.dagger.components.DaggerNetComponent.create();
</span><span style="font-style:italic"></span>}

<span style="font-weight:bold">public</span> NetComponent getNetComponent() {
   <span style="font-weight:bold">return</span> mNetComponent;
}
}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-weight:bold">public</span> class MyActivity extends Activity {
@Inject OkHttpClient mOkHttpClient;
@Inject SharedPreferences sharedPreferences;

<span style="font-weight:bold">public</span> void onCreate(Bundle savedInstance) {
    <span style="font-style:italic">// assign singleton instances to fields
</span><span style="font-style:italic"></span>    <span style="font-style:italic">// We need to cast to `MyApp` in order to get the right method
</span><span style="font-style:italic"></span>    ((MyApp) getApplication()).getNetComponent().inject(<span style="font-weight:bold">this</span>);
}
}</code></pre></div></li>
</ul>

<h3 id="qualified-types">Qualified types</h3>

<ul>
<li>@Provides 如果提供了返回一种类型的多种方法, 到到底选择哪一个呢, 就可以通过限定符来指定</li>

<li><p>通过 Dagger 提供的 @Qualifier 注解可以定义限定符, 就像定义 annotation 一样</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Provides @Named(<span style="font-style:italic">&#34;cached&#34;</span>)
@Singleton
OkHttpClient provideOkHttpClient(Cache cache) {
OkHttpClient client = <span style="font-weight:bold">new</span> OkHttpClient();
client.setCache(cache);
<span style="font-weight:bold">return</span> client;
}

@Provides @Named(<span style="font-style:italic">&#34;non_cached&#34;</span>) @Singleton
OkHttpClient provideOkHttpClient() {
OkHttpClient client = <span style="font-weight:bold">new</span> OkHttpClient();
<span style="font-weight:bold">return</span> client;
}

@Inject @Named(<span style="font-style:italic">&#34;cached&#34;</span>) OkHttpClient client;
@Inject @Named(<span style="font-style:italic">&#34;non_cached&#34;</span>) OkHttpClient client2;

@Qualifier
@Documented
@Retention(RUNTIME)
<span style="font-weight:bold">public</span> @interface DefaultPreferences {
}</code></pre></div></li>
</ul>

<h3 id="scopes">Scopes</h3>

<ul>
<li>Scopes 是用来管理各种 Component 的生命周期的, 或者说是管理其使用范围的</li>

<li><p>可以通过 Dagger 提供的注解 @Scope 来定制自己的 Scope, 但如何实现没有详细说明</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Scope
@Documented
@Retention(value=RetentionPolicy.RUNTIME)
<span style="font-weight:bold">public</span> @interface MyActivityScope
{
}</code></pre></div></li>
</ul>

<h3 id="dependent-components-or-subcomponents">dependent components or subcomponents</h3>

<ul>
<li>Component 并非一定要一直存在, 有些 Component 只存在于一个 Activity 的周期之内, 或者等到 User login 之后才能做事</li>
<li>dependent components 是父类指定可以注入的类, 子Component去按照指定的实现, 父类去掉 inject 函数, 由子类独立实现</li>
<li>两个 dependent components 不能享有同一个 Scope, 原因是因为 <a href="https://github.com/google/dagger/issues/107#issuecomment-71073298" title="循环依赖">循环依赖</a> 还是什么, 暂时看不太懂, 先略过</li>
<li>虽然 Dagger 有能力创建 Scoped Component, 但需要开发者来实现与此 Scope 一致的行为, Dagger 并不清楚开发者是怎么实现的。 stackoverflow 上面有相关 <a href="http://stackoverflow.com/questions/28411352/what-determines-the-lifecycle-of-a-component-object-graph-in-dagger-2" title="讨论">讨论</a>, 详细看完 Scope 之后再细看</li>
<li>一个 dependent components <a href="https://github.com/codepath/dagger2-example" title="dagger2-example">例程</a></li>
<li>dependent components 继承, subcomponents 组合</li>
<li>看过 <a href="https://github.com/vinc3m1/nowdothis" title="nowdothis">Dagger demo</a> 得出结论, Scope 就是个标识, 其规范在哪些范围使用, 范围是什么主要看 Component 是什么时候创建的, 比如有个 ImgurActivityComponent, 其初始化是在 ImgurUploadActivity 的 onCreate 方法内, 这些行为都遵守了 @PerImgurActivity 这个 Scope 的约定, 如果有人在另外的 Activity 中创建 ImgurActivityComponent, 使用其注入了某个类, 开发者可以实现, 但是这个 Scope 就被破坏了。</li>
<li>另外可以使用 @Inject 修饰 Constructor, 使其能够被用来注入, 但是什么时候使用 @Inject, 什么时候使用 @Provide 肯定有个优先级的。</li>
<li>Constructor Injection 的两种方式如下, @Inject 和 @Provide</li>

<li><p>Lazy injections</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-style:italic">// parent component
</span><span style="font-style:italic"></span>@Singleton
@Component(modules={AppModule.class, NetModule.class})
<span style="font-weight:bold">public</span> interface NetComponent {
<span style="font-style:italic">// remove injection methods if downstream modules will perform injection
</span><span style="font-style:italic"></span>
<span style="font-style:italic">// downstream components need these exposed
</span><span style="font-style:italic">// the method name does not matter, only the return type
</span><span style="font-style:italic"></span>Retrofit retrofit();
OkHttpClient okHttpClient();
SharedPreferences sharedPreferences();
}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Provides MyThing provideMyThing(
		SharedPreferences sp,
		Context context) {

	<span style="font-weight:bold">return</span> <span style="font-weight:bold">new</span> MyThing(sp, context);
}

@PerApp
<span style="font-weight:bold">class</span> MyThing {

	<span style="font-weight:bold">private</span> final SharedPRefs<span style="">…</span>
	<span style="font-weight:bold">private</span> final Context ...

	@Inject <span style="font-weight:bold">public</span> MyThing(
SharedPreferences sp,
		Context context) {

	}
}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Inject Lazy&lt;SharedPreferences&gt; mLazySharedPrefs;
<span style="">void</span> onSaveBtnClicked() {
mLazySharedPrefs.get()
            .edit().putString(<span style="font-style:italic">&#34;status&#34;</span>, <span style="font-style:italic">&#34;lazy...&#34;</span>)
            .apply();
}</code></pre></div></li>
</ul>

<h3 id="相关资料">相关资料</h3>

<ul>
<li><a href="https://docs.google.com/presentation/d/1bkctcKjbLlpiI0Nj9v0QpCcNIiZBhVsJsJp1dgU5n98/" title="Dagger 2 in Android">Vince Mi&rsquo;s Codepath Meetup Dagger 2 Slides</a></li>
<li><a href="https://speakerdeck.com/jakewharton/dependency-injection-with-dagger-2-devoxx-2014" title="Dependency Injection with Dagger 2 (Devoxx 2014)">Jake Wharton&rsquo;s Devoxx Dagger 2 Slides</a> Tweeter API 设计</li>
<li><a href="https://www.youtube.com/watch?v=plK0zyRLIP8" title="Jake Wharton's Devoxx Dagger 2 Talk">Jake Wharton&rsquo;s Devoxx Dagger 2 Talk</a> 50分钟</li>
<li><a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" title="Dagger 2 Google Developers Talk">Dagger 2 Google Developers Talk</a> 40分钟</li>
<li><a href="https://blog.gouline.net/dagger-2-even-sharper-less-square-b52101863542#.flwjtyxlk" title="Dagger 2: Even sharper, less square">Dagger 2: Even sharper, less square</a> 比较 Dagger 1, 指出3缺点</li>
<li><a href="https://www.youtube.com/watch?v=0XHx9jtxIxU">Architecting Android Applications with Dagger</a> dagger 与 android 构架</li>
</ul>

<h2 id="依赖注入-注解与apt">依赖注入, 注解与APT</h2>

<h3 id="依赖注入">依赖注入</h3>

<ul>
<li>DI, IoC <a href="http://www.martinfowler.com/articles/injection.html" title="Inversion of Control Containers and the Dependency Injection pattern">经典文章</a> 对比 <a href="http://www.cnblogs.com/gaochundong/archive/2013/04/12/service_locator_pattern.html" title="Service Locator 模式">Service Locator 模式</a></li>
<li>三种DI方式

<ol>
<li>Constructor Injection 是根据某种类型, 调用其一个默认实现的子类, Container 会提供一个配置接口, 并且为一个类返回一个默认实现, 当然主要是通过调用其构造方法, 并且可以配置传参</li>
<li>Setter Injection 是在需要被注入的类中有一个 Setter 方法, 用来设置相关依赖, 在此框架会返回一个默认的实现作为参数, Spring 通过 xml 文件配置类的某一个具体实现</li>
<li>Interface Injection 通过声明接口，框架给出默认实现，并且给出关联相关代码，而实现依赖注入, 但这里的例子没有使用注解, 而是直接使用了 Java Code</li>
</ol></li>

<li><p>Service Locator 与 Dependency Injection 比较，两者都是为了去耦合，依赖注入难以理解和调试</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-weight:bold">class</span> MovieLister...
<span style="font-weight:bold">public</span> MovieLister(MovieFinder finder) {
  <span style="font-weight:bold">this</span>.finder = finder;       
}

<span style="font-weight:bold">class</span> ColonMovieFinder...
<span style="font-weight:bold">public</span> ColonMovieFinder(String filename) {
  <span style="font-weight:bold">this</span>.filename = filename;
}

<span style="font-weight:bold">private</span> MutablePicoContainer configureContainer() {
MutablePicoContainer pico = <span style="font-weight:bold">new</span> DefaultPicoContainer();
Parameter[] finderParams =  {<span style="font-weight:bold">new</span> ConstantParameter(<span style="font-style:italic">&#34;movies1.txt&#34;</span>)};
pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);
pico.registerComponentImplementation(MovieLister.class);
<span style="font-weight:bold">return</span> pico;
}

<span style="font-weight:bold">public</span> void testWithPico() {
MutablePicoContainer pico = configureContainer();
MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);
Movie[] movies = lister.moviesDirectedBy(<span style="font-style:italic">&#34;Sergio Leone&#34;</span>);
assertEquals(<span style="font-style:italic">&#34;Once Upon a Time in the West&#34;</span>, movies[0].getTitle());
}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-weight:bold">class</span> MovieLister...
<span style="font-weight:bold">private</span> MovieFinder finder;
<span style="font-weight:bold">public</span> void setFinder(MovieFinder finder) {
<span style="font-weight:bold">this</span>.finder = finder;
}

<span style="font-weight:bold">class</span> ColonMovieFinder...
<span style="font-weight:bold">public</span> void setFilename(String filename) {
  <span style="font-weight:bold">this</span>.filename = filename;
}

&lt;beans&gt;
&lt;bean id=<span style="font-style:italic">&#34;MovieLister&#34;</span> class=<span style="font-style:italic">&#34;spring.MovieLister&#34;</span>&gt;
    &lt;property name=<span style="font-style:italic">&#34;finder&#34;</span>&gt;
        &lt;ref local=<span style="font-style:italic">&#34;MovieFinder&#34;</span>/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=<span style="font-style:italic">&#34;MovieFinder&#34;</span> class=<span style="font-style:italic">&#34;spring.ColonMovieFinder&#34;</span>&gt;
    &lt;property name=<span style="font-style:italic">&#34;filename&#34;</span>&gt;
        &lt;value&gt;movies1.txt&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;/beans&gt;

public <span style="">void</span> testWithSpring() <span style="font-weight:bold">throws</span> Exception {
ApplicationContext ctx = <span style="font-weight:bold">new</span> FileSystemXmlApplicationContext(<span style="font-style:italic">&#34;spring.xml&#34;</span>);
MovieLister lister = (MovieLister) ctx.getBean(<span style="font-style:italic">&#34;MovieLister&#34;</span>);
Movie[] movies = lister.moviesDirectedBy(<span style="font-style:italic">&#34;Sergio Leone&#34;</span>);
assertEquals(<span style="font-style:italic">&#34;Once Upon a Time in the West&#34;</span>, movies[0].getTitle());
}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-weight:bold">public</span> interface InjectFinder {
<span style="">void</span> injectFinder(MovieFinder finder);
}

<span style="font-weight:bold">class</span> MovieLister <span style="font-weight:bold">implements</span> InjectFinder {
<span style="font-weight:bold">public</span> void injectFinder(MovieFinder finder) {
  <span style="font-weight:bold">this</span>.finder = finder;
}
}

<span style="font-weight:bold">public</span> interface Injector {
<span style="font-weight:bold">public</span> void inject(Object target);
}

<span style="font-weight:bold">class</span> ColonMovieFinder <span style="font-weight:bold">implements</span> MovieFinder, Injector {
<span style="font-weight:bold">public</span> void injectFilename(String filename) {
  <span style="font-weight:bold">this</span>.filename = filename;
}
<span style="font-weight:bold">public</span> void inject(Object target) {
((InjectFinder) target).injectFinder(<span style="font-weight:bold">this</span>);        
}
}

<span style="font-weight:bold">class</span> Tester {
<span style="font-weight:bold">private</span> Container container;

<span style="font-weight:bold">private</span> void configureContainer() {
container = <span style="font-weight:bold">new</span> Container();
registerComponents();
registerInjectors();
container.start();
}

<span style="font-weight:bold">private</span> void registerComponents() {
container.registerComponent(<span style="font-style:italic">&#34;MovieLister&#34;</span>, MovieLister.class);
container.registerComponent(<span style="font-style:italic">&#34;MovieFinder&#34;</span>, ColonMovieFinder.class);
}

<span style="font-weight:bold">private</span> void registerInjectors() {
container.registerInjector(InjectFinder.class, container.lookup(<span style="font-style:italic">&#34;MovieFinder&#34;</span>));
}

<span style="font-weight:bold">public</span> void testIface() {
configureContainer();
MovieLister lister = (MovieLister)container.lookup(<span style="font-style:italic">&#34;MovieLister&#34;</span>);
Movie[] movies = lister.moviesDirectedBy(<span style="font-style:italic">&#34;Sergio Leone&#34;</span>);
assertEquals(<span style="font-style:italic">&#34;Once Upon a Time in the West&#34;</span>, movies[0].getTitle());
}
}</code></pre></div></li>
</ul>

<p>首先, 这个 InjectFinder 是被注入的那个类需要实现的接口, 名字有点问题, 难以理解。 需要使用 finder 的类实现 InjectFinder 接口, 会自动注入相关类。 registerComponent 是注册类, 可以通过 lookup 获取其实例。</p>

<p>registerInjector 表达一种关系, 谁注入谁的关系, 上面经过 registerInjectors 之后 InjectFinder 与 ColonMovieFinder 就关联起来了, ColonMovieFinder 会注入到 InjectFinder 里面去。</p>

<h3 id="jsr-330">JSR 330</h3>

<ul>
<li>JSR 330 - 2009 年发布, Spring 2.5 后支持, 依赖注入的标准</li>
<li>@Inject 注入顺序为构造器，字段，最后是方法。超类的字段、方法将优先于子类的字段、方法被注入</li>
<li>@Qualifier 给定的类型 T 与可选的限定器，注入器必须能够注入用户指定的类, 循环依赖, Provider<T> 然后显式调用其 get 方法。</li>
<li>Provider<T> 一般由注入器实现, 可返回多个实例, 而且打破循环依赖的问题</li>
<li>@Named 是默认实现的一个限定器, 参数是一个 String 类型, 大多数时候够用</li>
<li>@Scope 用于标识作用域注解, 重新定义一个新 Scope, 不应该含有属性</li>

<li><p>@Singleton 是一个Scope 实现, 对象只创建一次</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@java.lang.annotation.Documented
@java.lang.annotation.Retention(RUNTIME)
@javax.inject.Scope
<span style="font-weight:bold">public</span> @interface RequestScoped {}</code></pre></div></li>
</ul>

<h3 id="注解及apt">注解及APT</h3>

<ul>
<li>Dagger中, 注解的作用是在编译期间帮助生成代码, 运行时, 与注解已无关系</li>
<li><a href="https://github.com/square/javapoet" title="javapoet">javapoet</a>及其<a href="http://www.jianshu.com/p/95f12f72f69a" title="javapoet——让你从重复无聊的代码中解放出来">详解</a> 用来生成 java 源文件的库</li>
<li>内置注解 &amp; 元注解 &amp; 实现注解 &amp; 注解处理器</li>
<li>注解是一种语法, 怎么处理注解才是最重要的, 我们可以编写一个类实现注解处理, 也可以使用APT</li>
<li>一个编译时注解处理的 <a href="https://github.com/zjutkz/Knight" title="knight">简单实例</a>及其<a href="http://zjutkz.net/2016/04/07/%E4%B8%87%E8%83%BD%E7%9A%84APT%EF%BC%81%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A6%99%E7%94%A8/" title="万能的APT！编译时注解的妙用">详解</a></li>
<li><a href="http://blog.csdn.net/a1018875550/article/details/52166916" title="Android注解-编译时生成代码 (APT)">APT</a> 及相关项目 <a href="https://github.com/a1018875550/ViewInject/tree/master" title="ViewInject">ViewInject</a>, 完整用心地讲了具体实现</li>
<li>@AutoService 可以自动(为 Processor)生成配置信息</li>

<li><p>Android Studio 2.2 已经自带 annotationProcessor, 不再需要 APT, 即便不使用 Java 8</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-style:italic">// 内置注解
</span><span style="font-style:italic">// 方法注解，表示此注解修饰的方法覆盖了父类或是接口的方法
</span><span style="font-style:italic">// 如果不是这样，则输出警告
</span><span style="font-style:italic"></span>@Override

<span style="font-style:italic">// 对于此注解所修饰的对象（类、域、方法等）
</span><span style="font-style:italic">// 当你使用了它们时编译器将输出“已废弃”警告
</span><span style="font-style:italic"></span>@Deprecated

<span style="font-style:italic">// 关闭警告，通过给此注解的元素赋值
</span><span style="font-style:italic">// 可以关闭特定警告
</span><span style="font-style:italic"></span>@SuppressWarnings



<span style="font-style:italic">// 元注解
</span><span style="font-style:italic">// 定义注解所能作用的目标，说明该注解能作用于何种对象（类、方法、域……之类）。
</span><span style="font-style:italic"></span>@Target

<span style="font-style:italic">// 定义注解保存级别
</span><span style="font-style:italic">// 1.源代码注解，被编译器丢弃
</span><span style="font-style:italic">// 2.类注解，class文件中可用，被VM丢弃
</span><span style="font-style:italic">// 3.运行时可用，搭配反射
</span><span style="font-style:italic"></span>@Retention

<span style="font-style:italic">// 标志将此注解包含至javadoc中
</span><span style="font-style:italic"></span>@Documented

<span style="font-style:italic">// 说明假如此注解是类注解而且你在父类中使用此注解，那么子类将会继承此注解
</span><span style="font-style:italic"></span>@Inherited


<span style="font-style:italic">// 实现注解
</span><span style="font-style:italic"></span>@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
<span style="font-weight:bold">public</span> @interface Target {
ElementType[] value() <span style="font-weight:bold">default</span> {ElementType.ANNOTATION_TYPE};
}</code></pre></div></li>
</ul>

<h2 id="dagger-2-源码">Dagger 2 源码</h2>

<ul>
<li>dagger 并不是一个 android project, 而是一个 java project, 构建工具为 maven</li>
<li>maven 构建工具, 它如何构建, 如何集成, 如何打包 之后再说, 但其所有注解打概念得搞清楚</li>
<li>源码 中一大部分是新功能, 新概念, 比如 MultiBindings 支持Set 和 Map的多绑定实现插件式开发; Producer 用来支持异步编程模型, 还是先看文档熟悉一下比较好</li>
</ul>

<h3 id="新概念">新概念</h3>

<ul>
<li>MultiBindings 就是把一些值组成一个集合, 有 set 和 map, @IntoSet 和 @StringKey 等等, 用于实现插件式构架, 稍显复杂</li>
<li>@ProducerModule, @Produces, @ProductionComponent 是提供异步依赖注入的注解, 类似注解 @Module, @Provides, @Component</li>
<li>@Produces 返回一个 ListenableFuture<T>, 如果其中 T 被依赖, 并且也被 @Produces 修饰, 可以通过注解 @Production 修饰 Executor 来指定</li>
<li>错误处理, 被依赖的 T, 就是 Produced<T>, 如果需要做错误处理, 则在此完成, MultiBindings 和 Lazy execution 同样支持</li>

<li><p>返回 Scope 和相应的 Component 一致  @ProductionScope</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@ProducerModule(includes = UserModule.class)
<span style="font-weight:bold">final</span> class UserResponseModule {
@Produces
<span style="font-weight:bold">static</span> ListenableFuture&lt;UserData&gt; lookUpUserData(
  User user, UserDataStub stub) {
<span style="font-weight:bold">return</span> stub.lookUpData(user);
}

@Produces
<span style="font-weight:bold">static</span> Html renderHtml(UserData data, UserHtmlTemplate template) {
<span style="font-weight:bold">return</span> template.render(data);
}
}

@Module
<span style="font-weight:bold">final</span> class ExecutorModule {
@Provides
@Production
<span style="font-weight:bold">static</span> Executor executor() {
<span style="font-weight:bold">return</span> Executors.newCachedThreadPool();
}
}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Produces
<span style="font-weight:bold">static</span> Html renderHtml(
Produced&lt;UserData&gt; data,
UserHtmlTemplate template,
ErrorHtmlTemplate errorTemplate) {
<span style="font-weight:bold">try</span> {
<span style="font-weight:bold">return</span> template.render(data.get());
} <span style="font-weight:bold">catch</span> (ExecutionException e) {
<span style="font-weight:bold">return</span> errorTemplate.render(<span style="font-style:italic">&#34;user data failed&#34;</span>, e.getCause());
}
}</code></pre></div></li>
</ul>

<h3 id="componentprocessor">ComponentProcessor</h3>

<ul>
<li>getSupportedOptions, initSteps 和 postRound 来自于 BasicAnnotationProcessor</li>
<li><a href="https://github.com/google/auto" title="Auto">google auto</a>, 这个项目是用来帮助自动生成代码的</li>
<li><a href="https://github.com/google/guava" title="Google Core Libraries for Java 6+">google guava</a> 是 Google 开源的 Java 库, 在Java标准库上面的一些封装, 让 java 更加优雅, <a href="https://github.com/google/guava/wiki" title="Guava User Guide">guava guide</a></li>
<li>BasicAnnotationProcessor 中接口 ProcessingStep, ElementName</li>
</ul>

<h4 id="basicannotationprocessor-processingstep">BasicAnnotationProcessor.ProcessingStep</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-style:italic">// 处理阶段, 每个处理阶段可以处理一些注解的逻辑
</span><span style="font-style:italic"></span><span style="font-weight:bold">public</span> interface ProcessingStep {
    <span style="font-style:italic">// 返回该阶段需要处理的注解类型
</span><span style="font-style:italic"></span>    Set&lt;? <span style="font-weight:bold">extends</span> Class&lt;? <span style="font-weight:bold">extends</span> Annotation&gt;&gt; annotations();

    <span style="font-style:italic">// 处理注解和被注解的元素, 是 SetMultimap 类型, 说明可以处理多个注解,
</span><span style="font-style:italic"></span>    <span style="font-style:italic">// 同时每个注解可能注释了多个不同的元素
</span><span style="font-style:italic"></span>    Set&lt;Element&gt; process(SetMultimap&lt;Class&lt;? <span style="font-weight:bold">extends</span> Annotation&gt;, Element&gt; var1);
}</code></pre></div>
<h4 id="basicannotationprocessor-elementname">BasicAnnotationProcessor.ElementName</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-style:italic">// 该类主要用来存放节点名称, 并且区分包节点和类型节点
</span><span style="font-style:italic"></span><span style="font-weight:bold">private</span> static <span style="font-weight:bold">final</span> class ElementName {
    <span style="font-weight:bold">private</span> final BasicAnnotationProcessor.ElementName.Kind kind;
    <span style="font-weight:bold">private</span> final String name;
    <span style="font-style:italic">// ... 其中一些方法简化, 是一些构造方法和一些比较相关的方法
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">private</span> static <span style="font-weight:bold">enum</span> Kind {
        PACKAGE_NAME,
        TYPE_NAME;
    }
}</code></pre></div>
<h4 id="basicannotationprocessor-5个变量">BasicAnnotationProcessor 5个变量</h4>

<ul>
<li>deferredElementNames 未处理的元素</li>
<li>elementsDeferredBySteps 未处理的元素(按照 ProcessingStep 区分)</li>
<li>processorName 该 processor 的名称</li>
<li>elements 所有元素</li>
<li>messager 用于编译过程中报告错误</li>
<li>steps 所有处理步骤(ProcessingStep)</li>
</ul>

<h4 id="roundenvironment">RoundEnvironment</h4>

<ul>
<li>这个注释处理是一轮一轮进行的, RoundEnvironment 代表这一轮的处理环境</li>
<li>processingOver 表示上一轮处理完成, errorRaised 表示前面有错误发生</li>
<li>getRootElements 上一轮处理的根元素</li>
<li>getElementsAnnotatedWith 获取被注解的元素, 有两个重载的方法</li>
</ul>

<h4 id="basicannotationprocessor-处理流程">BasicAnnotationProcessor 处理流程</h4>

<ul>
<li>init 初始化, 暴露 initSteps 给子类, 让其返回其想要实现的 ProcessingStep</li>
<li>process 函数先检查了一些状态, 然后通过 deferredElementNames 得到了 deferredElements, 但奇怪的是, deferredElementNames 和 elements 怎么初始化</li>
<li>只在 validElements 方法中看到 deferredElementNames 被更改, 说明 deferredElements 来自处理结束, 最可能的是上一步留下的, 未处理的 Elements</li>
<li>validElements 做了什么呢?</li>
<li>下载了代码之后, 看完了头部的注释, 解释了如何处理一个 ProcessingStep, 然后哪些 element 需要延迟处理, 整个逻辑就清晰了。</li>
<li>BasicAnnotationProcessor 中, 注解处理器会多次调用 process 方法吗？ 如果未处理完成, 应该如何表征, 这是个问题, 后面慢慢弄明白</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>2016 年的 JavaScript</title>
            <link>https://quqiuzhu.com/2016/js-2016/</link>
            <pubDate>Wed, 05 Oct 2016 07:34:02 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/js-2016/</guid>
            <description>今天早上看了一篇文章, 名字叫How it feels to learn JavaScript in 2016 。模拟一个新加入项目, 了解过一点ES5和前端开发, 但对 2016 年 JavaScript 变化一无所知的人与作者的对话, 介绍了 2016 年 JavaScript 与前端开发的最新情况。 观整体趋势, JS 和 React 必将成为移动开发和Web前端开发的主流, 如果通过 NodeJs 等框架来写后端, 单单写 JS 就可以成为全栈工程师。 JS 后劲足, 早在 2014 年, 我就听说有人在嵌入式开发中引入了 JS, 因此 JS 变得越来越重要。以下是我看完之后记下的一些点
 React &amp;amp; React DOM 使用 JSX 语法来写组件, 不再直接使用 HTML Babel 是将 ES6 或 ES2016+ 语法的 JS 转换为旧版本的 JS, 以便浏览器兼容的库 ES2016+ 在 ES6 的基础上增加了 async, await 等特性 AMD, CommonJS 是 JS 模块化编程的规范, 重点看 这篇文章 npm 是一个共有的模块库(包管理), Browserify 将所有依赖的模块打包在一起使用 Webpack 搞定 JS 模块合并, Babel 等所有事情 HTTP/2 推荐使用多个 HTTP 请求而不是一个, SystemJS 可以将各模块中用到的 JS 分开, 一次请求就会小很多 Typescript 将 JavaScript 用作一种强类型语言, Flow 是一种使用 OCaml 写的检查器 Ramnda 使用 JS 函数式编程, David Chambers, Erik Meijer 等人 Fetch 或者 Fetch polyfill 使用 Promises 做异步编程 需要响应状态变化, 有 Redux, Flux, Flummox 等等  一个简单的总结就是</description>
            <content type="html"><![CDATA[<p>今天早上看了一篇文章, 名字叫<a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f" title="How it feels to learn JavaScript in 2016">How it feels to learn JavaScript in 2016</a> 。模拟一个新加入项目, 了解过一点ES5和前端开发, 但对 2016 年 JavaScript 变化一无所知的人与作者的对话, 介绍了 2016 年 JavaScript 与前端开发的最新情况。
<!-- more --></p>

<p>观整体趋势, JS 和 React 必将成为移动开发和Web前端开发的主流, 如果通过 NodeJs 等框架来写后端, 单单写 JS 就可以成为全栈工程师。 JS 后劲足, 早在 2014 年, 我就听说有人在嵌入式开发中引入了 JS, 因此 JS 变得越来越重要。以下是我看完之后记下的一些点</p>

<ul>
<li>React &amp; React DOM 使用 JSX 语法来写组件, 不再直接使用 HTML</li>
<li>Babel 是将 ES6 或 ES2016+ 语法的 JS 转换为旧版本的 JS, 以便浏览器兼容的库</li>
<li>ES2016+ 在 ES6 的基础上增加了 async, await 等特性</li>
<li>AMD, CommonJS 是 JS 模块化编程的规范, 重点看 <a href="http://justineo.github.io/singles/writing-modular-js/" title="使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript">这篇文章</a></li>
<li>npm 是一个共有的模块库(包管理), Browserify 将所有依赖的模块打包在一起使用</li>
<li>Webpack 搞定 JS 模块合并, Babel 等所有事情</li>
<li>HTTP/2 推荐使用多个 HTTP 请求而不是一个, SystemJS 可以将各模块中用到的 JS 分开, 一次请求就会小很多</li>
<li>Typescript 将 JavaScript 用作一种强类型语言, Flow 是一种使用 OCaml 写的检查器</li>
<li>Ramnda 使用 JS 函数式编程, David Chambers, Erik Meijer 等人</li>
<li>Fetch 或者 Fetch polyfill 使用 Promises 做异步编程</li>
<li>需要响应状态变化, 有 <a href="https://github.com/reactjs/redux" title="Redux">Redux</a>, Flux, Flummox 等等</li>
</ul>

<p>一个简单的总结就是</p>

<blockquote>
<p>Code everything in Typescript. All modules that use Fetch compile them to target ES6, transpile them with Babel on a stage-3 preset, and load them with SystemJS. If you don’t have Fetch, polyfill it, or use Bluebird, Request or Axios, and handle all your promises with await</p>
</blockquote>

<p>一个项目里面包含了这些的使用, 就是 <a href="https://github.com/vuejs/vue-hackernews-2.0" title="vue-hackernews-2.0">vue-hackernews-2.0</a></p>
]]></content>
        </item>
        
        <item>
            <title>Requests 源代码浅析</title>
            <link>https://quqiuzhu.com/2016/python-requests/</link>
            <pubDate>Sun, 04 Sep 2016 10:16:10 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/python-requests/</guid>
            <description>Requests是目前最流行的Python HTTP库，使用者众多，包括Amazon, Google, Twitter等大公司和美国国家安全局等政府机构。在github上有2w多的star。Requests的接口简单，符合人的直觉而且功能强大。比如持久 Cookie 的会话, Keep-Alive &amp;amp; 连接池,文件分块上传, 流下载, SSL 认证等。其大部分功能由其内置的urllib3库实现。所以Requests最关心的不是如何实现协议，而是如何设计接口，正如作者github自我介绍，「The only thing I really care about is interface design」。 HTTP基础 URL 一个统一资源定位符被分为下面的六段
http://user:passwd@httpbin.org:80/basic-auth/user/passwd?name=quqiuzhu#1 &amp;lt;scheme&amp;gt;://&amp;lt;netloc&amp;gt;/&amp;lt;path&amp;gt;;&amp;lt;params&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt; &amp;lt;scheme&amp;gt; http &amp;lt;netloc&amp;gt; user:passwd@httpbin.org:80 &amp;lt;path&amp;gt; basic-auth/user/passwd &amp;lt;query&amp;gt; name=quqiuzhu &amp;lt;fragment&amp;gt; 1 其中&amp;lt;params&amp;gt;叫做matrix parameters，&amp;lt;query&amp;gt;叫query parameters，&amp;lt;params&amp;gt;支持较少，关于这两种参数的讨论，请看stackoverflow。
&amp;lt;netloc&amp;gt; 可继续细分为&amp;lt;auth&amp;gt;, &amp;lt;host&amp;gt;, &amp;lt;port&amp;gt;, 一般情况下，没有&amp;lt;auth&amp;gt;部分，和&amp;lt;port&amp;gt;部分。因为在url中明文传递用户名密码和不安全，而且对外提供服务的网站一般都采用默认端口(HTTP:80, HTTPS:443)。
&amp;lt;fragment&amp;gt; 通常用作一个网页的页内分段跳转。
HTTP bat是一个类似cUrl的API测试工具，执行命令时，其能完整显示整个HTTP协议的传输过程，比如当我对http://httpbin.org/ip做一个GET请求时，其命令为
➜ ~ bat http://httpbin.org/ip 其构造的请求(Request)如下
GET /ip HTTP/1.1 Host: httpbin.org Accept: application/json Accept-Encoding: gzip, deflate User-Agent: bat/0.1.0 第一行是请求行，分别是谓词(方法)、路径和协议版本; 其后跟着的是头部信息(Host、Accept、Accept-Encoding 和User-Agent); 如果是POST或者PUT等请求，还可能会有BODY部分。</description>
            <content type="html"><![CDATA[

<p>Requests是目前最流行的Python HTTP库，使用者众多，包括Amazon, Google, Twitter等大公司和美国国家安全局等政府机构。在<a href="https://github.com/kennethreitz/requests" title="Requests: HTTP for Humans">github</a>上有2w多的star。Requests的接口简单，符合人的直觉而且功能强大。比如持久 Cookie 的会话, Keep-Alive &amp; 连接池,文件分块上传, 流下载, SSL 认证等。其大部分功能由其内置的<a href="https://github.com/shazow/urllib3" title="urllib3">urllib3</a>库实现。所以Requests最关心的不是如何实现协议，而是如何设计接口，正如作者<a href="https://github.com/kennethreitz" title="kennethreitz">github</a>自我介绍，「The only thing I really care about is interface design」。
<!-- more --></p>

<h2 id="http基础">HTTP基础</h2>

<h4 id="url">URL</h4>

<p>一个统一资源定位符被分为下面的六段</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">http://user:passwd@httpbin.org:80/basic-auth/user/passwd?name=quqiuzhu#1

&lt;scheme&gt;://&lt;netloc&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;fragment&gt;

&lt;scheme&gt;    http
&lt;netloc&gt;    user:passwd@httpbin.org:80
&lt;path&gt;      basic-auth/user/passwd
&lt;query&gt;     name=quqiuzhu
&lt;fragment&gt;  1</pre></div>
<p>其中<code>&lt;params&gt;</code>叫做matrix parameters，<code>&lt;query&gt;</code>叫query parameters，<code>&lt;params&gt;</code>支持较少，关于这两种参数的讨论，请看<a href="http://stackoverflow.com/questions/2048121/url-matrix-parameters-vs-request-parameters" title="URL matrix parameters vs. request parameters">stackoverflow</a>。</p>

<p><code>&lt;netloc&gt;</code> 可继续细分为<code>&lt;auth&gt;</code>, <code>&lt;host&gt;</code>, <code>&lt;port&gt;</code>, 一般情况下，没有<code>&lt;auth&gt;</code>部分，和<code>&lt;port&gt;</code>部分。因为在url中明文传递用户名密码和不安全，而且对外提供服务的网站一般都采用默认端口(HTTP:80, HTTPS:443)。</p>

<p><code>&lt;fragment&gt;</code> 通常用作一个网页的页内分段跳转。</p>

<h4 id="http">HTTP</h4>

<p><a href="https://github.com/astaxie/bat" title="bat">bat</a>是一个类似cUrl的API测试工具，执行命令时，其能完整显示整个HTTP协议的传输过程，比如当我对<a href="http://httpbin.org/ip做一个GET请求时，其命令为">http://httpbin.org/ip做一个GET请求时，其命令为</a></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">➜  ~ bat http://httpbin.org/ip</pre></div>
<p>其构造的请求(Request)如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">GET /ip HTTP/1.1
Host: httpbin.org
Accept: application/json
Accept-Encoding: gzip, deflate
User-Agent: bat/0.1.0</pre></div>
<p>第一行是请求行，分别是谓词(方法)、路径和协议版本; 其后跟着的是头部信息(Host、Accept、Accept-Encoding 和User-Agent); 如果是POST或者PUT等请求，还可能会有BODY部分。</p>

<p>回复(Response)的文本如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">HTTP/1.1 200 OK
Server : nginx
Date : Sun, 04 Sep 2016 11:59:35 GMT
Content-Type : application/json
Content-Length : 32
Connection : keep-alive
Access-Control-Allow-Origin : *
Access-Control-Allow-Credentials : true


{
  &#34;origin&#34;: &#34;111.0.186.217&#34;
}</pre></div>
<p>第一行是回复行，分别为协议版本，状态码和状态描述; 其后是头部信息; 之后是空行(<code>\r\n</code>);再后面跟着的是BODY信息。</p>

<p>以上是一个HTTP请求的基本框架，是其他所有功能的基础。</p>

<h2 id="urllib3">urllib3</h2>

<p>Requests大部分HTTP协议功能是urllib3实现的，一直看到最后，会发现urllib3最底层是调用了Python标准库的httplib(Python3 http.client)。它实现下面这些功能</p>

<ul>
<li>Connection pooling</li>
<li>File uploads with multipart encoding</li>
<li>Helpers for retrying requests and dealing with HTTP redirects</li>
<li>Support for gzip and deflate encoding</li>
<li>Proxy support for HTTP and SOCKS</li>
</ul>

<h4 id="连接池">连接池</h4>

<p>urllib3 对外暴露的结构就两个，PoolManager 和 HTTPConnectionPool(HTTPSConnectionPool)。PoolManager管理了一堆的 ConnectionPool，每一个独立的(scheme, host, port)元祖使用同一个ConnectionPool, (scheme, host, port)是从请求的URL中解析出来的。</p>

<p>PoolManager使用自己实现的RecentlyUsedContainer容器来管理ConnectionPool，一旦
ConnectionPool超过限制，则逐出最远使用的ConnectionPool。ConnectionPool内部使用LifoQueue来管理 HTTPConnection，HTTPSConnection和VerifiedHTTPSConnection。XXXXConnection都继承至httplib的httplib.HTTPConnection或者httplib.HTTPSConnection。</p>

<p>典型使用案例</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&gt;&gt;&gt; http = urllib3.PoolManager(num_pools=50)
&gt;&gt;&gt; r = http.request(&#39;GET&#39;, &#39;http://httpbin.org/ip&#39;)
&gt;&gt;&gt; r.data
&#39;{\n  &#34;origin&#34;: &#34;111.0.186.217&#34;\n}\n&#39;</pre></div>
<p>同样可以使用 ConnectionPool</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&gt;&gt;&gt; http = urllib3.HTTPConnectionPool(&#39;httpbin.org&#39;)
&gt;&gt;&gt; r = http.request(&#39;GET&#39;, &#39;http://httpbin.org/ip&#39;)
&gt;&gt;&gt; r.data
&#39;{\n  &#34;origin&#34;: &#34;111.0.186.217&#34;\n}\n&#39;</pre></div>
<p>PoolManager 与 ConnectionPool有相似的API，是因为它们有共同的父类RequestMethods</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class RequestMethods(object):
    def urlopen(self, method, url, body=None, headers=None,
                encode_multipart=True, multipart_boundary=None,
                **kw)
    def request(self, method, url, fields=None, headers=None,
                **urlopen_kw)
    ...</pre></div>
<h4 id="multipart编码文件上传">multipart编码文件上传</h4>

<p>urllib3 中POST, PUT, PATCH等方法，可以使用两种Content-Type上传数据，一种是application/x-www-form-urlencoded，一般用来传递非文件数据，还有一种就是multipart/form-data，可以传输数据也可以传输文件。</p>

<p>使用bat命令查看Content-Type为application/x-www-form-urlencoded的请求</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">➜  ~ bat -f=true http://httpbin.org/post name=qiuzhu age=18</pre></div>
<p>HTTP请求</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">POST /post HTTP/1.1
Host: httpbin.org
Accept: application/json
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
User-Agent: bat/0.1.0


name=qiuzhu&amp;age=18</pre></div>
<p>使用bat上传文件，其Content-Type为multipart/form-data的请求</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">➜  ~ bat -f=true http://httpbin.org/post name=qiuzhu f@f.txt</pre></div>
<p>HTTP请求</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">POST /post HTTP/1.1
Host: httpbin.org
Accept: application/json
Accept-Encoding: gzip, deflate
Content-Type: multipart/form-data; boundary=386e4e1c64f
User-Agent: bat/0.1.0


--386e4e1c64f
Content-Disposition: form-data; name=&#34;f&#34;; filename=&#34;f.txt&#34;
Content-Type: application/octet-stream

text in the f.txt

--386e4e1c64f
Content-Disposition: form-data; name=&#34;name&#34;

qiuzhu
--386e4e1c64f--</pre></div>
<p>区别在于，application/x-www-form-urlencoded类型的请求会使用urlencode来编码数据，然而multipart/form-data会使用一个边界字符串来区分每一个数据Item，以及请求的起始和结束位置。</p>

<p>filepost模块中的encode_multipart_formdata和fields模块的RequestField都实现了相关功能。使用方式如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&gt;&gt;&gt; file_data = open(&#39;/Users/xshare/Desktop/f.txt&#39;).read()
&gt;&gt;&gt; http = urllib3.PoolManager()
&gt;&gt;&gt; r = http.request(
        &#39;POST&#39;,
        &#39;http://httpbin.org/post&#39;,
        fields={&#39;filefield&#39;: (&#39;f.txt&#39;, file_data)}
)
&gt;&gt;&gt; r.data</pre></div>
<h4 id="自动跳转-与-gzip-deflate编码">自动跳转 与 gzip/deflate编码</h4>

<p>重试和自动跳转的逻辑很简单，就是检测到重定向状态码(303)之后，重试次数加1，如果超过最大重试次数，则抛出异常。</p>

<p>Retry不仅能实现redirects的计数，而且还有Read和Connect的重试。</p>

<p>自动跳转的逻辑实现在 PoolManager 的 urlopen中，值得注意的是，跳转之后，method为变为GET。</p>

<p>当HTTP Response的Content-Type为gzip/deflate时，对该数据进行编码，使用的库为zlib，这部分的逻辑实现在 response模块的 HTTPResponse中。</p>
]]></content>
        </item>
        
        <item>
            <title>Python 学习笔记 正则表达式</title>
            <link>https://quqiuzhu.com/2016/python-regexp/</link>
            <pubDate>Wed, 27 Apr 2016 14:24:46 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/python-regexp/</guid>
            <description>1.5 版之后，Python 内建支持正则表达式，它提供的正则表达式是 Perl 风格的。
正则表达式（或 RE）是一种小型的、高度专业化的编程语言，经常使用会感受到它的神奇之处。Python 正则表达式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行的。
本文开始给出一个匹配规则的表格，然后谈谈常用的正则表达式。然后讲了 Python 中 re 模块的函数及其相关的使用方式，最后以实例的形式给出了相关函数的用法。 正则匹配表    记号 说明     foo 匹配foo这个字符串   fooIbar 匹配foo 或者 bar   . 匹配任何字符（除了换行符）   ^ 匹配字符串开始   $ 匹配字符串结尾   * 匹配 0 次或更多次   + 匹配 1 次或者更多次   ? 匹配 0 或 1 次   {N} 匹配 N 次   {M,N} 匹配 M 到 N 次   [&amp;hellip;] 匹配 方括号里面的单个字符，可省略中间部分[a-z]   [^&amp;hellip;] 匹配 不在方括号中出现的字符   (*I+I?</description>
            <content type="html"><![CDATA[

<p>1.5 版之后，Python 内建支持正则表达式，它提供的正则表达式是 Perl 风格的。</p>

<p>正则表达式（或 RE）是一种小型的、高度专业化的编程语言，经常使用会感受到它的神奇之处。Python 正则表达式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行的。</p>

<p>本文开始给出一个匹配规则的表格，然后谈谈常用的正则表达式。然后讲了 Python 中 re 模块的函数及其相关的使用方式，最后以实例的形式给出了相关函数的用法。
<!-- more --></p>

<h2 id="正则匹配表">正则匹配表</h2>

<table>
<thead>
<tr>
<th>记号</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>foo</td>
<td>匹配foo这个字符串</td>
</tr>

<tr>
<td>foo<font color=red>I</font>bar</td>
<td>匹配foo 或者 bar</td>
</tr>

<tr>
<td>.</td>
<td>匹配任何字符（除了换行符）</td>
</tr>

<tr>
<td>^</td>
<td>匹配字符串开始</td>
</tr>

<tr>
<td>$</td>
<td>匹配字符串结尾</td>
</tr>

<tr>
<td>*</td>
<td>匹配 0 次或更多次</td>
</tr>

<tr>
<td>+</td>
<td>匹配 1 次或者更多次</td>
</tr>

<tr>
<td>?</td>
<td>匹配 0 或 1 次</td>
</tr>

<tr>
<td>{N}</td>
<td>匹配 N 次</td>
</tr>

<tr>
<td>{M,N}</td>
<td>匹配 M 到 N 次</td>
</tr>

<tr>
<td>[&hellip;]</td>
<td>匹配 方括号里面的单个字符，可省略中间部分[a-z]</td>
</tr>

<tr>
<td>[^&hellip;]</td>
<td>匹配 不在方括号中出现的字符</td>
</tr>

<tr>
<td>(*<font color=red>I</font>+<font color=red>I</font>?<font color=red>I</font>{})?</td>
<td>后面的问号，加在前面任何一个字符上，表示匹配越短越好(非贪婪)</td>
</tr>

<tr>
<td>(&hellip;)</td>
<td>匹配括号中的正则表达式，并保存为子组</td>
</tr>

<tr>
<td>\d</td>
<td>匹配 [0-9] <code>\D</code> 相反</td>
</tr>

<tr>
<td>\w</td>
<td>匹配 [A-Za-z0-9_] <code>\W</code> 相反</td>
</tr>

<tr>
<td>\s</td>
<td>匹配任何空白 <code>\S</code> 相反</td>
</tr>

<tr>
<td>\b</td>
<td>匹配单词边界 <code>\B</code> 相反</td>
</tr>

<tr>
<td>\N</td>
<td>N为一个数字，匹配子组 N</td>
</tr>

<tr>
<td>\C</td>
<td>C为特殊字符，匹配特殊字符 <code>\.</code>,<code>\*</code>等</td>
</tr>

<tr>
<td>\A</td>
<td>同 <code>^</code></td>
</tr>

<tr>
<td>\Z</td>
<td>同 <code>$</code></td>
</tr>
</tbody>
</table>

<blockquote>
<p>上面的表格中 <code>|</code> 以 <font color=red>I</font> 代替</p>
</blockquote>

<h2 id="常用正则表达式">常用正则表达式</h2>

<ul>
<li>中文字符: <code>[\u4e00-\u9fa5]</code></li>
<li>HTML标记: <code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code></li>
<li>Email地址: <code>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</code></li>
<li>国内电话号码: <code>\d{3}-\d{8}|\d{4}-\d{7}</code></li>
<li>HTTP_URL: <code>(https?)://([^/]+)(/?.*)</code></li>
<li>时间(24h制): <code>((1|0?)[0-9]|2[0-3]):([0-5][0-9])</code></li>
<li>URL: <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li>
<li>QQ号: <code>[1-9][0-9]{4,}</code></li>
</ul>

<h2 id="python-的-re-模块">Python 的 re 模块</h2>

<p>使用正则表达式，我们通常有下面的几种需求</p>

<ul>
<li>验证是否匹配字符串</li>
<li>验证字符串中有正则表达式表示的字符</li>
<li>符合正则表达式的字符串提取</li>
<li>正则表达式替换</li>
<li>字符串分割</li>
</ul>

<p>因此从 re 包中可以到处的函数如下</p>

<ul>
<li>compile(pattern, flags=0)</li>
<li>match(pattern, string, flags=0)</li>
<li>search(pattern, string, flags=0)</li>
<li>findall(pattern, string, flags=0)</li>
<li>sub(pattern, repl, string, count=0, flags=0)</li>
<li>subn(pattern, repl, string, count=0, flags=0)</li>
<li>split(pattern, string, maxsplit=0, flags=0)</li>
</ul>

<p>一般的处理流程是编译正则表达式，获取一个 regex 对象，然后使用该对象的方法。每个函数对象里面包含的方法和 re 包中包含的一样(除了 compile 函数)。 实际上是 re 模块里面的函数调用了 regex 对象的相应的方法，下面是 re 包中 match 函数的实现，其他函数也是类似的。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> match(pattern, string, flags=0):
    <span style="font-weight:bold">return</span> _compile(pattern, flags).match(string)</code></pre></div>
<p>re 包中的函数是先编译 regex 对象，然后调用其方法的。因为 re 模块有一块缓存区用来保存匹配过的正则表达式，所以速度也不会很慢，但是还是建议使用 regex 对象。</p>

<p>上面的函数都有一个 flags 参数，其实只是用来编译的，因为 re 包中的函数需要先编译再调用其他方法，所以每个函数都有一个 flag 参数。每个 flag 表示的含义如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-style:italic"># ignore case</span>
I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE 

<span style="font-style:italic"># assume current 8-bit locale</span>
L = LOCALE = sre_compile.SRE_FLAG_LOCALE 

<span style="font-style:italic"># assume unicode locale</span>
U = UNICODE = sre_compile.SRE_FLAG_UNICODE 

<span style="font-style:italic"># make anchors look for newline</span>
M = MULTILINE = sre_compile.SRE_FLAG_MULTILINE 

<span style="font-style:italic"># make dot match newline</span>
S = DOTALL = sre_compile.SRE_FLAG_DOTALL 

<span style="font-style:italic"># ignore whitespace and comments</span>
X = VERBOSE = sre_compile.SRE_FLAG_VERBOSE </code></pre></div>
<h2 id="例子">例子</h2>

<p><code>match()</code> 和 <code>search()</code> 如果匹配的话，会返回一个匹配对象，否则会返回 None。匹配对象有 <code>group()</code> 与 <code>groups()</code> 方法。 <code>group()</code> 会返回匹配的字符串， 而<code>groups()</code> 返回存在的子组元组的元组，如果不存在匹配的子组，则返回<code>()</code>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">g = re.match(<span style="font-style:italic">&#39;foo&#39;</span>, <span style="font-style:italic">&#39;foo&#39;</span>) <span style="font-style:italic"># 匹配对象</span>
g.group() <span style="font-style:italic"># &#39;foo&#39;</span>
g.groups() <span style="font-style:italic"># ()</span>

g = re.match(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) 
g.group() <span style="font-style:italic"># &#39;foo2033&#39;</span>
g.groups() <span style="font-style:italic"># (&#39;2033&#39;,)</span>

g = re.match(<span style="font-style:italic">&#39;^foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># 同上</span>
g = re.match(<span style="font-style:italic">&#39;^foo(\d+)$&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># None</span>
g = re.match(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;dfoo2033d&#39;</span>) <span style="font-style:italic"># None</span></code></pre></div>
<p>从上面最后一组的值，可以知道，<code>re.match</code> 默认从头开始匹配，但是并不默认一定要完全匹配到字符串末尾，除非使用结束符 <code>$</code> 。</p>

<p><code>re.search</code> 与 <code>re.match</code>的区别正在于此，<code>re.search</code>并不一定要从头开始，比如说上面四组匹配结果如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">g = re.search(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># 匹配成功</span>
g = re.search(<span style="font-style:italic">&#39;^foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># 匹配成功</span>
g = re.search(<span style="font-style:italic">&#39;^foo(\d+)$&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># None</span>
g = re.search(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;dfoo2033d&#39;</span>) <span style="font-style:italic"># 匹配成功</span></code></pre></div>
<p><code>re.findall</code> 跟 <code>re.search</code> 与 <code>re.match</code> 的区别是什么呢？第一，<code>re.search</code> 与 <code>re.match</code> 只匹配一次。 第二，<code>re.findall</code> 总会返回一个列表，不管匹配不匹配。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">g = re.match(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
g.group() <span style="font-style:italic"># &#39;foo2033&#39;</span>
g.groups() <span style="font-style:italic"># (&#39;2033&#39;,)</span>

l = re.findall(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
l <span style="font-style:italic"># [&#39;2033&#39;, &#39;9&#39;]</span>
l = re.findall(<span style="font-style:italic">&#39;foo\d+&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
l <span style="font-style:italic"># [&#39;foo2033&#39;, &#39;foo9&#39;]</span></code></pre></div>
<p><code>re.findall</code> 返回的列表，如果正则表达式有子组，则匹配返回的子组列表，否则返回整个正则表达式的匹配列表。</p>

<p><code>re.sub</code> 与 <code>re.subn</code> 是用来做字符串替换的，它们唯一的区别是前面的返回替换了的字符串，后面返回一个替换之后的字符串和替换次数的元组。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">r = re.sub(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>,<span style="font-style:italic">&#39;*&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
r <span style="font-style:italic"># &#39;**d&#39;</span>

r = re.subn(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>,<span style="font-style:italic">&#39;*&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
r <span style="font-style:italic"># (&#39;**d&#39;, 2)</span></code></pre></div>
<p><code>re.split</code> 使用正则表达式作为分隔符，但有子组和无子组的情况是不一样的，有子组的会分割字符串，但会留下子组的匹配值。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">l = re.split(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
l <span style="font-style:italic"># [&#39;&#39;, &#39;2033&#39;, &#39;&#39;, &#39;9&#39;, &#39;d&#39;]</span>

l = re.split(<span style="font-style:italic">&#39;foo\d+&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
l <span style="font-style:italic"># [&#39;&#39;, &#39;&#39;, &#39;d&#39;]</span></code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Python 学习笔记 描述符</title>
            <link>https://quqiuzhu.com/2016/python-descriptor/</link>
            <pubDate>Sun, 24 Apr 2016 22:21:25 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/python-descriptor/</guid>
            <description>许多做 C++ 和 Java 的朋友在看 Python 的时候，或许会问，Python 中没有 private, protected, public 等关键字，是怎么控制变量访问的呢？Python 中有没有静态变量，实例变量呢？
Python 没有静态变量和实例变量的区别，只有属性。类的属性还是对象的属性没有任何不同，因为类也是一种对象。Python 中类的属性还包含了类中的方法，而控制属性访问的正是描述符。
本文将详细叙述描述符协议、描述符的实现方式、属性及属性访问顺序等主题。 描述符协议 一个实例 instance 有一个属性 x，对属性 x 有三种操作。 访问 y = instance.x， 赋值 instance.x = 20 和 删除 del instance.x，描述符正是对这三种操作进行控制。
描述符协议有 3 个方法，只要实现 __get__ 或者 __set__ 方法就可以算是一个描述器。实现了 __set__ 方法的描述器是数据描述器，实现了 __get__ 方法，但是没有实现 __set__ 方法的是非数据描述符。两种描述符在属性访问时的优先级不同，后面会讲。
descr.__get__(self, inst, type=None) --&amp;gt; value descr.__set__(self, inst, value) --&amp;gt; None descr.__delete__(self, inst) --&amp;gt; None 描述符协议调用者是属性，所以参数 self 是指属性，inst 指的是实例。
描述符实现方式 有三种典型的方式来实现描述符，类、property() 和 property 装饰器</description>
            <content type="html"><![CDATA[

<p>许多做 C++ 和 Java 的朋友在看 Python 的时候，或许会问，Python 中没有 <code>private</code>, <code>protected</code>, <code>public</code> 等关键字，是怎么控制变量访问的呢？Python 中有没有静态变量，实例变量呢？</p>

<p>Python 没有静态变量和实例变量的区别，只有属性。类的属性还是对象的属性没有任何不同，因为类也是一种对象。Python 中类的属性还包含了类中的方法，而控制属性访问的正是描述符。</p>

<p>本文将详细叙述描述符协议、描述符的实现方式、属性及属性访问顺序等主题。
<!-- more --></p>

<h2 id="描述符协议">描述符协议</h2>

<p>一个实例 instance 有一个属性 x，对属性 x 有三种操作。 访问 <code>y = instance.x</code>， 赋值 <code>instance.x = 20</code> 和 删除 <code>del instance.x</code>，描述符正是对这三种操作进行控制。</p>

<p>描述符协议有 3 个方法，只要实现 <code>__get__</code> 或者 <code>__set__</code> 方法就可以算是一个描述器。实现了 <code>__set__</code> 方法的描述器是数据描述器，实现了 <code>__get__</code> 方法，但是没有实现 <code>__set__</code> 方法的是非数据描述符。两种描述符在属性访问时的优先级不同，后面会讲。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">descr.__get__(self, inst, type=None) --&gt; value
descr.__set__(self, inst, value) --&gt; None
descr.__delete__(self, inst) --&gt; None</code></pre></div>
<p>描述符协议调用者是属性，所以参数 self 是指属性，inst 指的是实例。</p>

<h2 id="描述符实现方式">描述符实现方式</h2>

<p>有三种典型的方式来实现描述符，类、property() 和 property 装饰器</p>

<h3 id="类">类</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">class</span> <span style="font-weight:bold">NameDescripter</span>(object):
    <span style="font-weight:bold">def</span> __init__(self):
        self._name = <span style="font-style:italic">&#39;&#39;</span>

    <span style="font-weight:bold">def</span> __get__(self, instance, inst_type):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__get__&#39;</span>, self._name
        <span style="font-weight:bold">return</span> self._name

    <span style="font-weight:bold">def</span> __set__(self, instance, value):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__set__&#39;</span>, self._name
        self._name = value

    <span style="font-weight:bold">def</span> __delete__(self, instance):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__delete__&#39;</span>, self._name
        self._name = <span style="font-style:italic">&#39;&#39;</span>

<span style="font-weight:bold">class</span> <span style="font-weight:bold">Person</span>(object):
    name = NameDescripter()
    
user = Person()
user.name = <span style="font-style:italic">&#39;quqiuzhu&#39;</span> 
out: __set__
user.name  
out: __get__ quqiuzhu
<span style="font-weight:bold">del</span> user.name
out: __delete__ quqiuzhu
user.name
out: __get__</code></pre></div>
<h3 id="property">property()</h3>

<p>property() 定义如下:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</code></pre></div>
<p>用该函数实现上一节的 Person name 属性</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">class</span> <span style="font-weight:bold">Person</span>(object):
    <span style="font-weight:bold">def</span> __init__(self):
        self._name = <span style="font-style:italic">&#39;&#39;</span>

    <span style="font-weight:bold">def</span> __get_name(self):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__get__&#39;</span>, self._name
        <span style="font-weight:bold">return</span> self._name

    <span style="font-weight:bold">def</span> __set_name(self, value):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__set__&#39;</span>, self._name
        self._name = value

    <span style="font-weight:bold">def</span> __del_name(self):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__delete__&#39;</span>, self._name
        self._name = <span style="font-style:italic">&#39;&#39;</span>
    name = property(__get_name, __set_name, __del_name)</code></pre></div>
<h3 id="property-装饰器">property 装饰器</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">class</span> <span style="font-weight:bold">Person</span>(object):
    <span style="font-weight:bold">def</span> __init__(self):
        self._name = <span style="font-style:italic">&#39;&#39;</span>
        
    @property
    <span style="font-weight:bold">def</span> name(self):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__get__&#39;</span>, self._name
        <span style="font-weight:bold">return</span> self._name

    @name.setter
    <span style="font-weight:bold">def</span> name(self, value):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__set__&#39;</span>, self._name
        self._name = value

    @name.deleter
    <span style="font-weight:bold">def</span> name(self):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;__delete__&#39;</span>, self._name
        self._name = <span style="font-style:italic">&#39;&#39;</span></code></pre></div>
<h2 id="方法描述符">方法描述符</h2>

<p>方法是一种特殊的属性，其描述符实现原理如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">class</span> <span style="font-weight:bold">Function</span>(object):
    . . .
    <span style="font-weight:bold">def</span> __get__(self, obj, objtype=None):
        <span style="font-style:italic">&#34;Simulate func_descr_get() in Objects/funcobject.c&#34;</span>
        <span style="font-weight:bold">return</span> types.MethodType(self, obj, objtype)</code></pre></div>
<p>Python 中 <code>.</code> 是 <code>getattr()</code> 函数的语法糖。所以方法调用 <code>object.func()</code> 相当于 <code>getattr(object, 'func') 然后调用 __call__()</code>。当然，获取属性的方式不只是 <code>getattr(object, 'func')</code> 那么简单，获取属性是一连串的序列的判断和调用，下面会讲。</p>

<h2 id="属性">属性</h2>

<p>属性的查找遵循LEGB原则：Local，Enclosing，Global以及Builtin。现在实例中找，找不到就去类中找，再去父类中找，一直找到 object 还找不到就去。</p>

<p>上面只是罗列一些点，但并没有展开，强烈推荐三篇参考的文章，比 Python Expert Programming 写得清晰很多。</p>

<h3 id="参考">参考</h3>

<ol>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-pythondescriptors/">Python 描述符简介</a></li>
<li><a href="http://pyzh.readthedocs.org/en/latest/Descriptor-HOW-TO-Guide.html">Python 描述器引导(翻译)</a></li>
<li><a href="http://wlwang41.github.io/content/python/python%E4%B8%AD%E7%9A%84attributes.html">Python 中的attributes</a></li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>Python 学习笔记 高性能容器 collections</title>
            <link>https://quqiuzhu.com/2016/python-collections/</link>
            <pubDate>Sun, 17 Apr 2016 20:54:06 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/python-collections/</guid>
            <description>Python 支持四种内建的集合类型 dict, list, set 和 tuple, 这些类型覆盖了大多数的使用场景。作为补充，collections 提供了几种高性能容器数据类型，Counter, deque, defaultdict 和 OrderedDict，以及 namedtuple() 函数。 Counter 先不忙讲 Counter 怎么用，先想想如果你来实现一个计数器，应该怎么实现，有哪些功能。我列一下，至少有 3 个功能。
 接收要统计的数据 更新统计数据 获取统计结果  其中 1 和 3 都涉及和 Python 内建类型之间的转换，2 涉及 Counter 之间的交互。
接收要统计的数据 数据一般是从构造函数传入，参数可以为 iterable 对象，也可以是 mapping 或者关键字参数。
c = Counter(&amp;#39;quqiuzhu&amp;#39;) c = Counter({&amp;#39;qu&amp;#39;: 1, &amp;#39;qiu&amp;#39;: 2, &amp;#39;zhu&amp;#39;: 3}) c = Counter(qu=1, qiu=2, zhu=3) 上面的例子看起来好像是 Counter 里面的 key 必须是字符串类型，value 必须是 int 类型的，实际上并没有这样的限制。比如可以像这样
cc = Counter({&amp;#39;qu&amp;#39;: 1, 4: 2, &amp;#39;zhu&amp;#39;: &amp;#39;str&amp;#39;}) 不过在 Counter 之间计算的时候会有一些问题，比如两个 Counter 相加的时候。</description>
            <content type="html"><![CDATA[

<p>Python 支持四种内建的集合类型 dict, list, set 和 tuple, 这些类型覆盖了大多数的使用场景。作为补充，collections 提供了几种高性能容器数据类型，Counter, deque, defaultdict 和 OrderedDict，以及 namedtuple() 函数。
<!-- more --></p>

<h2 id="counter">Counter</h2>

<p>先不忙讲 Counter 怎么用，先想想如果你来实现一个计数器，应该怎么实现，有哪些功能。我列一下，至少有 3 个功能。</p>

<ol>
<li>接收要统计的数据</li>
<li>更新统计数据</li>
<li>获取统计结果</li>
</ol>

<p>其中 1 和 3 都涉及和 Python 内建类型之间的转换，2 涉及 Counter 之间的交互。</p>

<h4 id="接收要统计的数据">接收要统计的数据</h4>

<p>数据一般是从构造函数传入，参数可以为 iterable 对象，也可以是 mapping 或者关键字参数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">c = Counter(<span style="font-style:italic">&#39;quqiuzhu&#39;</span>)
c = Counter({<span style="font-style:italic">&#39;qu&#39;</span>: 1, <span style="font-style:italic">&#39;qiu&#39;</span>: 2, <span style="font-style:italic">&#39;zhu&#39;</span>: 3})
c = Counter(qu=1, qiu=2, zhu=3)</code></pre></div>
<p>上面的例子看起来好像是 Counter 里面的 key 必须是字符串类型，value 必须是 int 类型的，实际上并没有这样的限制。比如可以像这样</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">cc = Counter({<span style="font-style:italic">&#39;qu&#39;</span>: 1, 4: 2, <span style="font-style:italic">&#39;zhu&#39;</span>: <span style="font-style:italic">&#39;str&#39;</span>})</code></pre></div>
<p>不过在 Counter 之间计算的时候会有一些问题，比如两个 Counter 相加的时候。</p>

<h4 id="更新统计数据">更新统计数据</h4>

<p>单个数据的更新和访问，支持下标访问，如果 Counter 中没有该记录，则返回 0。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">c[<span style="font-style:italic">&#39;quqiuzhu.com&#39;</span>] <span style="font-style:italic"># 0</span>
c[<span style="font-style:italic">&#39;quqiuzhu.com&#39;</span>] = 10 <span style="font-style:italic"># 10</span></code></pre></div>
<p>批量更新有两个方法，<code>subtract([iterable-or-mapping])</code> 和 <code>update([iterable-or-mapping])</code>，参数可以是 iterable, dict, 关键字参数或者 Counter 对象。 <code>subtract</code> 方法对 key 相同的 value 简单的应用减法运算，如果 value 不支持减法运算的话，就会出错，比如上面提到的，value 为 字符串的情况。</p>

<p>Counter 之间也可以进行 +, -, |, &amp; 运算，和你想象中的一样，都是相同 key 的 value 值之间的运算。</p>

<h4 id="获取统计结果">获取统计结果</h4>

<p><code>most_common([n])</code> 获取计数最多的 n 个 (key, value)的列表，<code>items()</code> 返回所有的，<code>elements()</code> 获取统计计数大于等于 2 的。</p>

<p>可以使用 set, list, dict 转为相应类型。</p>

<h2 id="deque">deque</h2>

<p>实现了双端队列的 API, 当队列为定长队列时，如果队列 isFull，则丢弃另一端的 items。</p>

<ul>
<li>append(x)</li>
<li>appendleft(x)</li>
<li>extend(iterable)</li>
<li>extendleft(iterable) 其中 iterable item 顺序会反过来</li>
<li>pop()</li>
<li>popleft()</li>
<li>clear()</li>
<li>count(x)</li>
<li>remove(x)</li>
<li>reverse() 原地反转, 返回None</li>
<li>rotate(n)</li>
</ul>

<p>支持随机访问，但性能不是很好。有只读属性 maxlen, 支持函数操作 len(d), reversed(d), copy.copy(d), copy.deepcopy(d)</p>

<h2 id="defaultdict-与-ordereddict">defaultdict 与 OrderedDict</h2>

<p>该结构扩展自内建类型 dict 。给所有新的 key 一个默认值，该默认值来自于参数 default_factory。
用法如下:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">d = defaultdict(list)
d[<span style="font-style:italic">&#39;k&#39;</span>] <span style="font-style:italic"># []</span></code></pre></div>
<p>由于当前没有 key &lsquo;k&rsquo;, 所以 defaultdict 调用 default_factory 函数，创建了一个默认值。 这里的 default_factory 是 list 函数。</p>

<p>OrderedDict items 是按照顺序存放的，用来做相等性检测是很好的。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">d = {<span style="font-style:italic">&#39;banana&#39;</span>: 3, <span style="font-style:italic">&#39;apple&#39;</span>:4, <span style="font-style:italic">&#39;pear&#39;</span>: 1, <span style="font-style:italic">&#39;orange&#39;</span>: 2}
OrderedDict(sorted(d.items(), key=<span style="font-weight:bold">lambda</span> t: t[0]))</code></pre></div>
<p>可以指定排序函数</p>

<h2 id="namedtuple">namedtuple()</h2>

<p>这是非常经典，非常有意思的一个函数，其简单用法如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">Point = namedtuple(<span style="font-style:italic">&#39;Point&#39;</span>, [<span style="font-style:italic">&#39;x&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>])</code></pre></div>
<p>这个 Point 是一个类，该类增强了内建的 tuple 类型。 使其支持一般的 tuple操作，也同时支持名称访问，上面的代码，其实现为</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">class</span> <span style="font-weight:bold">Point</span>(tuple):
    <span style="font-style:italic">&#39;Point(x, y)&#39;</span>

    __slots__ = ()

    _fields = (<span style="font-style:italic">&#39;x&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>)

    <span style="font-weight:bold">def</span> __new__(_cls, x, y):
        <span style="font-style:italic">&#39;Create a new instance of Point(x, y)&#39;</span>
        <span style="font-weight:bold">return</span> _tuple.__new__(_cls, (x, y))

    @classmethod
    <span style="font-weight:bold">def</span> _make(cls, iterable, new=tuple.__new__, len=len):
        <span style="font-style:italic">&#39;Make a new Point object from a sequence or iterable&#39;</span>
        result = new(cls, iterable)
        <span style="font-weight:bold">if</span> len(result) != 2:
            <span style="font-weight:bold">raise</span> <span style="font-weight:bold">TypeError</span>(<span style="font-style:italic">&#39;Expected 2 arguments, got </span><span style="font-weight:bold;font-style:italic">%d</span><span style="font-style:italic">&#39;</span> % len(result))
        <span style="font-weight:bold">return</span> result

    <span style="font-weight:bold">def</span> __repr__(self):
        <span style="font-style:italic">&#39;Return a nicely formatted representation string&#39;</span>
        <span style="font-weight:bold">return</span> <span style="font-style:italic">&#39;Point(x=</span><span style="font-weight:bold;font-style:italic">%r</span><span style="font-style:italic">, y=</span><span style="font-weight:bold;font-style:italic">%r</span><span style="font-style:italic">)&#39;</span> % self

    <span style="font-weight:bold">def</span> _asdict(self):
        <span style="font-style:italic">&#39;Return a new OrderedDict which maps field names to their values&#39;</span>
        <span style="font-weight:bold">return</span> OrderedDict(zip(self._fields, self))

    <span style="font-weight:bold">def</span> _replace(_self, **kwds):
        <span style="font-style:italic">&#39;Return a new Point object replacing specified fields with new values&#39;</span>
        result = _self._make(map(kwds.pop, (<span style="font-style:italic">&#39;x&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>), _self))
        <span style="font-weight:bold">if</span> kwds:
            <span style="font-weight:bold">raise</span> <span style="font-weight:bold">ValueError</span>(<span style="font-style:italic">&#39;Got unexpected field names: </span><span style="font-weight:bold;font-style:italic">%r</span><span style="font-style:italic">&#39;</span> % kwds.keys())
        <span style="font-weight:bold">return</span> result

    <span style="font-weight:bold">def</span> __getnewargs__(self):
        <span style="font-style:italic">&#39;Return self as a plain tuple.   Used by copy and pickle.&#39;</span>
        <span style="font-weight:bold">return</span> tuple(self)

    __dict__ = _property(_asdict)

    <span style="font-weight:bold">def</span> __getstate__(self):
        <span style="font-style:italic">&#39;Exclude the OrderedDict from pickling&#39;</span>
        <span style="font-weight:bold">pass</span>

    x = _property(_itemgetter(0), doc=<span style="font-style:italic">&#39;Alias for field number 0&#39;</span>)

    y = _property(_itemgetter(1), doc=<span style="font-style:italic">&#39;Alias for field number 1&#39;</span>)</code></pre></div>
<p>其内部实现为 String 定义模板加上 <code>exec class_definition in namespace</code> 来实现。有兴趣的可以查看其源代码。</p>

<p>新建一个 namedtuple 条目</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">p = Point(11, 22)
p.x <span style="font-style:italic"># 11</span></code></pre></div>
<p>总结以上，其 API 列表为</p>

<ul>
<li>somenamedtuple._make(iterable)</li>
<li>somenamedtuple._asdict()</li>
<li>somenamedtuple._replace(kwargs)</li>
</ul>

<h2 id="abc-集合抽象基类">ABC 集合抽象基类</h2>

<p>下面的表格摘自 <a href="https://docs.python.org/2/library/collections.html">Python 官方文档</a></p>

<p><img src="http://quqiuzhu.com/images/python_abc.png" alt="" /></p>
]]></content>
        </item>
        
        <item>
            <title>Python 学习笔记 多进程 multiprocessing</title>
            <link>https://quqiuzhu.com/2016/python-multiprocessing/</link>
            <pubDate>Thu, 14 Apr 2016 13:13:04 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/python-multiprocessing/</guid>
            <description>Python 解释器有一个全局解释器锁(PIL)，导致每个 Python 进程中最多同时运行一个线程，因此 Python 多线程程序并不能改善程序性能，不能发挥多核系统的优势，可以通过这篇文章了解。
但是多进程程序不受此影响， Python 2.6 引入了 multiprocessing 来解决这个问题。这里介绍 multiprocessing 模块下的进程，进程同步，进程间通信和进程管理四个方面的内容。 这里主要讲解多进程的典型使用，multiprocessing 的 API 几乎是完复制了 threading 的API， 因此只需花少量的时间就可以熟悉 threading 编程了。 Process 先来看一段代码
from multiprocessing import Process, current_process def func(): time.sleep(1) proc = current_process() proc.name, proc.pid sub_proc = Process(target=func, args=()) sub_proc.start() sub_proc.join() proc = current_process() proc.name, proc.pid 这是在主进程中创建子进程，然后启动(start) 子进程，等待(join) 子进程执行完，再继续执行主进程的整个的执行流程。
那么，一个进程应该是用来做什么的，它应该保存一些什么状态，它的生命周期是什么样的呢？
一个进程需要处理一些不同任务，或者处理不同的对象。创建进程需要一个 function 和相关参数，参数可以是dict Process(target=func, args=(), kwargs = {})，name 可以用来标识进程。
控制子进程进入不同阶段的是 start(), join(), is_alive(), terminate(), exitcode 方法。这些方法只能在创建子进程的进程中执行。</description>
            <content type="html"><![CDATA[

<p>Python 解释器有一个全局解释器锁(PIL)，导致每个 Python 进程中最多同时运行一个线程，因此 Python 多线程程序并不能改善程序性能，不能发挥多核系统的优势，可以通过<a href="http://www.oschina.net/translate/pythons-hardest-problem">这篇文章</a>了解。</p>

<p>但是多进程程序不受此影响， Python 2.6 引入了 multiprocessing 来解决这个问题。这里介绍 multiprocessing 模块下的进程，进程同步，进程间通信和进程管理四个方面的内容。 这里主要讲解多进程的典型使用，multiprocessing 的 API 几乎是完复制了 threading 的API， 因此只需花少量的时间就可以熟悉 threading 编程了。
<!-- more --></p>

<h2 id="process">Process</h2>

<p>先来看一段代码</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">from</span> <span style="font-weight:bold">multiprocessing</span> <span style="font-weight:bold">import</span> Process, current_process
<span style="font-weight:bold">def</span> func():
    time.sleep(1)
    proc = current_process()
    proc.name, proc.pid

sub_proc = Process(target=func, args=())
sub_proc.start()
sub_proc.join()
proc = current_process()
proc.name, proc.pid</code></pre></div>
<p>这是在主进程中创建子进程，然后启动(start) 子进程，等待(join) 子进程执行完，再继续执行主进程的整个的执行流程。</p>

<p>那么，一个进程应该是用来做什么的，它应该保存一些什么状态，它的生命周期是什么样的呢？</p>

<p>一个进程需要处理一些不同任务，或者处理不同的对象。创建进程需要一个 function 和相关参数，参数可以是dict <code>Process(target=func, args=(), kwargs = {})</code>，<code>name</code> 可以用来标识进程。</p>

<p>控制子进程进入不同阶段的是 <code>start()</code>, <code>join()</code>, <code>is_alive()</code>, <code>terminate()</code>, <code>exitcode</code> 方法。这些方法只能在创建子进程的进程中执行。</p>

<h2 id="进程同步">进程同步</h2>

<h3 id="lock">Lock</h3>

<p>锁是为了确保数据一致性，比如读写锁，每个进程给一个变量增加 1 ，但是如果在一个进程读取但还没有写入的时候，另外的进程也同时读取了，并写入该值，则最后写入的值是错误的，这时候就需要锁。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> func(lock):
    lock.acquire()
    <span style="font-style:italic"># do mysql query select update ...</span>
    lock.release()
       
lock = Lock()
<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(4):
    proc = Process(target=func, args=(lock))
    proc.start()</code></pre></div>
<p>Lock 同时也实现了 ContextManager API, 可以结合 with 语句使用, 关于 ContextManager, 请移步 <a href="http://quqiuzhu.com/2016/python-decorator-and-context">Python 学习实践笔记 装饰器 与 context</a> 查看。</p>

<h3 id="semaphore">Semaphore</h3>

<p>Semaphore 和 Lock 稍有不同，Semaphore 相当于 N 把锁，获取其中一把就可以执行了。 信号量的总数 N 在构造时传入，<code>s = Semaphore(N)</code>。 和 Lock 一样，如果信号量为0，则进程堵塞，直到信号大于0。</p>

<h3 id="pipes">Pipes</h3>

<p>Pipe 是在两个进程之间通信的工具，Pipe Constructor 会返回两个端</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">conn1, conn2 = Pipe(True)</code></pre></div>
<p>如果是全双工的(构造函数参数为True)，则双端口都可接收发送，否则前面的端口用于接收，后面的端口用于发送。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> proc1(pipe):
   <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10000):
       pipe.send(i)

<span style="font-weight:bold">def</span> proc2(pipe):
    <span style="font-weight:bold">while</span> True:
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#34;proc2 rev:&#34;</span>, pipe.recv()

pipe = Pipe()
Process(target=proc1, args=(pipe[0],)).start()
Process(target=proc2, args=(pipe[1],)).start()</code></pre></div>
<p>Pipe 的每个端口同时最多一个进程读写，否则数据会出各种问题</p>

<h3 id="queues">Queues</h3>

<p>multiprocessing.Queue 与 Queue.Queue 非常相似。其 API 列表如下</p>

<ul>
<li>qsize()</li>
<li>empty()</li>
<li>full()</li>
<li>put()</li>
<li>put_nowait()</li>
<li>get()</li>
<li>get_nowait()</li>
<li>close()</li>
<li>join_thread()</li>
<li>cancel_join_thread()</li>
</ul>

<p>当 Queue 为 Queue.Full 状态时，再 put() 会堵塞，当状态为 Queue.Empty 时，再 get() 也是。当 put() 或 get() 设置了超时参数，而超时的时候，会抛出异常。</p>

<p>Queue 主要用于多个进程产生和消费，一般使用情况如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> producer(q):
    <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10):
        q.put(i)

<span style="font-weight:bold">def</span> consumer(q):
    <span style="font-weight:bold">while</span> True:
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#34;consumer&#34;</span>, q.get()

q = Queue(40)
<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10):
    Process(target=producer, args=(q,)).start()
Process(target=consumer, args=(q,)).start()</code></pre></div>
<p>十个生产者进程，一个消费者进程，共用同一个队列进行同步。</p>

<p>有一个简化版本的 multiprocessing.queues.SimpleQueue, 只支持3个方法 empty(), get(), put()。</p>

<p>也有一个强化版本的 JoinableQueue, 新增两个方法 task_done() 和 join()。 task_done() 是给消费者使用的，每完成队列中的一个任务，调用一次该方法。当所有的 tasks 都完成之后，交给调用 join() 的进程执行。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> consumer(q):
    <span style="font-weight:bold">while</span> True:
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#34;consumer&#34;</span>, q.get()
        q.task_done()

jobs = JoinableQueue()
<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10):
        jobs.put(i)

<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10):
    p = Process(target=consumer, args=(jobs,))
    p.daemon = True
    p.start()

jobs.join()</code></pre></div>
<p>这个 join 函数等待 JoinableQueue 为空的时候，等待就结束，外面的进程可以继续执行了，但是那10个进程干嘛去了呢，他们还在等待呀，上面是设置了 <code>p.daemon = True</code>, 子进程才随着主进程结束的，如果没有设置，它们还是会一直等待的呢。</p>

<p>Lock、Pipe、Queue 和 Pipe 需要注意的是：尽量避免使用 Process.terminate 来终止程序，否则将会导致很多问题, 详情请移步<a href="https://docs.python.org/2/library/multiprocessing.html">python 官方文档</a>查看。</p>

<h2 id="进程间数据共享">进程间数据共享</h2>

<p>前一节中, Pipe、Queue 都有一定数据共享的功能，但是他们会堵塞进程, 这里介绍的两种数据共享方式都不会堵塞进程, 而且都是多进程安全的。</p>

<h3 id="共享内存">共享内存</h3>

<p>共享内存有两个结构，一个是 <code>Value</code>, 一个是 <code>Array</code>，这两个结构内部都实现了锁机制，因此是多进程安全的。 用法如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> func(n, a):
    n.value = 50
    <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(len(a)):
        a[i] += 10

num = Value(<span style="font-style:italic">&#39;d&#39;</span>, 0.0)
ints= Array(<span style="font-style:italic">&#39;i&#39;</span>, range(10))

p = Process(target=func, args=(num, ints))
p.start()
p.join()</code></pre></div>
<p>Value 和 Array 都需要设置其中存放值的类型，d 是 double 类型，i 是 int 类型，具体的对应关系在Python 标准库的 sharedctypes 模块中查看。</p>

<h3 id="服务进程-manager">服务进程 Manager</h3>

<p>上面的共享内存支持两种结构 Value 和 Array, 这些值在主进程中管理，很分散。 Python 中还有一统天下，无所不能的 Server process，专门用来做数据共享。 其支持的类型非常多，比如list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value 和 Array 用法如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">from</span> <span style="font-weight:bold">multiprocessing</span> <span style="font-weight:bold">import</span> Process, Manager

<span style="font-weight:bold">def</span> func(dct, lst):
    dct[88] = 88
    lst.reverse()

manager = Manager()
dct = manager.dict()
lst = manager.list(range(5,10))

p = Process(target=func, args=(dct, lst))
p.start()
p.join()
<span style="font-weight:bold">print</span> dct, <span style="font-style:italic">&#39;|&#39;</span>, lst
Out: {88: 88} | [9, 8, 7, 6, 5]</code></pre></div>
<p>一个 Manager 对象是一个服务进程，推荐多进程程序中，数据共享就用一个 manager 管理。</p>

<h2 id="进程管理">进程管理</h2>

<p>如果有50个任务要执行, 但是 CPU 只有4核, 你可以创建50个进程来做这个事情。但是大可不必，徒增管理开销。如果你只想创建4个进程，让他们轮流替你完成任务，不用自己去管理具体的进程的创建销毁，那 Pool 是非常有用的。</p>

<p>Pool 是进程池，进程池能够管理一定的进程，当有空闲进程时，则利用空闲进程完成任务，直到所有任务完成为止，用法如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> func(x):
    <span style="font-weight:bold">return</span> x*x

pool = Pool(processes=4)
<span style="font-weight:bold">print</span> pool.map(func, range(8))</code></pre></div>
<p>Pool 进程池创建4个进程，不管有没有任务，都一直在进程池中等候，等到有数据的时候就开始执行。
Pool 的 API 列表如下：</p>

<ul>
<li>apply(func[, args[, kwds]])</li>
<li>apply_async(func[, args[, kwds[, callback]]])</li>
<li>map(func, iterable[, chunksize])</li>
<li>map_async(func, iterable[, chunksize[, callback]])</li>
<li>imap(func, iterable[, chunksize])</li>
<li>imap_unordered(func, iterable[, chunksize])</li>
<li>close()</li>
<li>terminate()</li>
<li>join()</li>
</ul>

<h3 id="异步执行">异步执行</h3>

<p>apply_async 和 map_async 执行之后立即返回，然后异步返回结果。 使用方法如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> func(x):
    <span style="font-weight:bold">return</span> x*x

<span style="font-weight:bold">def</span> callback(x):
    <span style="font-weight:bold">print</span> x, <span style="font-style:italic">&#39;in callback&#39;</span>
    
pool = Pool(processes=4)
result = pool.map_async(func, range(8), 8, callback)
<span style="font-weight:bold">print</span> result.get(), <span style="font-style:italic">&#39;in main&#39;</span>
Out:
[0, 1, 4, 9, 16, 25, 36, 49] <span style="font-weight:bold">in</span> callback
[0, 1, 4, 9, 16, 25, 36, 49] <span style="font-weight:bold">in</span> main</code></pre></div>
<p>有两个值得提到的，一个是 callback，另外一个是 multiprocessing.pool.AsyncResult。 callback 是在结果返回之前，调用的一个函数，这个函数必须只有一个参数，它会首先接收到结果。callback 不能有耗时操作，因为它会阻塞主线程。</p>

<p>AsyncResult 是获取结果的对象，其 API 如下</p>

<ul>
<li>get([timeout])</li>
<li>wait([timeout])</li>
<li>ready()</li>
<li>successful()</li>
</ul>

<p>如果设置了 timeout 时间，超时会抛出 multiprocessing.TimeoutError 异常。wait 是等待执行完成。 ready 测试是否已经完成，successful 是在确定已经 ready 的情况下，如果执行中没有抛出异常，则成功，如果没有ready 就调用该函数，会得到一个 AssertionError 异常。</p>

<h3 id="pool-管理">Pool 管理</h3>

<p>这里不再继续讲 map 的各种变体了，因为从上面的 API 一看便知。</p>

<p>然后我们来看看 Pool 的执行流程，有三个阶段。第一、一个进程池接收很多任务，然后分开执行任务；第二、不再接收任务了；第三、等所有任务完成了，回家，不干了。</p>

<p>这就是上面的方法，close 停止接收新的任务，如果还有任务来，就会抛出异常。 join 是等待所有任务完成。 join 必须要在 close 之后调用，否则会抛出异常。terminate 非正常终止，内存不够用时，垃圾回收器调用的就是这个方法。</p>
]]></content>
        </item>
        
        <item>
            <title>Python 学习笔记 装饰器 与 context</title>
            <link>https://quqiuzhu.com/2016/python-decorator-and-context/</link>
            <pubDate>Thu, 07 Apr 2016 12:17:58 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/python-decorator-and-context/</guid>
            <description>装饰器 Python中函数是一等公民，装饰器的作用就是接收一个函数，返回其增强版本的函数。例如:
def decorator(function): def _mydecorator(*args, **kw): print &amp;#39;do something before&amp;#39; res = function(*args, **kw) print &amp;#39;do somthing after&amp;#39; return res return _mydecorator @decorator def function(): print &amp;#39;function executing&amp;#39; function() 输出： do something before function executing do somthing after 装饰器是语法糖，因此装饰器可以用其他一般的语句来实现，我们将上面例子中的function定义部分作出下面改动
def function(): print &amp;#39;function executing&amp;#39; function = decorator(function) 实现同样的功能，所以装饰器一点也不厉害，就是函数调用加上赋值运算的语法糖。
上面的是无参数的装饰器，如果是有参数的装饰器，则这么来实现
def otherdecorator(args1, args2): def _otherdecorator(function): def __otherdecorator(*args, **kw): print &amp;#39;do something before with args %s, %s&amp;#39; % (args1, args2) res = function(*args, **kw) print &amp;#39;do something after with args %s, %s&amp;#39; % (args1, args2) return res return __otherdecorator return _otherdecorator @otherdecorator(&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;) def function(): print &amp;#39;function executing&amp;#39; function() 输出： do something before with args name, age function executing do something after with args name, age 有参数的函数的定义相当于</description>
            <content type="html"><![CDATA[

<h2 id="装饰器">装饰器</h2>

<p>Python中函数是一等公民，装饰器的作用就是接收一个函数，返回其增强版本的函数。例如:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> decorator(function):
    <span style="font-weight:bold">def</span> _mydecorator(*args, **kw):
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;do something before&#39;</span>
        res = function(*args, **kw)
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;do somthing after&#39;</span>
        <span style="font-weight:bold">return</span> res
    <span style="font-weight:bold">return</span> _mydecorator

@decorator
<span style="font-weight:bold">def</span> function():
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;function executing&#39;</span>

function()

<span style="">输出：</span>
do something before
function executing
do somthing after</code></pre></div>
<!-- more -->

<p>装饰器是语法糖，因此装饰器可以用其他一般的语句来实现，我们将上面例子中的<code>function</code>定义部分作出下面改动</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> function():
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;function executing&#39;</span>
    
function = decorator(function)</code></pre></div>
<p>实现同样的功能，所以装饰器一点也不厉害，就是函数调用加上赋值运算的语法糖。</p>

<p>上面的是无参数的装饰器，如果是有参数的装饰器，则这么来实现</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> otherdecorator(args1, args2):
    <span style="font-weight:bold">def</span> _otherdecorator(function):
        <span style="font-weight:bold">def</span> __otherdecorator(*args, **kw):
            <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;do something before with args </span><span style="font-weight:bold;font-style:italic">%s</span><span style="font-style:italic">, </span><span style="font-weight:bold;font-style:italic">%s</span><span style="font-style:italic">&#39;</span> % (args1, args2)
            res = function(*args, **kw)
            <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;do something after with args </span><span style="font-weight:bold;font-style:italic">%s</span><span style="font-style:italic">, </span><span style="font-weight:bold;font-style:italic">%s</span><span style="font-style:italic">&#39;</span> % (args1, args2)
            <span style="font-weight:bold">return</span> res
        <span style="font-weight:bold">return</span> __otherdecorator
    <span style="font-weight:bold">return</span> _otherdecorator

@otherdecorator(<span style="font-style:italic">&#39;name&#39;</span>, <span style="font-style:italic">&#39;age&#39;</span>)
<span style="font-weight:bold">def</span> function():
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;function executing&#39;</span>
    
function()
<span style="">输出：</span>
do something before <span style="font-weight:bold">with</span> args name, age
function executing
do something after <span style="font-weight:bold">with</span> args name, age</code></pre></div>
<p>有参数的函数的定义相当于</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> function():
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;function executing&#39;</span>

function = otherdecorator(<span style="font-style:italic">&#39;name&#39;</span>, <span style="font-style:italic">&#39;age&#39;</span>)(function)</code></pre></div>
<p>装饰器还有类的实现方式，类实现<code>__call__</code>方法的时候可以被调用，这里不再多讲。</p>

<p>应用</p>

<ul>
<li>参数检查</li>
<li>缓存</li>
<li>代理</li>
</ul>

<h2 id="context">context</h2>

<h3 id="with-语句的使用">with 语句的使用</h3>

<p>python 上下文跟 with 语句的使用有关。一般的用法如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">with</span> open(filename) <span style="font-weight:bold">as</span> f:
    <span style="font-weight:bold">for</span> line <span style="font-weight:bold">in</span> f:
        <span style="font-weight:bold">print</span> line
        <span style="font-weight:bold">raise</span> <span style="font-weight:bold">ValueError</span>()</code></pre></div>
<p>如果在语句体中发生异常，文件也将正常关闭，主要是因为 with 语句与 context_manager 的交互。 context_manager 是实现了 <code>__enter__()</code> 和 <code>__exit__()</code> 方法的对象。 with 语句保证在语句体重发生异常时，<code>__exit__()</code> 方法 也会被调用，从而使程序正确退出上下文。</p>

<p>上面的代码中，<code>open(filename)</code> 返回的是一个 context_manager， 而  <code>as f</code> 这个 f 被赋值的是 <code>context_manager.__enter__()</code> 的返回结果。</p>

<p>但是有时候又会发现，不用with语句也可以直接使用，比如 <code>f = open(filename)</code> 。这是因为 python 的文件对象实现了 <code>__enter__()</code> 和 <code>__exit__()</code> 方法， 文件对象本身也是 context_manager， 其 <code>__enter__()</code> 返回的是自身。</p>

<h3 id="contextlib">contextlib</h3>

<p>有一个装饰器 <code>contexmanager</code>， 一个 <code>closing()</code> 函数和 <code>nested()</code> 函数。</p>

<p><code>contexmanager</code> 是用来帮助我们自定义 contexmanager 的, 其中 yield 语句前一部分在 <code>__enter__()</code> 中执行，yield 语句 执行 with 语句体, yield 语句后的部分在 <code>__exit__()</code> 中执行。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">@contextmanager
<span style="font-weight:bold">def</span> cm():
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;do something before&#39;</span>
    <span style="font-weight:bold">yield</span>
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;do something after&#39;</span></code></pre></div>
<p>很容易想出来 <code>contextmanager</code> 装饰器的实现方式，这里不再多讲。</p>

<p><code>closing(that)</code> 函数是一个 <code>contextmanager</code>，不是装饰器，它的作用就是最终会调用 that 的 close 方法，如果不想自己实现上下文管理器，但是也要支持上下文管理器的功能的话，就只需要实现 close 方法，然后使用 <code>with closing(that) as f</code> 就好了。</p>

<p><code>nested()</code> 函数用来解决嵌套with语句的问题，可以这样使用</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">with</span> nested(A(), B(), C()) <span style="font-weight:bold">as</span> (X, Y, Z):
	  <span style="font-weight:bold">pass</span></code></pre></div>
<p>如果细节了解不清楚，建议看 IBM 的<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/">文章</a></p>
]]></content>
        </item>
        
        <item>
            <title>Python 学习笔记 迭代器和生成器</title>
            <link>https://quqiuzhu.com/2016/python-iterator-and-generator/</link>
            <pubDate>Wed, 06 Apr 2016 23:08:59 +0000</pubDate>
            
            <guid>https://quqiuzhu.com/2016/python-iterator-and-generator/</guid>
            <description>迭代器 一个迭代器是一个实现了__iter__()方法和 next()方法的对象，但是我发现这两个并不需要一起实现，就像Java中一样，返回迭代子的对象和迭代子是分离的。 __iter__() 只是返回迭代器，真正进行迭代的是实现了 next()方法的，所以可以在 for i in r 的r中实现一个__iter__()方法，然后返回一个实现了next()方法的对象
class Itrator(object): def __init__(self): self.i = 4; def next(self): if self.i: self.i -= 1 return self.i else: raise StopIteration class Iterable(object): def __iter__(self): return Itrator() for i in Iterable(): print i 当然一般上都可以把这两个方法写在同一个类里面，python里和Java是一样的，一个是Iterable，一个是Itrator。
生成器 有两种生成器，第一种是产生值的生成器，像下面这样的
def power(values): print &amp;#39;xxxx&amp;#39; for value in values: yield value 第二种种是作为表达式的生成器，这种生成器需要接受外面的输入，像下面这样的
def psychologist(): print &amp;#39;plaese tell me your problem&amp;#39; while True : answer = (yield) if answer is not None: if answer.</description>
            <content type="html"><![CDATA[

<h2 id="迭代器">迭代器</h2>

<p>一个迭代器是一个实现了<code>__iter__()</code>方法和 <code>next()</code>方法的对象，但是我发现这两个并不需要一起实现，就像Java中一样，返回迭代子的对象和迭代子是分离的。 <code>__iter__()</code> 只是返回迭代器，真正进行迭代的是实现了 <code>next()</code>方法的，所以可以在 <code>for i in r</code> 的r中实现一个<code>__iter__()</code>方法，然后返回一个实现了<code>next()</code>方法的对象</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">class</span> <span style="font-weight:bold">Itrator</span>(object):
    <span style="font-weight:bold">def</span> __init__(self):
        self.i = 4;
        
    <span style="font-weight:bold">def</span> next(self):
        <span style="font-weight:bold">if</span> self.i:
            self.i -= 1
            <span style="font-weight:bold">return</span> self.i
        <span style="font-weight:bold">else</span>:
            <span style="font-weight:bold">raise</span> <span style="font-weight:bold">StopIteration</span>

<span style="font-weight:bold">class</span> <span style="font-weight:bold">Iterable</span>(object):
    <span style="font-weight:bold">def</span> __iter__(self):
        <span style="font-weight:bold">return</span> Itrator()

<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> Iterable():
    <span style="font-weight:bold">print</span> i</code></pre></div>
<!-- more -->

<p>当然一般上都可以把这两个方法写在同一个类里面，python里和Java是一样的，一个是Iterable，一个是Itrator。</p>

<h2 id="生成器">生成器</h2>

<p>有两种生成器，第一种是产生值的生成器，像下面这样的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> power(values):
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;xxxx&#39;</span>
    <span style="font-weight:bold">for</span> value <span style="font-weight:bold">in</span> values:
        <span style="font-weight:bold">yield</span> value</code></pre></div>
<p>第二种种是作为表达式的生成器，这种生成器需要接受外面的输入，像下面这样的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> psychologist():
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;plaese tell me your problem&#39;</span>
    <span style="font-weight:bold">while</span> True :
        answer = (<span style="font-weight:bold">yield</span>)
        <span style="font-weight:bold">if</span> answer <span style="font-weight:bold">is</span> <span style="font-weight:bold">not</span> None:
            <span style="font-weight:bold">if</span> answer.endswith(<span style="font-style:italic">&#39;?&#39;</span>):
                <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;what is you question?&#39;</span>
            <span style="font-weight:bold">elif</span> <span style="font-style:italic">&#39;good&#39;</span> <span style="font-weight:bold">in</span> ans:
                <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;good good&#39;</span>
            <span style="font-weight:bold">else</span>:
                <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;hahaha&#39;</span>
        <span style="font-weight:bold">else</span>:
            <span style="font-weight:bold">raise</span> <span style="font-weight:bold">StopIteration</span></code></pre></div>
<h3 id="第一种生成器">第一种生成器</h3>

<p>这种生成器是可以迭代的，因为生成器函数会返回一个生成器对象，而生成器实现了<code>next</code> 和 <code>__iter__</code>方法，所以是可以迭代的。</p>

<p>另外，由于生成器函数默认会返回一个生成器，所以生成器方法中return 语句不能返回任何东西，否则就会出错。</p>

<p>生成器最重要的一个特性，是可以暂停并保持生成器方法的状态，直到调用下一个生成器方法，这一种特性被用在协同程序中。</p>

<p>一开始调用生成器函数时，除了返回一个生成器对象之外，不会执行任何代码。因此，在上面的power 方法中，即便是 print &lsquo;xxxx&rsquo;语句在 关键字yield之前，也不会执行。这些代码是初始代码，将会在第一个next方法调用的时候执行。</p>

<h3 id="第二种生成器">第二种生成器</h3>

<p>这种生成器需要外面给它传值，有四个方法,分别是 <code>next()</code>, <code>send(val)</code>, <code>throw(err)</code>, <code>close()</code>。</p>

<p><code>send(val)</code> 方法给生成器传值，每一次传值就是一次迭代</p>

<p><code>next()</code> 方法等价于 <code>send(None)</code>， 因此迭代该生成器，就相当于不断发送None 值，直到遇到 StopIteration 异常。</p>

<p><code>close()</code> 相当于做了一个停止的标记，之后不能再调用 send 和 next 方法，否则会得到 StopIteration 异常，但是可以调用throw方法。</p>

<p><code>throw(err)</code> 方法会向生成器发出异常，而不是向外发出。要理解这一点并不难，因为这样外面调用者就可以随意停止迭代了。</p>

<h3 id="生成器的几个应用">生成器的几个应用</h3>

<ul>
<li>协程</li>
<li>生成器表达式（类似列表推导）</li>
</ul>

<h2 id="itertools">itertools</h2>

<p>这里面的函数一般都以i开头。</p>

<p><code>islice()</code> 窗口迭代，第一个参数是iterable对象，后面如果只有一个参数，则是stop位置，如果两个参数则是start 和 stop，第三个参数是步长</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">a = range(10)
list(itertools.islice(a, 4))
Out: [0, 1, 2, 3]
list(itertools.islice(a, 4, None))
Out: [4, 5, 6, 7, 8, 9]
list(itertools.islice(a, 4, None, 2))
Out: [4, 6, 8]</code></pre></div>
<p><code>count</code>,<code>cycle</code>,<code>repeat</code> 无限迭代，第一个一段整数不断递增或者递减，第二个传入一个可迭代对象，然后就会得到一个循环迭代。repeat函数会一直重复迭代一个元素。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">list(itertools.islice(itertools.count(20), 4))
Out: [20, 21, 22, 23]
list(itertools.islice(itertools.count(20,-1), 4))
Out: [20, 19, 18, 17]
list(itertools.islice(itertools.repeat(-1), 4))
Out: [-1, -1, -1, -1]
list(itertools.islice(itertools.cycle([1,2,3]), 4))
Out: [1, 2, 3, 1]</code></pre></div>
<p><code>chain</code>, 传入一组可迭代对象，按顺序迭代，有时候知道是列表等明确的数据类型的时候，是不需要这个函数的，一般也可以先转换，再连接，但又太浪费内存资源了。所以写一个共用库的时候，最后记得用这个。</p>

<p>相似的是<code>tee</code>, 传入一个iterable对象，返回多个iterable对象，默认返回两个</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">l1 = [2,3,9,4,7,1]
l2 = [3,3,3,3,3,3]
list(itertools.chain(l1,l2)))
Out: [2, 3, 9, 4, 7, 1, 3, 3, 3, 3, 3, 3]
i1,i2 = itertools.tee(l1,2)
i1.next()
Out: 2
i2.next()
Out: 2</code></pre></div>
<p><code>compress</code>,<code>ifilter</code>,<code>ifilterfalse</code> 过滤迭代，<code>compress</code>函数传入iterable数据，第二个iterable选择条件，而<code>ifilter</code>,<code>ifilterfalse</code>，第一个参数是筛选函数，第二个参数是数据。下面是选择征兵青年，输出年龄在18-24岁的人名，用这3个函数分别的完成方式</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">candidates = [
	(8,<span style="font-style:italic">&#39;zhangsan&#39;</span>), 
	(21, <span style="font-style:italic">&#39;lisi&#39;</span>), 
	(19, <span style="font-style:italic">&#39;wangmazi&#39;</span>),
	(40, <span style="font-style:italic">&#39;laozi&#39;</span>)
]
list(itertools.compress(
	 	(c[1] <span style="font-weight:bold">for</span> c <span style="font-weight:bold">in</span> candidates),
	 	(18 &lt;= c[0] &lt;= 22 <span style="font-weight:bold">for</span> c <span style="font-weight:bold">in</span> candidates)
	 )
)
Out: [<span style="font-style:italic">&#39;lisi&#39;</span>, <span style="font-style:italic">&#39;wangmazi&#39;</span>]
list(itertools.ifilter(
		<span style="font-weight:bold">lambda</span> x:18 &lt;= x[0] &lt;= 22,
	 	(c <span style="font-weight:bold">for</span> c <span style="font-weight:bold">in</span> candidates)
	 )
)
Out: [(21, <span style="font-style:italic">&#39;lisi&#39;</span>), (19, <span style="font-style:italic">&#39;wangmazi&#39;</span>)]</code></pre></div>
<p><code>ifilterfalse</code>函数与<code>ifilter</code>只是条件函数不同，就不列举了。这里可以发现一个轻微的不同，我只要输出名字，但是<code>ifilter</code>输出了 candidate 列表。但是如果只传入名字作为参数，又无法判断，只能输入 candidate 列表，因为输入的数据和输出的数据是同源的，返回的就只能是 candidate列表。该例子说明了为什么有了 <code>ifilter</code> 还需要 <code>compress</code> 的原因，当需要返回的数据不足以作为筛选判断条件的时候，<code>compress</code> 就非常有用。</p>

<p><code>takewhile</code>,<code>dropwhile</code> 第一个参数是筛选函数，第二个参数是数据。<code>takewhile</code> 是一开始就拿，直到条件不满足为止；<code>dropwhile</code> 一开始不要，直到条件不满足，然后拿之后的所有数据。所以<code>takewhile</code>倾向于拿前面的数据，<code>dropwhile</code>倾向于拿后半部分的数据。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">list(itertools.takewhile(<span style="font-weight:bold">lambda</span> x: x&lt;5, [1,4,6,4,1]))
Out: [1, 4]
list(itertools.dropwhile(<span style="font-weight:bold">lambda</span> x: x&lt;5, [1,4,6,4,1]))
Out: [6, 4, 1]</code></pre></div>
<p><code>izip()</code>, <code>izip_longest()</code> 装包函数，把几个课迭代的对象组合起来，返回元组迭代</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">list(itertools.izip(<span style="font-style:italic">&#39;ABCD&#39;</span>, <span style="font-style:italic">&#39;xy&#39;</span>))
Out: [(<span style="font-style:italic">&#39;A&#39;</span>, <span style="font-style:italic">&#39;x&#39;</span>), (<span style="font-style:italic">&#39;B&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>)]
list(itertools.izip_longest(<span style="font-style:italic">&#39;ABCD&#39;</span>, <span style="font-style:italic">&#39;xy&#39;</span>))
Out: [(<span style="font-style:italic">&#39;A&#39;</span>, <span style="font-style:italic">&#39;x&#39;</span>), (<span style="font-style:italic">&#39;B&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>), (<span style="font-style:italic">&#39;C&#39;</span>, None), (<span style="font-style:italic">&#39;D&#39;</span>, None)]
list(itertools.izip_longest(<span style="font-style:italic">&#39;ABCD&#39;</span>, <span style="font-style:italic">&#39;xy&#39;</span>, fillvalue = <span style="font-style:italic">&#39;-&#39;</span>))
Out: [(<span style="font-style:italic">&#39;A&#39;</span>, <span style="font-style:italic">&#39;x&#39;</span>), (<span style="font-style:italic">&#39;B&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>), (<span style="font-style:italic">&#39;C&#39;</span>, <span style="font-style:italic">&#39;-&#39;</span>), (<span style="font-style:italic">&#39;D&#39;</span>, <span style="font-style:italic">&#39;-&#39;</span>)]</code></pre></div>
<p><code>imap()</code>, <code>starmap()</code> 第一个参数是函数，后面的是传入的数据，返回的是函数的返回值序列 <code>imap()</code> 先把后面的一串可迭代对象装包，<code>starmap()</code>是后面参数已经装包好了的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">list(itertools.imap(operator.add, (2,3,10), (5,2,3)))
Out: [7, 5, 13]
list(itertools.imap(operator.add, (2,3,10), (5,2)))
Out: [7, 5]</code></pre></div>
<p><code>groupby()</code> 将迭代对象变为按连续的key分组，返回是一个迭代对象，该对象为(key, subgroup) 形式。这里只是让key不连续重复，并不会保证key不重复</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">lst = <span style="font-style:italic">&#39;get uuuuuuuuuuuuuuupd&#39;</span>
<span style="font-weight:bold">def</span> group(data):
    <span style="font-weight:bold">for</span> k,g <span style="font-weight:bold">in</span> itertools.groupby(data):
        <span style="font-weight:bold">print</span> k,list(g)
group(lst)
Out: 
g [<span style="font-style:italic">&#39;g&#39;</span>]
e [<span style="font-style:italic">&#39;e&#39;</span>]
t [<span style="font-style:italic">&#39;t&#39;</span>]
  [<span style="font-style:italic">&#39; &#39;</span>]
u [<span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>]
p [<span style="font-style:italic">&#39;p&#39;</span>]
d [<span style="font-style:italic">&#39;d&#39;</span>]</code></pre></div>
<p><code>product()</code>, <code>permutations()</code>, <code>combinations()</code> 笛卡尔乘法、排列和组合。笛卡尔乘包含自身与自身的组合，排列不包含，而组合不按顺序来。这个不举例子，可以将一些双重循环变成单循环</p>
]]></content>
        </item>
        
    </channel>
</rss>
