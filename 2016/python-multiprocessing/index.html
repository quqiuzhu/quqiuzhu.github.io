<!DOCTYPE html>
<html lang="zh-CN">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="屈秋竹">
    <meta name="description" content="屈秋竹的个人网站">
    <meta name="keywords" content="屈秋竹,秋竹,程序员,站长,工程师,商汤,虎牙,音视频,看见未来">

    <base href="https://quqiuzhu.com/2016/python-multiprocessing/">
    <title>
  Python 学习笔记 多进程 multiprocessing · 看见未来
</title>

    <link rel="canonical" href="https://quqiuzhu.com/2016/python-multiprocessing/">

    
    <link rel="stylesheet" href="https://s3.pstatp.com/cdn/expire-1-M/normalize/8.0.1/normalize.min.css"/>
    
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1306475_6bvggoehvvm.css" />

    
    
    <link rel="stylesheet" href="https://quqiuzhu.com/css/coder.min.d82ce87248795163aa8fb82483d051bfe609859587ed85a175a6fa76c868e631.css" integrity="sha256-2Czockh5UWOqj7gkg9BRv&#43;YJhZWH7YWhdab6dsho5jE="
      crossorigin="anonymous" media="screen" />

    

    <link rel="icon" type="image/png" href="https://quqiuzhu.com/favicon.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://quqiuzhu.com/favicon.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.60.0-DEV" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://quqiuzhu.com/">
      看见未来
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><span class="iconfont icon-menu"></span></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://quqiuzhu.com/posts/">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://quqiuzhu.com/about/">关于</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Python 学习笔记 多进程 multiprocessing</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <span class="iconfont icon-calendar"></span>
              <time datetime='2016-04-14T13:13:04Z'>
                2016-04-14
              </time>
              &nbsp
              <span class="tags">
  <span class="iconfont icon-tag"></span>
    <a href="https://quqiuzhu.com/tags/python/">python</a></span>

            </span>
          </div>
        </div>
      </header>

      <div class="post-content">
        

<p>Python 解释器有一个全局解释器锁(PIL)，导致每个 Python 进程中最多同时运行一个线程，因此 Python 多线程程序并不能改善程序性能，不能发挥多核系统的优势，可以通过<a href="http://www.oschina.net/translate/pythons-hardest-problem">这篇文章</a>了解。</p>

<p>但是多进程程序不受此影响， Python 2.6 引入了 multiprocessing 来解决这个问题。这里介绍 multiprocessing 模块下的进程，进程同步，进程间通信和进程管理四个方面的内容。 这里主要讲解多进程的典型使用，multiprocessing 的 API 几乎是完复制了 threading 的API， 因此只需花少量的时间就可以熟悉 threading 编程了。
<!-- more --></p>

<h2 id="process">Process</h2>

<p>先来看一段代码</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">from</span> <span style="font-weight:bold">multiprocessing</span> <span style="font-weight:bold">import</span> Process, current_process
<span style="font-weight:bold">def</span> func():
    time.sleep(1)
    proc = current_process()
    proc.name, proc.pid

sub_proc = Process(target=func, args=())
sub_proc.start()
sub_proc.join()
proc = current_process()
proc.name, proc.pid</code></pre></div>
<p>这是在主进程中创建子进程，然后启动(start) 子进程，等待(join) 子进程执行完，再继续执行主进程的整个的执行流程。</p>

<p>那么，一个进程应该是用来做什么的，它应该保存一些什么状态，它的生命周期是什么样的呢？</p>

<p>一个进程需要处理一些不同任务，或者处理不同的对象。创建进程需要一个 function 和相关参数，参数可以是dict <code>Process(target=func, args=(), kwargs = {})</code>，<code>name</code> 可以用来标识进程。</p>

<p>控制子进程进入不同阶段的是 <code>start()</code>, <code>join()</code>, <code>is_alive()</code>, <code>terminate()</code>, <code>exitcode</code> 方法。这些方法只能在创建子进程的进程中执行。</p>

<h2 id="进程同步">进程同步</h2>

<h3 id="lock">Lock</h3>

<p>锁是为了确保数据一致性，比如读写锁，每个进程给一个变量增加 1 ，但是如果在一个进程读取但还没有写入的时候，另外的进程也同时读取了，并写入该值，则最后写入的值是错误的，这时候就需要锁。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> func(lock):
    lock.acquire()
    <span style="font-style:italic"># do mysql query select update ...</span>
    lock.release()
       
lock = Lock()
<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(4):
    proc = Process(target=func, args=(lock))
    proc.start()</code></pre></div>
<p>Lock 同时也实现了 ContextManager API, 可以结合 with 语句使用, 关于 ContextManager, 请移步 <a href="http://quqiuzhu.com/2016/python-decorator-and-context">Python 学习实践笔记 装饰器 与 context</a> 查看。</p>

<h3 id="semaphore">Semaphore</h3>

<p>Semaphore 和 Lock 稍有不同，Semaphore 相当于 N 把锁，获取其中一把就可以执行了。 信号量的总数 N 在构造时传入，<code>s = Semaphore(N)</code>。 和 Lock 一样，如果信号量为0，则进程堵塞，直到信号大于0。</p>

<h3 id="pipes">Pipes</h3>

<p>Pipe 是在两个进程之间通信的工具，Pipe Constructor 会返回两个端</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">conn1, conn2 = Pipe(True)</code></pre></div>
<p>如果是全双工的(构造函数参数为True)，则双端口都可接收发送，否则前面的端口用于接收，后面的端口用于发送。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> proc1(pipe):
   <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10000):
       pipe.send(i)

<span style="font-weight:bold">def</span> proc2(pipe):
    <span style="font-weight:bold">while</span> True:
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#34;proc2 rev:&#34;</span>, pipe.recv()

pipe = Pipe()
Process(target=proc1, args=(pipe[0],)).start()
Process(target=proc2, args=(pipe[1],)).start()</code></pre></div>
<p>Pipe 的每个端口同时最多一个进程读写，否则数据会出各种问题</p>

<h3 id="queues">Queues</h3>

<p>multiprocessing.Queue 与 Queue.Queue 非常相似。其 API 列表如下</p>

<ul>
<li>qsize()</li>
<li>empty()</li>
<li>full()</li>
<li>put()</li>
<li>put_nowait()</li>
<li>get()</li>
<li>get_nowait()</li>
<li>close()</li>
<li>join_thread()</li>
<li>cancel_join_thread()</li>
</ul>

<p>当 Queue 为 Queue.Full 状态时，再 put() 会堵塞，当状态为 Queue.Empty 时，再 get() 也是。当 put() 或 get() 设置了超时参数，而超时的时候，会抛出异常。</p>

<p>Queue 主要用于多个进程产生和消费，一般使用情况如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> producer(q):
    <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10):
        q.put(i)

<span style="font-weight:bold">def</span> consumer(q):
    <span style="font-weight:bold">while</span> True:
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#34;consumer&#34;</span>, q.get()

q = Queue(40)
<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10):
    Process(target=producer, args=(q,)).start()
Process(target=consumer, args=(q,)).start()</code></pre></div>
<p>十个生产者进程，一个消费者进程，共用同一个队列进行同步。</p>

<p>有一个简化版本的 multiprocessing.queues.SimpleQueue, 只支持3个方法 empty(), get(), put()。</p>

<p>也有一个强化版本的 JoinableQueue, 新增两个方法 task_done() 和 join()。 task_done() 是给消费者使用的，每完成队列中的一个任务，调用一次该方法。当所有的 tasks 都完成之后，交给调用 join() 的进程执行。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> consumer(q):
    <span style="font-weight:bold">while</span> True:
        <span style="font-weight:bold">print</span> <span style="font-style:italic">&#34;consumer&#34;</span>, q.get()
        q.task_done()

jobs = JoinableQueue()
<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10):
        jobs.put(i)

<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> xrange(10):
    p = Process(target=consumer, args=(jobs,))
    p.daemon = True
    p.start()

jobs.join()</code></pre></div>
<p>这个 join 函数等待 JoinableQueue 为空的时候，等待就结束，外面的进程可以继续执行了，但是那10个进程干嘛去了呢，他们还在等待呀，上面是设置了 <code>p.daemon = True</code>, 子进程才随着主进程结束的，如果没有设置，它们还是会一直等待的呢。</p>

<p>Lock、Pipe、Queue 和 Pipe 需要注意的是：尽量避免使用 Process.terminate 来终止程序，否则将会导致很多问题, 详情请移步<a href="https://docs.python.org/2/library/multiprocessing.html">python 官方文档</a>查看。</p>

<h2 id="进程间数据共享">进程间数据共享</h2>

<p>前一节中, Pipe、Queue 都有一定数据共享的功能，但是他们会堵塞进程, 这里介绍的两种数据共享方式都不会堵塞进程, 而且都是多进程安全的。</p>

<h3 id="共享内存">共享内存</h3>

<p>共享内存有两个结构，一个是 <code>Value</code>, 一个是 <code>Array</code>，这两个结构内部都实现了锁机制，因此是多进程安全的。 用法如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> func(n, a):
    n.value = 50
    <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(len(a)):
        a[i] += 10

num = Value(<span style="font-style:italic">&#39;d&#39;</span>, 0.0)
ints= Array(<span style="font-style:italic">&#39;i&#39;</span>, range(10))

p = Process(target=func, args=(num, ints))
p.start()
p.join()</code></pre></div>
<p>Value 和 Array 都需要设置其中存放值的类型，d 是 double 类型，i 是 int 类型，具体的对应关系在Python 标准库的 sharedctypes 模块中查看。</p>

<h3 id="服务进程-manager">服务进程 Manager</h3>

<p>上面的共享内存支持两种结构 Value 和 Array, 这些值在主进程中管理，很分散。 Python 中还有一统天下，无所不能的 Server process，专门用来做数据共享。 其支持的类型非常多，比如list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value 和 Array 用法如下：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">from</span> <span style="font-weight:bold">multiprocessing</span> <span style="font-weight:bold">import</span> Process, Manager

<span style="font-weight:bold">def</span> func(dct, lst):
    dct[88] = 88
    lst.reverse()

manager = Manager()
dct = manager.dict()
lst = manager.list(range(5,10))

p = Process(target=func, args=(dct, lst))
p.start()
p.join()
<span style="font-weight:bold">print</span> dct, <span style="font-style:italic">&#39;|&#39;</span>, lst
Out: {88: 88} | [9, 8, 7, 6, 5]</code></pre></div>
<p>一个 Manager 对象是一个服务进程，推荐多进程程序中，数据共享就用一个 manager 管理。</p>

<h2 id="进程管理">进程管理</h2>

<p>如果有50个任务要执行, 但是 CPU 只有4核, 你可以创建50个进程来做这个事情。但是大可不必，徒增管理开销。如果你只想创建4个进程，让他们轮流替你完成任务，不用自己去管理具体的进程的创建销毁，那 Pool 是非常有用的。</p>

<p>Pool 是进程池，进程池能够管理一定的进程，当有空闲进程时，则利用空闲进程完成任务，直到所有任务完成为止，用法如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> func(x):
    <span style="font-weight:bold">return</span> x*x

pool = Pool(processes=4)
<span style="font-weight:bold">print</span> pool.map(func, range(8))</code></pre></div>
<p>Pool 进程池创建4个进程，不管有没有任务，都一直在进程池中等候，等到有数据的时候就开始执行。
Pool 的 API 列表如下：</p>

<ul>
<li>apply(func[, args[, kwds]])</li>
<li>apply_async(func[, args[, kwds[, callback]]])</li>
<li>map(func, iterable[, chunksize])</li>
<li>map_async(func, iterable[, chunksize[, callback]])</li>
<li>imap(func, iterable[, chunksize])</li>
<li>imap_unordered(func, iterable[, chunksize])</li>
<li>close()</li>
<li>terminate()</li>
<li>join()</li>
</ul>

<h3 id="异步执行">异步执行</h3>

<p>apply_async 和 map_async 执行之后立即返回，然后异步返回结果。 使用方法如下</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> func(x):
    <span style="font-weight:bold">return</span> x*x

<span style="font-weight:bold">def</span> callback(x):
    <span style="font-weight:bold">print</span> x, <span style="font-style:italic">&#39;in callback&#39;</span>
    
pool = Pool(processes=4)
result = pool.map_async(func, range(8), 8, callback)
<span style="font-weight:bold">print</span> result.get(), <span style="font-style:italic">&#39;in main&#39;</span>
Out:
[0, 1, 4, 9, 16, 25, 36, 49] <span style="font-weight:bold">in</span> callback
[0, 1, 4, 9, 16, 25, 36, 49] <span style="font-weight:bold">in</span> main</code></pre></div>
<p>有两个值得提到的，一个是 callback，另外一个是 multiprocessing.pool.AsyncResult。 callback 是在结果返回之前，调用的一个函数，这个函数必须只有一个参数，它会首先接收到结果。callback 不能有耗时操作，因为它会阻塞主线程。</p>

<p>AsyncResult 是获取结果的对象，其 API 如下</p>

<ul>
<li>get([timeout])</li>
<li>wait([timeout])</li>
<li>ready()</li>
<li>successful()</li>
</ul>

<p>如果设置了 timeout 时间，超时会抛出 multiprocessing.TimeoutError 异常。wait 是等待执行完成。 ready 测试是否已经完成，successful 是在确定已经 ready 的情况下，如果执行中没有抛出异常，则成功，如果没有ready 就调用该函数，会得到一个 AssertionError 异常。</p>

<h3 id="pool-管理">Pool 管理</h3>

<p>这里不再继续讲 map 的各种变体了，因为从上面的 API 一看便知。</p>

<p>然后我们来看看 Pool 的执行流程，有三个阶段。第一、一个进程池接收很多任务，然后分开执行任务；第二、不再接收任务了；第三、等所有任务完成了，回家，不干了。</p>

<p>这就是上面的方法，close 停止接收新的任务，如果还有任务来，就会抛出异常。 join 是等待所有任务完成。 join 必须要在 close 之后调用，否则会抛出异常。terminate 非正常终止，内存不够用时，垃圾回收器调用的就是这个方法。</p>

      </div>

      <footer>
        <div id="utter-container"></div>
<script src="https://utteranc.es/client.js" repo='quqiuzhu/quqiuzhu.github.io'
    issue-term="title" theme='github-light' crossorigin="anonymous"
    async>
</script>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
      <p>浙ICP备17015868号</p>
        
     © 2019
    
    
  </section>
</footer>

    </main>

    

<script type="text/javascript" src="https://quqiuzhu.com/bundle.min.71f6cc734ea8c75ac28fd27a49444fac11880210be81de4b7bf8c1a7c59871d5a08807d5b36de3de68282328b61032de05fa94ac41c8ff2c4e3992d18d92ae1b.js" integrity="sha512-cfbMc06ox1rCj9J6SURPrBGIAhC&#43;gd5Le/jBp8WYcdWgiAfVs23j3mgoIyi2EDLeBfqUrEHI/yxOOZLRjZKuGw=="></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-140819128-1', 'auto');
	
	ga('send', 'pageview');
}
</script>



  </body>

</html>
