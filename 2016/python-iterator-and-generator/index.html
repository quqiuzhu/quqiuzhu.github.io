<!DOCTYPE html>
<html lang="zh-CN">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="屈秋竹">
    <meta name="description" content="屈秋竹的个人网站">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python 学习笔记 迭代器和生成器"/>
<meta name="twitter:description" content="迭代器 一个迭代器是一个实现了__iter__()方法和 next()方法的对象，但是我发现这两个并不需要一起实现，就像Java中一样，返回迭代子的对象和迭代子是分离的。 __iter__() 只是返回迭代器，真正进行迭代的是实现了 next()方法的，所以可以在 for i in r 的r中实现一个__iter__()方法，然后返回一个实现了next()方法的对象
class Itrator(object): def __init__(self): self.i = 4; def next(self): if self.i: self.i -= 1 return self.i else: raise StopIteration class Iterable(object): def __iter__(self): return Itrator() for i in Iterable(): print i 当然一般上都可以把这两个方法写在同一个类里面，python里和Java是一样的，一个是Iterable，一个是Itrator。
生成器 有两种生成器，第一种是产生值的生成器，像下面这样的
def power(values): print &#39;xxxx&#39; for value in values: yield value 第二种种是作为表达式的生成器，这种生成器需要接受外面的输入，像下面这样的
def psychologist(): print &#39;plaese tell me your problem&#39; while True : answer = (yield) if answer is not None: if answer."/>


    <base href="https://quqiuzhu.com/2016/python-iterator-and-generator/">
    <title>
  Python 学习笔记 迭代器和生成器 · 看见未来
</title>

    <link rel="canonical" href="https://quqiuzhu.com/2016/python-iterator-and-generator/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://quqiuzhu.com/css/coder.min.ac37073bc2826cd28ef57364a9fe339de7ebcb26dafc22fd832cb35cf5b1d048.css" integrity="sha256-rDcHO8KCbNKO9XNkqf4znefryyba/CL9gyyzXPWx0Eg=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="https://quqiuzhu.com/css/custom.css">
    

    <link rel="icon" type="image/png" href="https://quqiuzhu.com/favicon.ico" sizes="32x32">
    <link rel="icon" type="image/png" href="https://quqiuzhu.com/favicon.ico" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.56.0-DEV" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://quqiuzhu.com/">
      看见未来
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://quqiuzhu.com/archives/">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://quqiuzhu.com/about/">关于</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>Python 学习笔记 迭代器和生成器</h1>
    </header>

    

<h2 id="迭代器">迭代器</h2>

<p>一个迭代器是一个实现了<code>__iter__()</code>方法和 <code>next()</code>方法的对象，但是我发现这两个并不需要一起实现，就像Java中一样，返回迭代子的对象和迭代子是分离的。 <code>__iter__()</code> 只是返回迭代器，真正进行迭代的是实现了 <code>next()</code>方法的，所以可以在 <code>for i in r</code> 的r中实现一个<code>__iter__()</code>方法，然后返回一个实现了<code>next()</code>方法的对象</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">class</span> <span style="font-weight:bold">Itrator</span>(object):
    <span style="font-weight:bold">def</span> __init__(self):
        self.i = 4;
        
    <span style="font-weight:bold">def</span> next(self):
        <span style="font-weight:bold">if</span> self.i:
            self.i -= 1
            <span style="font-weight:bold">return</span> self.i
        <span style="font-weight:bold">else</span>:
            <span style="font-weight:bold">raise</span> <span style="font-weight:bold">StopIteration</span>

<span style="font-weight:bold">class</span> <span style="font-weight:bold">Iterable</span>(object):
    <span style="font-weight:bold">def</span> __iter__(self):
        <span style="font-weight:bold">return</span> Itrator()

<span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> Iterable():
    <span style="font-weight:bold">print</span> i</code></pre></div>
<!-- more -->

<p>当然一般上都可以把这两个方法写在同一个类里面，python里和Java是一样的，一个是Iterable，一个是Itrator。</p>

<h2 id="生成器">生成器</h2>

<p>有两种生成器，第一种是产生值的生成器，像下面这样的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> power(values):
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;xxxx&#39;</span>
    <span style="font-weight:bold">for</span> value <span style="font-weight:bold">in</span> values:
        <span style="font-weight:bold">yield</span> value</code></pre></div>
<p>第二种种是作为表达式的生成器，这种生成器需要接受外面的输入，像下面这样的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> psychologist():
    <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;plaese tell me your problem&#39;</span>
    <span style="font-weight:bold">while</span> True :
        answer = (<span style="font-weight:bold">yield</span>)
        <span style="font-weight:bold">if</span> answer <span style="font-weight:bold">is</span> <span style="font-weight:bold">not</span> None:
            <span style="font-weight:bold">if</span> answer.endswith(<span style="font-style:italic">&#39;?&#39;</span>):
                <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;what is you question?&#39;</span>
            <span style="font-weight:bold">elif</span> <span style="font-style:italic">&#39;good&#39;</span> <span style="font-weight:bold">in</span> ans:
                <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;good good&#39;</span>
            <span style="font-weight:bold">else</span>:
                <span style="font-weight:bold">print</span> <span style="font-style:italic">&#39;hahaha&#39;</span>
        <span style="font-weight:bold">else</span>:
            <span style="font-weight:bold">raise</span> <span style="font-weight:bold">StopIteration</span></code></pre></div>
<h3 id="第一种生成器">第一种生成器</h3>

<p>这种生成器是可以迭代的，因为生成器函数会返回一个生成器对象，而生成器实现了<code>next</code> 和 <code>__iter__</code>方法，所以是可以迭代的。</p>

<p>另外，由于生成器函数默认会返回一个生成器，所以生成器方法中return 语句不能返回任何东西，否则就会出错。</p>

<p>生成器最重要的一个特性，是可以暂停并保持生成器方法的状态，直到调用下一个生成器方法，这一种特性被用在协同程序中。</p>

<p>一开始调用生成器函数时，除了返回一个生成器对象之外，不会执行任何代码。因此，在上面的power 方法中，即便是 print &lsquo;xxxx&rsquo;语句在 关键字yield之前，也不会执行。这些代码是初始代码，将会在第一个next方法调用的时候执行。</p>

<h3 id="第二种生成器">第二种生成器</h3>

<p>这种生成器需要外面给它传值，有四个方法,分别是 <code>next()</code>, <code>send(val)</code>, <code>throw(err)</code>, <code>close()</code>。</p>

<p><code>send(val)</code> 方法给生成器传值，每一次传值就是一次迭代</p>

<p><code>next()</code> 方法等价于 <code>send(None)</code>， 因此迭代该生成器，就相当于不断发送None 值，直到遇到 StopIteration 异常。</p>

<p><code>close()</code> 相当于做了一个停止的标记，之后不能再调用 send 和 next 方法，否则会得到 StopIteration 异常，但是可以调用throw方法。</p>

<p><code>throw(err)</code> 方法会向生成器发出异常，而不是向外发出。要理解这一点并不难，因为这样外面调用者就可以随意停止迭代了。</p>

<h3 id="生成器的几个应用">生成器的几个应用</h3>

<ul>
<li>协程</li>
<li>生成器表达式（类似列表推导）</li>
</ul>

<h2 id="itertools">itertools</h2>

<p>这里面的函数一般都以i开头。</p>

<p><code>islice()</code> 窗口迭代，第一个参数是iterable对象，后面如果只有一个参数，则是stop位置，如果两个参数则是start 和 stop，第三个参数是步长</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">a = range(10)
list(itertools.islice(a, 4))
Out: [0, 1, 2, 3]
list(itertools.islice(a, 4, None))
Out: [4, 5, 6, 7, 8, 9]
list(itertools.islice(a, 4, None, 2))
Out: [4, 6, 8]</code></pre></div>
<p><code>count</code>,<code>cycle</code>,<code>repeat</code> 无限迭代，第一个一段整数不断递增或者递减，第二个传入一个可迭代对象，然后就会得到一个循环迭代。repeat函数会一直重复迭代一个元素。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">list(itertools.islice(itertools.count(20), 4))
Out: [20, 21, 22, 23]
list(itertools.islice(itertools.count(20,-1), 4))
Out: [20, 19, 18, 17]
list(itertools.islice(itertools.repeat(-1), 4))
Out: [-1, -1, -1, -1]
list(itertools.islice(itertools.cycle([1,2,3]), 4))
Out: [1, 2, 3, 1]</code></pre></div>
<p><code>chain</code>, 传入一组可迭代对象，按顺序迭代，有时候知道是列表等明确的数据类型的时候，是不需要这个函数的，一般也可以先转换，再连接，但又太浪费内存资源了。所以写一个共用库的时候，最后记得用这个。</p>

<p>相似的是<code>tee</code>, 传入一个iterable对象，返回多个iterable对象，默认返回两个</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">l1 = [2,3,9,4,7,1]
l2 = [3,3,3,3,3,3]
list(itertools.chain(l1,l2)))
Out: [2, 3, 9, 4, 7, 1, 3, 3, 3, 3, 3, 3]
i1,i2 = itertools.tee(l1,2)
i1.next()
Out: 2
i2.next()
Out: 2</code></pre></div>
<p><code>compress</code>,<code>ifilter</code>,<code>ifilterfalse</code> 过滤迭代，<code>compress</code>函数传入iterable数据，第二个iterable选择条件，而<code>ifilter</code>,<code>ifilterfalse</code>，第一个参数是筛选函数，第二个参数是数据。下面是选择征兵青年，输出年龄在18-24岁的人名，用这3个函数分别的完成方式</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">candidates = [
	(8,<span style="font-style:italic">&#39;zhangsan&#39;</span>), 
	(21, <span style="font-style:italic">&#39;lisi&#39;</span>), 
	(19, <span style="font-style:italic">&#39;wangmazi&#39;</span>),
	(40, <span style="font-style:italic">&#39;laozi&#39;</span>)
]
list(itertools.compress(
	 	(c[1] <span style="font-weight:bold">for</span> c <span style="font-weight:bold">in</span> candidates),
	 	(18 &lt;= c[0] &lt;= 22 <span style="font-weight:bold">for</span> c <span style="font-weight:bold">in</span> candidates)
	 )
)
Out: [<span style="font-style:italic">&#39;lisi&#39;</span>, <span style="font-style:italic">&#39;wangmazi&#39;</span>]
list(itertools.ifilter(
		<span style="font-weight:bold">lambda</span> x:18 &lt;= x[0] &lt;= 22,
	 	(c <span style="font-weight:bold">for</span> c <span style="font-weight:bold">in</span> candidates)
	 )
)
Out: [(21, <span style="font-style:italic">&#39;lisi&#39;</span>), (19, <span style="font-style:italic">&#39;wangmazi&#39;</span>)]</code></pre></div>
<p><code>ifilterfalse</code>函数与<code>ifilter</code>只是条件函数不同，就不列举了。这里可以发现一个轻微的不同，我只要输出名字，但是<code>ifilter</code>输出了 candidate 列表。但是如果只传入名字作为参数，又无法判断，只能输入 candidate 列表，因为输入的数据和输出的数据是同源的，返回的就只能是 candidate列表。该例子说明了为什么有了 <code>ifilter</code> 还需要 <code>compress</code> 的原因，当需要返回的数据不足以作为筛选判断条件的时候，<code>compress</code> 就非常有用。</p>

<p><code>takewhile</code>,<code>dropwhile</code> 第一个参数是筛选函数，第二个参数是数据。<code>takewhile</code> 是一开始就拿，直到条件不满足为止；<code>dropwhile</code> 一开始不要，直到条件不满足，然后拿之后的所有数据。所以<code>takewhile</code>倾向于拿前面的数据，<code>dropwhile</code>倾向于拿后半部分的数据。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">list(itertools.takewhile(<span style="font-weight:bold">lambda</span> x: x&lt;5, [1,4,6,4,1]))
Out: [1, 4]
list(itertools.dropwhile(<span style="font-weight:bold">lambda</span> x: x&lt;5, [1,4,6,4,1]))
Out: [6, 4, 1]</code></pre></div>
<p><code>izip()</code>, <code>izip_longest()</code> 装包函数，把几个课迭代的对象组合起来，返回元组迭代</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">list(itertools.izip(<span style="font-style:italic">&#39;ABCD&#39;</span>, <span style="font-style:italic">&#39;xy&#39;</span>))
Out: [(<span style="font-style:italic">&#39;A&#39;</span>, <span style="font-style:italic">&#39;x&#39;</span>), (<span style="font-style:italic">&#39;B&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>)]
list(itertools.izip_longest(<span style="font-style:italic">&#39;ABCD&#39;</span>, <span style="font-style:italic">&#39;xy&#39;</span>))
Out: [(<span style="font-style:italic">&#39;A&#39;</span>, <span style="font-style:italic">&#39;x&#39;</span>), (<span style="font-style:italic">&#39;B&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>), (<span style="font-style:italic">&#39;C&#39;</span>, None), (<span style="font-style:italic">&#39;D&#39;</span>, None)]
list(itertools.izip_longest(<span style="font-style:italic">&#39;ABCD&#39;</span>, <span style="font-style:italic">&#39;xy&#39;</span>, fillvalue = <span style="font-style:italic">&#39;-&#39;</span>))
Out: [(<span style="font-style:italic">&#39;A&#39;</span>, <span style="font-style:italic">&#39;x&#39;</span>), (<span style="font-style:italic">&#39;B&#39;</span>, <span style="font-style:italic">&#39;y&#39;</span>), (<span style="font-style:italic">&#39;C&#39;</span>, <span style="font-style:italic">&#39;-&#39;</span>), (<span style="font-style:italic">&#39;D&#39;</span>, <span style="font-style:italic">&#39;-&#39;</span>)]</code></pre></div>
<p><code>imap()</code>, <code>starmap()</code> 第一个参数是函数，后面的是传入的数据，返回的是函数的返回值序列 <code>imap()</code> 先把后面的一串可迭代对象装包，<code>starmap()</code>是后面参数已经装包好了的</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">list(itertools.imap(operator.add, (2,3,10), (5,2,3)))
Out: [7, 5, 13]
list(itertools.imap(operator.add, (2,3,10), (5,2)))
Out: [7, 5]</code></pre></div>
<p><code>groupby()</code> 将迭代对象变为按连续的key分组，返回是一个迭代对象，该对象为(key, subgroup) 形式。这里只是让key不连续重复，并不会保证key不重复</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">lst = <span style="font-style:italic">&#39;get uuuuuuuuuuuuuuupd&#39;</span>
<span style="font-weight:bold">def</span> group(data):
    <span style="font-weight:bold">for</span> k,g <span style="font-weight:bold">in</span> itertools.groupby(data):
        <span style="font-weight:bold">print</span> k,list(g)
group(lst)
Out: 
g [<span style="font-style:italic">&#39;g&#39;</span>]
e [<span style="font-style:italic">&#39;e&#39;</span>]
t [<span style="font-style:italic">&#39;t&#39;</span>]
  [<span style="font-style:italic">&#39; &#39;</span>]
u [<span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>, <span style="font-style:italic">&#39;u&#39;</span>]
p [<span style="font-style:italic">&#39;p&#39;</span>]
d [<span style="font-style:italic">&#39;d&#39;</span>]</code></pre></div>
<p><code>product()</code>, <code>permutations()</code>, <code>combinations()</code> 笛卡尔乘法、排列和组合。笛卡尔乘包含自身与自身的组合，排列不包含，而组合不按顺序来。这个不举例子，可以将一些双重循环变成单循环</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    <p>
       © 2019
    &nbsp
      
        浙ICP备17015868号
      
    &nbsp
      <span> <a href="https://quqiuzhu.com/index.xml"
        target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20"
          fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
          class="feather feather-rss">
          <path d="M4 11a9 9 0 0 1 9 9"></path>
          <path d="M4 4a16 16 0 0 1 16 16"></path>
          <circle cx="5" cy="19" r="1"></circle>
        </svg></a>
      </span>
    </p>
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
