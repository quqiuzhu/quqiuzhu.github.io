<!DOCTYPE html>
<html lang="zh-CN">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="屈秋竹">
    <meta name="description" content="屈秋竹的个人网站">
    <meta name="keywords" content="屈秋竹,秋竹,程序员,站长,工程师,商汤,虎牙,音视频,看见未来">

    <base href="https://quqiuzhu.com/2016/python-regexp/">
    <title>
  Python 学习笔记 正则表达式 · 看见未来
</title>

    <link rel="canonical" href="https://quqiuzhu.com/2016/python-regexp/">

    
    <link rel="stylesheet" href="https://s3.pstatp.com/cdn/expire-1-M/normalize/8.0.1/normalize.min.css"/>
    
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_1306475_6bvggoehvvm.css" />

    
    
    <link rel="stylesheet" href="https://quqiuzhu.com/css/coder.min.e7f92773eeff2c735118a3ba44689134642453f82cd54f6f58a8f074a49fe506.css" integrity="sha256-5/knc&#43;7/LHNRGKO6RGiRNGQkU/gs1U9vWKjwdKSf5QY="
      crossorigin="anonymous" media="screen" />

    

    <link rel="icon" type="image/png" href="https://quqiuzhu.com/favicon.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://quqiuzhu.com/favicon.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.86.0" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://quqiuzhu.com/">
      看见未来
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><span class="iconfont icon-menu"></span></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://quqiuzhu.com/posts/">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://quqiuzhu.com/about/">关于</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Python 学习笔记 正则表达式</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <span class="iconfont icon-calendar"></span>
              <time datetime='2016-04-27T14:24:46Z'>
                2016-04-27
              </time>
              &nbsp
              <span class="tags">
  <span class="iconfont icon-tag"></span>
    <a href="https://quqiuzhu.com/tags/python/">python</a>
      <span class="separator">•</span>
    <a href="https://quqiuzhu.com/tags/magic/">magic</a></span>

            </span>
          </div>
        </div>
      </header>

      <div class="post-content">
        <p>1.5 版之后，Python 内建支持正则表达式，它提供的正则表达式是 Perl 风格的。</p>
<p>正则表达式（或 RE）是一种小型的、高度专业化的编程语言，经常使用会感受到它的神奇之处。Python 正则表达式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行的。</p>
<p>本文开始给出一个匹配规则的表格，然后谈谈常用的正则表达式。然后讲了 Python 中 re 模块的函数及其相关的使用方式，最后以实例的形式给出了相关函数的用法。</p>
<!-- raw HTML omitted -->
<h2 id="正则匹配表">正则匹配表</h2>
<table>
<thead>
<tr>
<th>记号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>匹配foo这个字符串</td>
</tr>
<tr>
<td>foo<!-- raw HTML omitted -->I<!-- raw HTML omitted -->bar</td>
<td>匹配foo 或者 bar</td>
</tr>
<tr>
<td>.</td>
<td>匹配任何字符（除了换行符）</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
</tr>
</tbody>
</table>
<ul>
<li>
<pre><code>      | 匹配 0 次或更多次
</code></pre>
</li>
</ul>
<ul>
<li>
<pre><code>      | 匹配 1 次或者更多次
</code></pre>
</li>
</ul>
<p>?           | 匹配 0 或 1 次
{N}         | 匹配 N 次
{M,N}       | 匹配 M 到 N 次
[&hellip;]       | 匹配 方括号里面的单个字符，可省略中间部分[a-z]
[^&hellip;]      | 匹配 不在方括号中出现的字符
(*<!-- raw HTML omitted -->I<!-- raw HTML omitted -->+<!-- raw HTML omitted -->I<!-- raw HTML omitted -->?<!-- raw HTML omitted -->I<!-- raw HTML omitted -->{})? | 后面的问号，加在前面任何一个字符上，表示匹配越短越好(非贪婪)
(&hellip;)       | 匹配括号中的正则表达式，并保存为子组
\d          | 匹配 [0-9] <code>\D</code> 相反
\w          | 匹配 [A-Za-z0-9_] <code>\W</code> 相反
\s          | 匹配任何空白 <code>\S</code> 相反
\b          | 匹配单词边界 <code>\B</code> 相反
\N          | N为一个数字，匹配子组 N
\C          | C为特殊字符，匹配特殊字符 <code>\.</code>,<code>\*</code>等
\A          | 同 <code>^</code>
\Z          | 同 <code>$</code></p>
<blockquote>
<p>上面的表格中 <code>|</code> 以 <!-- raw HTML omitted -->I<!-- raw HTML omitted --> 代替</p>
</blockquote>
<h2 id="常用正则表达式">常用正则表达式</h2>
<ul>
<li>中文字符: <code>[\u4e00-\u9fa5]</code></li>
<li>HTML标记: <code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code></li>
<li>Email地址: <code>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</code></li>
<li>国内电话号码: <code>\d{3}-\d{8}|\d{4}-\d{7}</code></li>
<li>HTTP_URL: <code>(https?)://([^/]+)(/?.*)</code></li>
<li>时间(24h制): <code>((1|0?)[0-9]|2[0-3]):([0-5][0-9])</code></li>
<li>URL: <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li>
<li>QQ号: <code>[1-9][0-9]{4,}</code></li>
</ul>
<h2 id="python-的-re-模块">Python 的 re 模块</h2>
<p>使用正则表达式，我们通常有下面的几种需求</p>
<ul>
<li>验证是否匹配字符串</li>
<li>验证字符串中有正则表达式表示的字符</li>
<li>符合正则表达式的字符串提取</li>
<li>正则表达式替换</li>
<li>字符串分割</li>
</ul>
<p>因此从 re 包中可以到处的函数如下</p>
<ul>
<li>compile(pattern, flags=0)</li>
<li>match(pattern, string, flags=0)</li>
<li>search(pattern, string, flags=0)</li>
<li>findall(pattern, string, flags=0)</li>
<li>sub(pattern, repl, string, count=0, flags=0)</li>
<li>subn(pattern, repl, string, count=0, flags=0)</li>
<li>split(pattern, string, maxsplit=0, flags=0)</li>
</ul>
<p>一般的处理流程是编译正则表达式，获取一个 regex 对象，然后使用该对象的方法。每个函数对象里面包含的方法和 re 包中包含的一样(除了 compile 函数)。 实际上是 re 模块里面的函数调用了 regex 对象的相应的方法，下面是 re 包中 match 函数的实现，其他函数也是类似的。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-weight:bold">def</span> match(pattern, string, flags=0):
    <span style="font-weight:bold">return</span> _compile(pattern, flags).match(string)
</code></pre></div><p>re 包中的函数是先编译 regex 对象，然后调用其方法的。因为 re 模块有一块缓存区用来保存匹配过的正则表达式，所以速度也不会很慢，但是还是建议使用 regex 对象。</p>
<p>上面的函数都有一个 flags 参数，其实只是用来编译的，因为 re 包中的函数需要先编译再调用其他方法，所以每个函数都有一个 flag 参数。每个 flag 表示的含义如下</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="font-style:italic"># ignore case</span>
I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE 

<span style="font-style:italic"># assume current 8-bit locale</span>
L = LOCALE = sre_compile.SRE_FLAG_LOCALE 

<span style="font-style:italic"># assume unicode locale</span>
U = UNICODE = sre_compile.SRE_FLAG_UNICODE 

<span style="font-style:italic"># make anchors look for newline</span>
M = MULTILINE = sre_compile.SRE_FLAG_MULTILINE 

<span style="font-style:italic"># make dot match newline</span>
S = DOTALL = sre_compile.SRE_FLAG_DOTALL 

<span style="font-style:italic"># ignore whitespace and comments</span>
X = VERBOSE = sre_compile.SRE_FLAG_VERBOSE 
</code></pre></div><h2 id="例子">例子</h2>
<p><code>match()</code> 和 <code>search()</code> 如果匹配的话，会返回一个匹配对象，否则会返回 None。匹配对象有 <code>group()</code> 与 <code>groups()</code> 方法。 <code>group()</code> 会返回匹配的字符串， 而<code>groups()</code> 返回存在的子组元组的元组，如果不存在匹配的子组，则返回<code>()</code>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">g = re.match(<span style="font-style:italic">&#39;foo&#39;</span>, <span style="font-style:italic">&#39;foo&#39;</span>) <span style="font-style:italic"># 匹配对象</span>
g.group() <span style="font-style:italic"># &#39;foo&#39;</span>
g.groups() <span style="font-style:italic"># ()</span>

g = re.match(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) 
g.group() <span style="font-style:italic"># &#39;foo2033&#39;</span>
g.groups() <span style="font-style:italic"># (&#39;2033&#39;,)</span>

g = re.match(<span style="font-style:italic">&#39;^foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># 同上</span>
g = re.match(<span style="font-style:italic">&#39;^foo(\d+)$&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># None</span>
g = re.match(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;dfoo2033d&#39;</span>) <span style="font-style:italic"># None</span>
</code></pre></div><p>从上面最后一组的值，可以知道，<code>re.match</code> 默认从头开始匹配，但是并不默认一定要完全匹配到字符串末尾，除非使用结束符 <code>$</code> 。</p>
<p><code>re.search</code> 与 <code>re.match</code>的区别正在于此，<code>re.search</code>并不一定要从头开始，比如说上面四组匹配结果如下</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">g = re.search(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># 匹配成功</span>
g = re.search(<span style="font-style:italic">&#39;^foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># 匹配成功</span>
g = re.search(<span style="font-style:italic">&#39;^foo(\d+)$&#39;</span>, <span style="font-style:italic">&#39;foo2033d&#39;</span>) <span style="font-style:italic"># None</span>
g = re.search(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;dfoo2033d&#39;</span>) <span style="font-style:italic"># 匹配成功</span>
</code></pre></div><p><code>re.findall</code> 跟 <code>re.search</code> 与 <code>re.match</code> 的区别是什么呢？第一，<code>re.search</code> 与 <code>re.match</code> 只匹配一次。 第二，<code>re.findall</code> 总会返回一个列表，不管匹配不匹配。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">g = re.match(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
g.group() <span style="font-style:italic"># &#39;foo2033&#39;</span>
g.groups() <span style="font-style:italic"># (&#39;2033&#39;,)</span>

l = re.findall(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
l <span style="font-style:italic"># [&#39;2033&#39;, &#39;9&#39;]</span>
l = re.findall(<span style="font-style:italic">&#39;foo\d+&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
l <span style="font-style:italic"># [&#39;foo2033&#39;, &#39;foo9&#39;]</span>
</code></pre></div><p><code>re.findall</code> 返回的列表，如果正则表达式有子组，则匹配返回的子组列表，否则返回整个正则表达式的匹配列表。</p>
<p><code>re.sub</code> 与 <code>re.subn</code> 是用来做字符串替换的，它们唯一的区别是前面的返回替换了的字符串，后面返回一个替换之后的字符串和替换次数的元组。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">r = re.sub(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>,<span style="font-style:italic">&#39;*&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
r <span style="font-style:italic"># &#39;**d&#39;</span>

r = re.subn(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>,<span style="font-style:italic">&#39;*&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
r <span style="font-style:italic"># (&#39;**d&#39;, 2)</span>
</code></pre></div><p><code>re.split</code> 使用正则表达式作为分隔符，但有子组和无子组的情况是不一样的，有子组的会分割字符串，但会留下子组的匹配值。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py">l = re.split(<span style="font-style:italic">&#39;foo(\d+)&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
l <span style="font-style:italic"># [&#39;&#39;, &#39;2033&#39;, &#39;&#39;, &#39;9&#39;, &#39;d&#39;]</span>

l = re.split(<span style="font-style:italic">&#39;foo\d+&#39;</span>, <span style="font-style:italic">&#39;foo2033foo9d&#39;</span>)
l <span style="font-style:italic"># [&#39;&#39;, &#39;&#39;, &#39;d&#39;]</span>
</code></pre></div>
      </div>

      <footer>
        <div id="utter-container"></div>
<script src="https://utteranc.es/client.js" repo='quqiuzhu/quqiuzhu.github.io'
    issue-term="title" theme='github-light' crossorigin="anonymous"
    async>
</script>
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    <p> <a href="https://beian.miit.gov.cn">浙ICP备17015868号-1</a> </p>
        
     © 2022
    
    
  </section>
</footer>

    </main>

    

<script type="text/javascript" src="https://quqiuzhu.com/bundle.min.6e69e85dd5983e29ee3d3d981c3008270531c7faad47072b266d46db0e44b49357be605190a1c26ee07cbcb22afda651ae35f605c9187cb42bc3c047b3b226d4.js" integrity="sha512-bmnoXdWYPinuPT2YHDAIJwUxx/qtRwcrJm1G2w5EtJNXvmBRkKHCbuB8vLIq/aZRrjX2BckYfLQrw8BHs7Im1A=="></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-140819128-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  </body>

</html>
