<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>屈秋竹</title>
  <subtitle>看见未来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://quqiuzhu.com/"/>
  <updated>2017-06-04T07:30:38.000Z</updated>
  <id>http://quqiuzhu.com/</id>
  
  <author>
    <name>屈秋竹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>打造一款直播硬件</title>
    <link href="http://quqiuzhu.com/2017/build-yunxibox/"/>
    <id>http://quqiuzhu.com/2017/build-yunxibox/</id>
    <published>2017-06-04T07:26:03.000Z</published>
    <updated>2017-06-04T07:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>离上次写博客已经过去6个月了， 这段时间我一直在做一款直播硬件「云犀BOX」，现在产品已经日臻完善，开始对外销售了。在我们公司<a href="http://yunxi.tv/site/box" target="_blank" rel="external">云犀直播</a>的官网上可以看到它的一些介绍。</p>
<a id="more"></a>
<p>与一般的手机直播不一样，我们追求的是专业级的高质量的直播。 手机摄像头因为诸多限制，应用在稍微大一些的场景的话效果会差很多。 专业直播的应用场景一开始是一些电视媒体，体育赛事直播等。在我们发布「云犀BOX」之前，专业直播是比较困难，花费人力和财力的事情。 一般专业直播的流程是这样的:</p>
<blockquote>
<p>A公司要准备一场发布会直播，它先去找企业直播服务公司B建立一个直播活动(直播间)，设置好直播间的封面，和其他一些公司宣传的内容。 之后B公司派员工C到直播现场执行直播，员工C带上摄像机、upmost(视频采集卡)和笔记本电脑，摄像机连接视频采集卡，视频采集卡连接到电脑，配置电脑上的OBS(专业直播软件)，设置好RTMP推流地址，然后开始直播。</p>
</blockquote>
<p>对于需求方和提供直播服务的公司来说，人都是一个瓶颈。近两年来，直播作为一种内容形式被广泛接受，一些公司已经用直播作为其日常与用户沟通的渠道，比如「得到」的周会直播。这些公司和团体并没有专业的知识，搭建一个公司的直播频道的有可能只是初入职场的一个运营实习生，所以直播应该更加简单，让普通人第一次上手就会用。</p>
<p>所以我们做了这款「云犀BOX」，只需要一个摄像机，一根HDMI线，一个比手机稍大的「云犀BOX」连上之后点击开始直播就好了。摄像机和「云犀BOX」可以通过热靴云台连在一起，如果扛摄像机直播的话也会非常方便。</p>
<p>「云犀BOX」是由完全自主研发的一款产品，能自己做的都自己做了，包括直播推流SDK、板卡设计、外观设计等，当然也包含了里面的软件，我们就此申请了3款专利。</p>
<p>其中软件部分最核心的是推流SDK，我们花了很长时间优化，前三个月一直在搞推流SDK，后面也一直有优化。其实各个视频云平台都有推流SDK，比如七牛、阿里云。为了能够针对我们的硬件进行优化，我们选择重新实现，现在推流的流畅性与稳定性比平均水平高很多的。</p>
<p>硬件部分，从包装到电源板卡芯片，任何可能出错的地方都出错过，不可能出错的地方也出错过，因此推出时间比我们预想的要迟一个半月左右。即便这样，这款硬件能在半年内做出来并上市，让我感受到了中国硬件产业链的成熟。</p>
<p>人工智能时代，科技公司不应该只玩软件了，还需要会玩硬件和算法的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;离上次写博客已经过去6个月了， 这段时间我一直在做一款直播硬件「云犀BOX」，现在产品已经日臻完善，开始对外销售了。在我们公司&lt;a href=&quot;http://yunxi.tv/site/box&quot;&gt;云犀直播&lt;/a&gt;的官网上可以看到它的一些介绍。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>再见路口</title>
    <link href="http://quqiuzhu.com/2016/goodbye-lukou/"/>
    <id>http://quqiuzhu.com/2016/goodbye-lukou/</id>
    <published>2016-11-25T19:58:25.000Z</published>
    <updated>2016-11-29T07:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天办完离职手续，退出路口的微信群和QQ群，我正式离开了我的第一家公司。</p>
<a id="more"></a>
<p>14年12月，刚创立4个月的路口团队去浙大校招，那时候去听宣讲会的人只有11人，其中3人来了路口。子扬和小萌都相继离开了，这次我离职之后，我们那一批校招进来的人，都走了。</p>
<p>我是当天面试完就签了三方协议，但因为学校有考试，春节之后的3月9日才正式入职。入职之后一个月，我和带我的老大君涵开发了路口 android 1.1 版。那时的我，虽然是一个实习生，但我觉得我干了一个正式员工的活。那时候，我的自行车还没有被偷，我常常和子扬在晚上10:30之后一起骑车回学校。那时候Uber刚开始在杭州宣传，我3月15日注册了Uber。11月14号Uber发信息给我，说我已经注册610天了，今天25号，我正式离职，所以推算下来，我在路口的时间是627天。</p>
<p>此后，我请两个月假回学校写毕业论文。在此期间，公司也发生了一些事情，导致君涵，子扬，刀哥相继离开。后来我回到公司继续实习，但浙大的毕业程序非常烦，我得经常从学校跑，再加上我需要准备一些考试，很累。直到7月初拿到毕业证，我从实习生转正，正式入职路口。</p>
<p>公司地址也从城市心境的住宅搬到了数字娱乐产业园。那时网络总是掉线，大家都一直抱怨，东哥叫我来负责这件事情，我压力很大，后来我找到了思科的专业设备，解决了网络掉线的问题。在数字娱乐产业园的时间非常短，就从6月到9月，在那里开发了路口 android 2.0版，增加了专辑功能。我记得清楚，是因为那是15年的中秋，公司正要从数字娱乐产业园搬出来，我们去高技街的beta咖啡开发了2.0版。因为嫌他们太吵，我们还刻意躲着运营团队的人。</p>
<p>之后公司搬到了文二西路，我个人做了一个比较失败的项目，hadoop项目。然后做了路口的 android 3.0版，这一版相当难产，前前后后拖了一个半月，上线之后效果也不好，留存率一直往下掉。此后，路口暂停产品更新。</p>
<p>年终时，公司组织了去日本旅游，去买了好多东西。我和博士去镰仓看了拍摄「灌篮高手」的中学，去海滩边坐了坐，然后在附近找吃的。还去了江之岛，我们到那时，正是日落时分，海边吹来温暖的风。</p>
<p>16年春节之后，由于hadoop项目不成功，我们决定不搭建自己的云平台，转而采用阿里的大数据计算服务。我做了ODPS项目，把路口的离线数据分析转移到了云端。之后我开始做后端，后端有好多事情，除了写API之外，还有后台管理，反垃圾，抓取，性能优化等事情。</p>
<p>10月之后，公司决定做一款新产品「熊猫海淘」，我又回来做android了，开发了1.0版，用了很多之前没用的技术。 </p>
<p>11月开发完之后我决定辞职，对我来说这是职业上的选择，但却很舍不得路口的人。好多人都一起吃过饭，没吃饭的也大多有过沟通。都说继续保持联系，但离职实实在在的就是一场告别。我问过之前离职的同事，他们都慢慢地减少了和路口的联系；从我个人经验上来说，每次毕业之后，最好的朋友也联系得非常少了。是的，路口最好的朋友也会慢慢走远。</p>
<p>今天去办理离职手续，跟主管和高层有非常友好的沟通，中午跟路口的好朋友一起喝咖啡，听了技术部的分享，晚上跟路口的朋友一起吃饭、看电影。这个让我发恼骚想离开的公司，在离别之际竟然给我如此多的感动。</p>
<p>再见路口！</p>
<p>– end –</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天办完离职手续，退出路口的微信群和QQ群，我正式离开了我的第一家公司。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://quqiuzhu.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>React Native</title>
    <link href="http://quqiuzhu.com/2016/react-native/"/>
    <id>http://quqiuzhu.com/2016/react-native/</id>
    <published>2016-10-29T18:09:53.000Z</published>
    <updated>2016-11-03T09:32:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司开发了一款叫「熊猫洋货」的APP，学习了一些 React Native 的知识，在这里进行一下总结</p>
<ol>
<li>环境搭建</li>
<li>React Native 页面</li>
<li>原生应用集成</li>
</ol>
<a id="more"></a>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>因为我是一名使用 Mac 的 Android 开发者，所以 Mac下的 Android 环境、HomeBrew 包管理器都已具备。只需要装 Node 和 React Native 命令行工具即可。 安装 Node 主要是希望使用其包管理工具 npm 。安装命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install node</div><div class="line">npm install -g react-native-cli</div></pre></td></tr></table></figure>
<p>在此提醒一下，请注意 HomeBrew 的提示，如果有命令没有安装成功，按照 HomeBrew 的提示操作。</p>
<h2 id="React-Native-页面"><a href="#React-Native-页面" class="headerlink" title="React Native 页面"></a>React Native 页面</h2><p>React 推荐使用 JSX 语法来写页面，因为其可读性较强。因为 JSX 是一种类 XML 的语法，对于习惯于使用布局文件的 Android 开发者来说并不陌生。 使用 React Component 来开发我们的应用界面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Greeting extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Text&gt;Hello world!&lt;/Text&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 XML 能给 Componet 传递属性，Component 内部能够通过 <code>this.props</code> 获取到该属性。比如从上面的例子改为从外部接受属性参数的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Greeting extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Text&gt;this.props.words&lt;/Text&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class App extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Greeting words=&apos;Hello world!&apos;/&gt;</div><div class="line">      &lt;Greeting words=&apos;你好!&apos;/&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在一个 Component 里面，props 的值是不会变的，如果在 Component 的生命周期内需要改变样式，需要使用 state。 下面该组件一会显示 Hello world!， 一会又显示 你好!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Greeting extends Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line">    this.state = &#123; engish: true &#125;;</div><div class="line"></div><div class="line">    setInterval(() =&gt; &#123;</div><div class="line">      this.setState(&#123; engish: !this.state.engish &#125;);</div><div class="line">    &#125;, 1000);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Text&gt;this.state.english ? &apos;Hello world!&apos; : &apos;你好!&apos; &lt;/Text&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Component 能通过 StyleSheet 指定样式, flexbox 布局进行定位元素位置。 上述页面使用 StyleSheet </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Greeting extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Text style=&#123;styles.bigblue&#125;&gt;Hello world!&lt;/Text&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  bigblue: &#123;</div><div class="line">    color: &apos;blue&apos;,</div><div class="line">    fontWeight: &apos;bold&apos;,</div><div class="line">    fontSize: 30,</div><div class="line">    flex: 1,</div><div class="line">    alignSelf: &apos;center&apos;</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="原生应用集成"><a href="#原生应用集成" class="headerlink" title="原生应用集成"></a>原生应用集成</h2><p>在 Application 中加入下列代码，并将 React 写成的页面打成 bundle 放到 src/assets 下, 并命名为 index.android.js。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123;</div><div class="line">   @Override</div><div class="line">   public boolean getUseDeveloperSupport() &#123;</div><div class="line">       return false;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   public List&lt;ReactPackage&gt; getPackages() &#123;</div><div class="line">       return Arrays.&lt;ReactPackage&gt;asList(</div><div class="line">               new MainReactPackage(),</div><div class="line">               new YourReactPackage()</div><div class="line">       );</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">@Override</div><div class="line">public ReactNativeHost getReactNativeHost() &#123;</div><div class="line">   return mReactNativeHost;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在需要使用 React 的页面使用 ReactRootView 代替，并在该页面维持 ReactInstanceManager 的状态。使用下面的就能展示 React 写的页面了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mReactRootView.startReactApplication(reactInstancemanager, moduleName, bundle);</div></pre></td></tr></table></figure>
<p>reactInstancemanager 为 Application 中维护的同一个 reactInstancemanager 可以通过 getReactNativeHost.getReactInstanceManager() 获取。</p>
<p>moduleName 为当前页面的模块名</p>
<p>bundle 为 Native 传给 React 的参数</p>
<h3 id="React-如何调用-Native-方法"><a href="#React-如何调用-Native-方法" class="headerlink" title="React 如何调用 Native 方法"></a>React 如何调用 Native 方法</h3><p>可以在 ReactPackage 中返回给 React 一些 Native 实现的 module 实例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class YourReactPackage implements ReactPackage &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;Class&lt;? extends JavaScriptModule&gt;&gt; createJSModules() &#123;</div><div class="line">        return Collections.emptyList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;ViewManager&gt; createViewManagers(</div><div class="line">    		ReactApplicationContext reactContext) &#123;</div><div class="line">        return Collections.emptyList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public List&lt;NativeModule&gt; createNativeModules(</div><div class="line">            ReactApplicationContext reactContext) &#123;</div><div class="line">        List&lt;NativeModule&gt; modules = new ArrayList&lt;&gt;();</div><div class="line">        modules.add(new YourModule(reactContext));</div><div class="line">        return modules;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class YourModule extends ReactContextBaseJavaModule &#123;</div><div class="line"></div><div class="line">    public YourModule(ReactApplicationContext reactContext) &#123;</div><div class="line">        super(reactContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public YourModule(ReactApplicationContext reactContext, </div><div class="line">    							Context context) &#123;</div><div class="line">        super(reactContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @ReactMethod</div><div class="line">    public void event(String name)&#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后在 React 中可以通过 <code>NativeModules.YourModule</code> 访问到 Native 方法，比如上面实现的 event 方法。</p>
<h3 id="Native-如何调用-React-方法"><a href="#Native-如何调用-React-方法" class="headerlink" title="Native 如何调用 React 方法"></a>Native 如何调用 React 方法</h3><p>Native 主动与 React 沟通的方式，不是调用 React 方法，而是用事件通知的方式。首先看 Native 如何发通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void sendReactEvent(String eventName， WriteableMap params) &#123;</div><div class="line">   reactInstanceManager.getCurrentReactContext()</div><div class="line">   		.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)</div><div class="line">			.emit(eventName, params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Reac 方面，使用下面的方法监听 Native 发来的事件并作出反应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DeviceEventEmitter.addListener(eventName, (params) =&gt; &#123;</div><div class="line">	// Do Something</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>– end –</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司开发了一款叫「熊猫洋货」的APP，学习了一些 React Native 的知识，在这里进行一下总结&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;环境搭建&lt;/li&gt;
&lt;li&gt;React Native 页面&lt;/li&gt;
&lt;li&gt;原生应用集成&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="android" scheme="http://quqiuzhu.com/categories/android/"/>
    
    
      <category term="android" scheme="http://quqiuzhu.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Dagger 2 学习笔记</title>
    <link href="http://quqiuzhu.com/2016/dagger2/"/>
    <id>http://quqiuzhu.com/2016/dagger2/</id>
    <published>2016-10-09T00:31:11.000Z</published>
    <updated>2016-10-29T18:26:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>国庆假期学习了 <a href="https://github.com/google/dagger" target="_blank" rel="external">Dagger 2</a>, 在这里进行一些总结。 Dagger 2 是一个由 Google 工程师开发的依赖注入库，该项目 fork 自在 Square 工作的前 Google 工程师开发的 <a href="https://github.com/square/dagger" target="_blank" rel="external">Dagger 1</a>。</p>
<p>如果你想了解 Dagger 2 的基本概念和使用方式，推荐看 Codepath 的这篇文章 <a href="https://github.com/codepath/android_guides/wiki/Dependency-Injection-with-Dagger-2" target="_blank" rel="external">Dependency Injection with Dagger 2</a>。Dagger 2 通过注解 <code>@Module</code> 和 <code>@Provide</code> 标注提供依赖的类和方法, 通过 <code>@Inject</code> 标注请求依赖的实例, 通过 <code>@Component</code> 将两者连接起来, 而且提供了其他的一些 Feature。看完这些之后，你可能会有两个问题</p>
<ol>
<li>为什么要重新开发 Dagger 2, Dagger 1 哪里不好？</li>
<li>我现在知道怎么用了, 但是它是怎么实现的？</li>
</ol>
<p>第一个问题，在 Google 开发者大会上，Dagger 2 的开发者的演讲 <a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" target="_blank" rel="external">DAGGER 2 - A New Type of dependency injection</a> 中，不仅讲了 Dagger 1的优缺点，还讲了依赖注入如何从 Spring -&gt; Guice -&gt; Dagger 1 -&gt; Dagger 2。 Spring 主要的缺点是繁琐, 那段替代复杂的依赖注入的 XML 和原来的 Java 代码一样丑陋；Guice 的缺点是图错误在运行时才能发现，并且开发者难以调试；Dagger 1 的缺点是，生成的代码丑陋，出错难以调试，并且运行时开销不可忽视；Dagger 2在 Dagger 1 的基础上，解决了性能问题，并且生成的代码更加优雅。</p>
<p>第二个问题，其实在上面提到的 <a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" target="_blank" rel="external">DAGGER 2 - A New Type of dependency injection</a> 的演讲中，Dagger 2 的开发者已经解释了他们是如何设计 Dagger 2 的。但他使用CoffeeMaker 来举例，而我对 CoffeeMaker 并不熟悉，因此每当看到 Heater 和 Pump 的时候就在想它到底是什么，也许我应该好好玩一下公司的咖啡机。相比之下，我更喜欢 <a href="http://jakewharton.com" target="_blank" rel="external">Jake Wharton</a>的演讲 <a href="https://www.youtube.com/watch?v=plK0zyRLIP8" target="_blank" rel="external">Jake Wharton’s Devoxx Dagger 2 Talk</a>。</p>
<a id="more"></a>
<h2 id="Dagger使用"><a href="#Dagger使用" class="headerlink" title="Dagger使用"></a>Dagger使用</h2><ul>
<li>时间安排2天, 包含玩一下 dagger 项目中的例子程序</li>
<li>annotation processors compile-time checks 在编译时检测, 所以运行时很高效</li>
<li>简化共享实例的访问</li>
<li>易于配置复杂依赖</li>
<li>更容易的单元测试和集成测试</li>
<li>限定实例, 易于管理实例的生成和销毁</li>
</ul>
<h3 id="Creating-Singletons"><a href="#Creating-Singletons" class="headerlink" title="Creating Singletons"></a>Creating Singletons</h3><ul>
<li>@Module Dagger 模块, Dagger 在此寻找可以构造某个对象的实例的方法</li>
<li>@Module 可以用来解决依赖关系, 定义所依赖的对象</li>
<li>@Provides 提供类的实例的构造方式</li>
<li>@Singleton 告诉 Dagger 编译器, 在某个周期内, 只能创建一次实例</li>
<li>@Provides 修饰的方法, 根据参数来实例化某个对象, 而实例提供者, 是某个 @Module 中的一个返回值与参数相同的方法(同样被 @Provides 修饰)</li>
<li>@Component(modules={AppModule.class, NetModule.class}) 注解组件, 参数注明提供注解的类, 需要为所有需要被注解的类, 写不同的 inject()方法, 如以下代码所示</li>
<li>Dagger 注解不能修饰父类, 其依赖强类型</li>
<li>@Component 修饰的接口, 最终会生成一个以 Dagger 开始的一个类, 比如以下代码生成 DaggerNetComponent 类</li>
<li>在 Application 中初始化相关 Component</li>
<li>在需要注入的类中, 使用已经实例化的 Component, 调用其 inject() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="meta">@Component</span>(modules=&#123;AppModule.class, NetModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetComponent</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity activity)</span></span>;</div><div class="line">   <span class="comment">// void inject(MyFragment fragment);</span></div><div class="line">   <span class="comment">// void inject(MyService service);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> NetComponent mNetComponent;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line"></div><div class="line">        <span class="comment">// Dagger%COMPONENT_NAME%</span></div><div class="line">        mNetComponent = DaggerNetComponent.builder()</div><div class="line">                <span class="comment">// list of modules that are part of this component need to be created here too</span></div><div class="line">                .appModule(<span class="keyword">new</span> AppModule(<span class="keyword">this</span>)) <span class="comment">// This also corresponds to the name of your module: %component_name%Module</span></div><div class="line">                .netModule(<span class="keyword">new</span> NetModule(<span class="string">"https://api.github.com"</span>))</div><div class="line">                .build();</div><div class="line"></div><div class="line">        <span class="comment">// If a Dagger 2 component does not have any constructor arguments for any of its modules,</span></div><div class="line">        <span class="comment">// then we can use .create() as a shortcut instead:</span></div><div class="line">        <span class="comment">//  mNetComponent = com.codepath.dagger.components.DaggerNetComponent.create();</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> NetComponent <span class="title">getNetComponent</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> mNetComponent;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">  <span class="meta">@Inject</span> OkHttpClient mOkHttpClient;</div><div class="line">  <span class="meta">@Inject</span> SharedPreferences sharedPreferences;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstance)</span> </span>&#123;</div><div class="line">        <span class="comment">// assign singleton instances to fields</span></div><div class="line">        <span class="comment">// We need to cast to `MyApp` in order to get the right method</span></div><div class="line">        ((MyApp) getApplication()).getNetComponent().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Qualified-types"><a href="#Qualified-types" class="headerlink" title="Qualified types"></a>Qualified types</h3><ul>
<li>@Provides 如果提供了返回一种类型的多种方法, 到到底选择哪一个呢, 就可以通过限定符来指定</li>
<li>通过 Dagger 提供的 @Qualifier 注解可以定义限定符, 就像定义 annotation 一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provides</span> <span class="meta">@Named</span>(<span class="string">"cached"</span>)</div><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="function">OkHttpClient <span class="title">provideOkHttpClient</span><span class="params">(Cache cache)</span> </span>&#123;</div><div class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">    client.setCache(cache);</div><div class="line">    <span class="keyword">return</span> client;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Provides</span> <span class="meta">@Named</span>(<span class="string">"non_cached"</span>) <span class="meta">@Singleton</span></div><div class="line"><span class="function">OkHttpClient <span class="title">provideOkHttpClient</span><span class="params">()</span> </span>&#123;</div><div class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">    <span class="keyword">return</span> client;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Inject</span> <span class="meta">@Named</span>(<span class="string">"cached"</span>) OkHttpClient client;</div><div class="line"><span class="meta">@Inject</span> <span class="meta">@Named</span>(<span class="string">"non_cached"</span>) OkHttpClient client2;</div><div class="line"></div><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DefaultPreferences &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h3><ul>
<li>Scopes 是用来管理各种 Component 的生命周期的, 或者说是管理其使用范围的</li>
<li>可以通过 Dagger 提供的注解 @Scope 来定制自己的 Scope, 但如何实现没有详细说明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scope</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(value=RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyActivityScope</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="dependent-components-or-subcomponents"><a href="#dependent-components-or-subcomponents" class="headerlink" title="dependent components or subcomponents"></a>dependent components or subcomponents</h3><ul>
<li>Component 并非一定要一直存在, 有些 Component 只存在于一个 Activity 的周期之内, 或者等到 User login 之后才能做事</li>
<li>dependent components 是父类指定可以注入的类, 子Component去按照指定的实现, 父类去掉 inject 函数, 由子类独立实现</li>
<li>两个 dependent components 不能享有同一个 Scope, 原因是因为 <a href="https://github.com/google/dagger/issues/107#issuecomment-71073298" title="循环依赖" target="_blank" rel="external">循环依赖</a> 还是什么, 暂时看不太懂, 先略过</li>
<li>虽然 Dagger 有能力创建 Scoped Component, 但需要开发者来实现与此 Scope 一致的行为, Dagger 并不清楚开发者是怎么实现的。 stackoverflow 上面有相关 <a href="http://stackoverflow.com/questions/28411352/what-determines-the-lifecycle-of-a-component-object-graph-in-dagger-2" title="讨论" target="_blank" rel="external">讨论</a>, 详细看完 Scope 之后再细看</li>
<li>一个 dependent components <a href="https://github.com/codepath/dagger2-example" title="dagger2-example" target="_blank" rel="external">例程</a></li>
<li>dependent components 继承, subcomponents 组合</li>
<li>看过 <a href="https://github.com/vinc3m1/nowdothis" title="nowdothis" target="_blank" rel="external">Dagger demo</a> 得出结论, Scope 就是个标识, 其规范在哪些范围使用, 范围是什么主要看 Component 是什么时候创建的, 比如有个 ImgurActivityComponent, 其初始化是在 ImgurUploadActivity 的 onCreate 方法内, 这些行为都遵守了 @PerImgurActivity 这个 Scope 的约定, 如果有人在另外的 Activity 中创建 ImgurActivityComponent, 使用其注入了某个类, 开发者可以实现, 但是这个 Scope 就被破坏了。</li>
<li>另外可以使用 @Inject 修饰 Constructor, 使其能够被用来注入, 但是什么时候使用 @Inject, 什么时候使用 @Provide 肯定有个优先级的。</li>
<li>Constructor Injection 的两种方式如下, @Inject 和 @Provide</li>
<li>Lazy injections</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// parent component</span></div><div class="line"><span class="meta">@Singleton</span></div><div class="line"><span class="meta">@Component</span>(modules=&#123;AppModule.class, NetModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetComponent</span> </span>&#123;</div><div class="line">    <span class="comment">// remove injection methods if downstream modules will perform injection</span></div><div class="line"></div><div class="line">    <span class="comment">// downstream components need these exposed</span></div><div class="line">    <span class="comment">// the method name does not matter, only the return type</span></div><div class="line">    <span class="function">Retrofit <span class="title">retrofit</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">OkHttpClient <span class="title">okHttpClient</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">SharedPreferences <span class="title">sharedPreferences</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Provides</span> <span class="function">MyThing <span class="title">provideMyThing</span><span class="params">(</span></span></div><div class="line">		SharedPreferences sp,</div><div class="line">		Context context) &#123;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MyThing(sp, context);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@PerApp</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThing</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SharedPRefs…</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Context ...</div><div class="line"></div><div class="line">	<span class="meta">@Inject</span> <span class="function"><span class="keyword">public</span> <span class="title">MyThing</span><span class="params">(</span></span></div><div class="line">SharedPreferences sp,</div><div class="line">		Context context) &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inject</span> Lazy&lt;SharedPreferences&gt; mLazySharedPrefs;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onSaveBtnClicked</span><span class="params">()</span> </span>&#123;</div><div class="line">    mLazySharedPrefs.get()</div><div class="line">                .edit().putString(<span class="string">"status"</span>, <span class="string">"lazy..."</span>)</div><div class="line">                .apply();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://docs.google.com/presentation/d/1bkctcKjbLlpiI0Nj9v0QpCcNIiZBhVsJsJp1dgU5n98/" title="Dagger 2 in Android" target="_blank" rel="external">Vince Mi’s Codepath Meetup Dagger 2 Slides</a></li>
<li><a href="https://speakerdeck.com/jakewharton/dependency-injection-with-dagger-2-devoxx-2014" title="Dependency Injection with Dagger 2 (Devoxx 2014)" target="_blank" rel="external">Jake Wharton’s Devoxx Dagger 2 Slides</a> Tweeter API 设计</li>
<li><a href="https://www.youtube.com/watch?v=plK0zyRLIP8" title="Jake Wharton&#39;s Devoxx Dagger 2 Talk" target="_blank" rel="external">Jake Wharton’s Devoxx Dagger 2 Talk</a> 50分钟</li>
<li><a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" title="Dagger 2 Google Developers Talk" target="_blank" rel="external">Dagger 2 Google Developers Talk</a> 40分钟</li>
<li><a href="https://blog.gouline.net/dagger-2-even-sharper-less-square-b52101863542#.flwjtyxlk" title="Dagger 2: Even sharper, less square" target="_blank" rel="external">Dagger 2: Even sharper, less square</a> 比较 Dagger 1, 指出3缺点</li>
<li><a href="https://www.youtube.com/watch?v=0XHx9jtxIxU" target="_blank" rel="external">Architecting Android Applications with Dagger</a> dagger 与 android 构架</li>
</ul>
<h2 id="依赖注入-注解与APT"><a href="#依赖注入-注解与APT" class="headerlink" title="依赖注入, 注解与APT"></a>依赖注入, 注解与APT</h2><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul>
<li>DI, IoC <a href="http://www.martinfowler.com/articles/injection.html" title="Inversion of Control Containers and the Dependency Injection pattern" target="_blank" rel="external">经典文章</a> 对比 <a href="http://www.cnblogs.com/gaochundong/archive/2013/04/12/service_locator_pattern.html" title="Service Locator 模式" target="_blank" rel="external">Service Locator 模式</a></li>
<li>三种DI方式<ol>
<li>Constructor Injection 是根据某种类型, 调用其一个默认实现的子类, Container 会提供一个配置接口, 并且为一个类返回一个默认实现, 当然主要是通过调用其构造方法, 并且可以配置传参</li>
<li>Setter Injection 是在需要被注入的类中有一个 Setter 方法, 用来设置相关依赖, 在此框架会返回一个默认的实现作为参数, Spring 通过 xml 文件配置类的某一个具体实现</li>
<li>Interface Injection 通过声明接口，框架给出默认实现，并且给出关联相关代码，而实现依赖注入, 但这里的例子没有使用注解, 而是直接使用了 Java Code</li>
</ol>
</li>
<li>Service Locator 与 Dependency Injection 比较，两者都是为了去耦合，依赖注入难以理解和调试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span>...</span></div><div class="line">  <span class="title">public</span> <span class="title">MovieLister</span>(<span class="title">MovieFinder</span> <span class="title">finder</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.finder = finder;       </div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColonMovieFinder</span>...</span></div><div class="line">  <span class="title">public</span> <span class="title">ColonMovieFinder</span>(<span class="title">String</span> <span class="title">filename</span>) &#123;</div><div class="line">      <span class="keyword">this</span>.filename = filename;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> MutablePicoContainer <span class="title">configureContainer</span><span class="params">()</span> </span>&#123;</div><div class="line">    MutablePicoContainer pico = <span class="keyword">new</span> DefaultPicoContainer();</div><div class="line">    Parameter[] finderParams =  &#123;<span class="keyword">new</span> ConstantParameter(<span class="string">"movies1.txt"</span>)&#125;;</div><div class="line">    pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);</div><div class="line">    pico.registerComponentImplementation(MovieLister.class);</div><div class="line">    <span class="keyword">return</span> pico;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWithPico</span><span class="params">()</span> </span>&#123;</div><div class="line">    MutablePicoContainer pico = configureContainer();</div><div class="line">    MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);</div><div class="line">    Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</div><div class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class MovieLister...</div><div class="line">  private MovieFinder finder;</div><div class="line">  public void setFinder(MovieFinder finder) &#123;</div><div class="line">    this.finder = finder;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">class ColonMovieFinder...</div><div class="line">  public void setFilename(String filename) &#123;</div><div class="line">      this.filename = filename;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&lt;beans&gt;</div><div class="line">    &lt;bean id="MovieLister" class="spring.MovieLister"&gt;</div><div class="line">        &lt;property name="finder"&gt;</div><div class="line">            &lt;ref local="MovieFinder"/&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">    &lt;bean id="MovieFinder" class="spring.ColonMovieFinder"&gt;</div><div class="line">        &lt;property name="filename"&gt;</div><div class="line">            &lt;value&gt;movies1.txt&lt;/value&gt;</div><div class="line">        &lt;/property&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div><div class="line"></div><div class="line">public void testWithSpring() throws Exception &#123;</div><div class="line">    ApplicationContext ctx = new FileSystemXmlApplicationContext("spring.xml");</div><div class="line">    MovieLister lister = (MovieLister) ctx.getBean("MovieLister");</div><div class="line">    Movie[] movies = lister.moviesDirectedBy("Sergio Leone");</div><div class="line">    assertEquals("Once Upon a Time in the West", movies[0].getTitle());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InjectFinder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieLister</span> <span class="keyword">implements</span> <span class="title">InjectFinder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectFinder</span><span class="params">(MovieFinder finder)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.finder = finder;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Injector</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColonMovieFinder</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span>, <span class="title">Injector</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectFilename</span><span class="params">(String filename)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.filename = filename;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</div><div class="line">    ((InjectFinder) target).injectFinder(<span class="keyword">this</span>);        </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Container container;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureContainer</span><span class="params">()</span> </span>&#123;</div><div class="line">   container = <span class="keyword">new</span> Container();</div><div class="line">   registerComponents();</div><div class="line">   registerInjectors();</div><div class="line">   container.start();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">()</span> </span>&#123;</div><div class="line">    container.registerComponent(<span class="string">"MovieLister"</span>, MovieLister.class);</div><div class="line">    container.registerComponent(<span class="string">"MovieFinder"</span>, ColonMovieFinder.class);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerInjectors</span><span class="params">()</span> </span>&#123;</div><div class="line">    container.registerInjector(InjectFinder.class, container.lookup(<span class="string">"MovieFinder"</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIface</span><span class="params">()</span> </span>&#123;</div><div class="line">    configureContainer();</div><div class="line">    MovieLister lister = (MovieLister)container.lookup(<span class="string">"MovieLister"</span>);</div><div class="line">    Movie[] movies = lister.moviesDirectedBy(<span class="string">"Sergio Leone"</span>);</div><div class="line">    assertEquals(<span class="string">"Once Upon a Time in the West"</span>, movies[<span class="number">0</span>].getTitle());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先, 这个 InjectFinder 是被注入的那个类需要实现的接口, 名字有点问题, 难以理解。 需要使用 finder 的类实现 InjectFinder 接口, 会自动注入相关类。 registerComponent 是注册类, 可以通过 lookup 获取其实例。</p>
<p>registerInjector 表达一种关系, 谁注入谁的关系, 上面经过 registerInjectors 之后 InjectFinder 与 ColonMovieFinder 就关联起来了, ColonMovieFinder 会注入到 InjectFinder 里面去。</p>
<h3 id="JSR-330"><a href="#JSR-330" class="headerlink" title="JSR 330"></a>JSR 330</h3><ul>
<li>JSR 330 - 2009 年发布, Spring 2.5 后支持, 依赖注入的标准</li>
<li>@Inject 注入顺序为构造器，字段，最后是方法。超类的字段、方法将优先于子类的字段、方法被注入</li>
<li>@Qualifier 给定的类型 T 与可选的限定器，注入器必须能够注入用户指定的类, 循环依赖, Provider<t> 然后显式调用其 get 方法。</t></li>
<li>Provider<t> 一般由注入器实现, 可返回多个实例, 而且打破循环依赖的问题</t></li>
<li>@Named 是默认实现的一个限定器, 参数是一个 String 类型, 大多数时候够用</li>
<li>@Scope 用于标识作用域注解, 重新定义一个新 Scope, 不应该含有属性</li>
<li>@Singleton 是一个Scope 实现, 对象只创建一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@java</span>.lang.annotation.Documented</div><div class="line"><span class="meta">@java</span>.lang.annotation.Retention(RUNTIME)</div><div class="line"><span class="meta">@javax</span>.inject.Scope</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestScoped &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="注解及APT"><a href="#注解及APT" class="headerlink" title="注解及APT"></a>注解及APT</h3><ul>
<li>Dagger中, 注解的作用是在编译期间帮助生成代码, 运行时, 与注解已无关系</li>
<li><a href="https://github.com/square/javapoet" title="javapoet" target="_blank" rel="external">javapoet</a>及其<a href="http://www.jianshu.com/p/95f12f72f69a" title="javapoet——让你从重复无聊的代码中解放出来" target="_blank" rel="external">详解</a> 用来生成 java 源文件的库</li>
<li>内置注解 &amp; 元注解 &amp; 实现注解 &amp; 注解处理器</li>
<li>注解是一种语法, 怎么处理注解才是最重要的, 我们可以编写一个类实现注解处理, 也可以使用APT</li>
<li>一个编译时注解处理的 <a href="https://github.com/zjutkz/Knight" title="knight" target="_blank" rel="external">简单实例</a>及其<a href="http://zjutkz.net/2016/04/07/%E4%B8%87%E8%83%BD%E7%9A%84APT%EF%BC%81%E7%BC%96%E8%AF%91%E6%97%B6%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A6%99%E7%94%A8/" title="万能的APT！编译时注解的妙用" target="_blank" rel="external">详解</a></li>
<li><a href="http://blog.csdn.net/a1018875550/article/details/52166916" title="Android注解-编译时生成代码 (APT)" target="_blank" rel="external">APT</a> 及相关项目 <a href="https://github.com/a1018875550/ViewInject/tree/master" title="ViewInject" target="_blank" rel="external">ViewInject</a>, 完整用心地讲了具体实现</li>
<li>@AutoService 可以自动(为 Processor)生成配置信息</li>
<li>Android Studio 2.2 已经自带 annotationProcessor, 不再需要 APT, 即便不使用 Java 8</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内置注解</span></div><div class="line"><span class="comment">// 方法注解，表示此注解修饰的方法覆盖了父类或是接口的方法</span></div><div class="line"><span class="comment">// 如果不是这样，则输出警告</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"></div><div class="line"><span class="comment">// 对于此注解所修饰的对象（类、域、方法等）</span></div><div class="line"><span class="comment">// 当你使用了它们时编译器将输出“已废弃”警告</span></div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"></div><div class="line"><span class="comment">// 关闭警告，通过给此注解的元素赋值</span></div><div class="line"><span class="comment">// 可以关闭特定警告</span></div><div class="line"><span class="meta">@SuppressWarnings</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 元注解</span></div><div class="line"><span class="comment">// 定义注解所能作用的目标，说明该注解能作用于何种对象（类、方法、域……之类）。</span></div><div class="line"><span class="meta">@Target</span></div><div class="line"></div><div class="line"><span class="comment">// 定义注解保存级别</span></div><div class="line"><span class="comment">// 1.源代码注解，被编译器丢弃</span></div><div class="line"><span class="comment">// 2.类注解，class文件中可用，被VM丢弃</span></div><div class="line"><span class="comment">// 3.运行时可用，搭配反射</span></div><div class="line"><span class="meta">@Retention</span></div><div class="line"></div><div class="line"><span class="comment">// 标志将此注解包含至javadoc中</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"></div><div class="line"><span class="comment">// 说明假如此注解是类注解而且你在父类中使用此注解，那么子类将会继承此注解</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 实现注解</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</div><div class="line">    ElementType[] value() <span class="keyword">default</span> &#123;ElementType.ANNOTATION_TYPE&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Dagger-2-源码"><a href="#Dagger-2-源码" class="headerlink" title="Dagger 2 源码"></a>Dagger 2 源码</h2><ul>
<li>dagger 并不是一个 android project, 而是一个 java project, 构建工具为 maven</li>
<li>maven 构建工具, 它如何构建, 如何集成, 如何打包 之后再说, 但其所有注解打概念得搞清楚</li>
<li>源码 中一大部分是新功能, 新概念, 比如 MultiBindings 支持Set 和 Map的多绑定实现插件式开发; Producer 用来支持异步编程模型, 还是先看文档熟悉一下比较好</li>
</ul>
<h3 id="新概念"><a href="#新概念" class="headerlink" title="新概念"></a>新概念</h3><ul>
<li>MultiBindings 就是把一些值组成一个集合, 有 set 和 map, @IntoSet 和 @StringKey 等等, 用于实现插件式构架, 稍显复杂</li>
<li>@ProducerModule, @Produces, @ProductionComponent 是提供异步依赖注入的注解, 类似注解 @Module, @Provides, @Component</li>
<li>@Produces 返回一个 ListenableFuture<t>, 如果其中 T 被依赖, 并且也被 @Produces 修饰, 可以通过注解 @Production 修饰 Executor 来指定</t></li>
<li>错误处理, 被依赖的 T, 就是 Produced<t>, 如果需要做错误处理, 则在此完成, MultiBindings 和 Lazy execution 同样支持</t></li>
<li>返回 Scope 和相应的 Component 一致  @ProductionScope</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ProducerModule</span>(includes = UserModule.class)</div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserResponseModule</span> </span>&#123;</div><div class="line">  <span class="meta">@Produces</span></div><div class="line">  <span class="function"><span class="keyword">static</span> ListenableFuture&lt;UserData&gt; <span class="title">lookUpUserData</span><span class="params">(</span></span></div><div class="line">      User user, UserDataStub stub) &#123;</div><div class="line">    <span class="keyword">return</span> stub.lookUpData(user);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Produces</span></div><div class="line">  <span class="function"><span class="keyword">static</span> Html <span class="title">renderHtml</span><span class="params">(UserData data, UserHtmlTemplate template)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> template.render(data);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorModule</span> </span>&#123;</div><div class="line">  <span class="meta">@Provides</span></div><div class="line">  <span class="meta">@Production</span></div><div class="line">  <span class="function"><span class="keyword">static</span> Executor <span class="title">executor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Executors.newCachedThreadPool();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Produces</span></div><div class="line"><span class="function"><span class="keyword">static</span> Html <span class="title">renderHtml</span><span class="params">(</span></span></div><div class="line">    Produced&lt;UserData&gt; data,</div><div class="line">    UserHtmlTemplate template,</div><div class="line">    ErrorHtmlTemplate errorTemplate) &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> template.render(data.get());</div><div class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">    <span class="keyword">return</span> errorTemplate.render(<span class="string">"user data failed"</span>, e.getCause());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ComponentProcessor"><a href="#ComponentProcessor" class="headerlink" title="ComponentProcessor"></a>ComponentProcessor</h3><ul>
<li>getSupportedOptions, initSteps 和 postRound 来自于 BasicAnnotationProcessor</li>
<li><a href="https://github.com/google/auto" title="Auto" target="_blank" rel="external">google auto</a>, 这个项目是用来帮助自动生成代码的</li>
<li><a href="https://github.com/google/guava" title="Google Core Libraries for Java 6+" target="_blank" rel="external">google guava</a> 是 Google 开源的 Java 库, 在Java标准库上面的一些封装, 让 java 更加优雅, <a href="https://github.com/google/guava/wiki" title="Guava User Guide" target="_blank" rel="external">guava guide</a></li>
<li>BasicAnnotationProcessor 中接口 ProcessingStep, ElementName</li>
</ul>
<h4 id="BasicAnnotationProcessor-ProcessingStep"><a href="#BasicAnnotationProcessor-ProcessingStep" class="headerlink" title="BasicAnnotationProcessor.ProcessingStep"></a>BasicAnnotationProcessor.ProcessingStep</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理阶段, 每个处理阶段可以处理一些注解的逻辑</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProcessingStep</span> </span>&#123;</div><div class="line">    <span class="comment">// 返回该阶段需要处理的注解类型</span></div><div class="line">    Set&lt;? extends Class&lt;? extends Annotation&gt;&gt; annotations();</div><div class="line"></div><div class="line">    <span class="comment">// 处理注解和被注解的元素, 是 SetMultimap 类型, 说明可以处理多个注解,</span></div><div class="line">    <span class="comment">// 同时每个注解可能注释了多个不同的元素</span></div><div class="line">    <span class="function">Set&lt;Element&gt; <span class="title">process</span><span class="params">(SetMultimap&lt;Class&lt;? extends Annotation&gt;, Element&gt; var1)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="BasicAnnotationProcessor-ElementName"><a href="#BasicAnnotationProcessor-ElementName" class="headerlink" title="BasicAnnotationProcessor.ElementName"></a>BasicAnnotationProcessor.ElementName</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该类主要用来存放节点名称, 并且区分包节点和类型节点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ElementName</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BasicAnnotationProcessor.ElementName.Kind kind;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">// ... 其中一些方法简化, 是一些构造方法和一些比较相关的方法</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> Kind &#123;</div><div class="line">        PACKAGE_NAME,</div><div class="line">        TYPE_NAME;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="BasicAnnotationProcessor-5个变量"><a href="#BasicAnnotationProcessor-5个变量" class="headerlink" title="BasicAnnotationProcessor 5个变量"></a>BasicAnnotationProcessor 5个变量</h4><ul>
<li>deferredElementNames 未处理的元素</li>
<li>elementsDeferredBySteps 未处理的元素(按照 ProcessingStep 区分)</li>
<li>processorName 该 processor 的名称</li>
<li>elements 所有元素</li>
<li>messager 用于编译过程中报告错误</li>
<li>steps 所有处理步骤(ProcessingStep)</li>
</ul>
<h4 id="RoundEnvironment"><a href="#RoundEnvironment" class="headerlink" title="RoundEnvironment"></a>RoundEnvironment</h4><ul>
<li>这个注释处理是一轮一轮进行的, RoundEnvironment 代表这一轮的处理环境</li>
<li>processingOver 表示上一轮处理完成, errorRaised 表示前面有错误发生</li>
<li>getRootElements 上一轮处理的根元素</li>
<li>getElementsAnnotatedWith 获取被注解的元素, 有两个重载的方法</li>
</ul>
<h4 id="BasicAnnotationProcessor-处理流程"><a href="#BasicAnnotationProcessor-处理流程" class="headerlink" title="BasicAnnotationProcessor 处理流程"></a>BasicAnnotationProcessor 处理流程</h4><ul>
<li>init 初始化, 暴露 initSteps 给子类, 让其返回其想要实现的 ProcessingStep</li>
<li>process 函数先检查了一些状态, 然后通过 deferredElementNames 得到了 deferredElements, 但奇怪的是, deferredElementNames 和 elements 怎么初始化</li>
<li>只在 validElements 方法中看到 deferredElementNames 被更改, 说明 deferredElements 来自处理结束, 最可能的是上一步留下的, 未处理的 Elements</li>
<li>validElements 做了什么呢?</li>
<li>下载了代码之后, 看完了头部的注释, 解释了如何处理一个 ProcessingStep, 然后哪些 element 需要延迟处理, 整个逻辑就清晰了。</li>
<li>BasicAnnotationProcessor 中, 注解处理器会多次调用 process 方法吗？ 如果未处理完成, 应该如何表征, 这是个问题, 后面慢慢弄明白</li>
</ul>
<p>– end –</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国庆假期学习了 &lt;a href=&quot;https://github.com/google/dagger&quot;&gt;Dagger 2&lt;/a&gt;, 在这里进行一些总结。 Dagger 2 是一个由 Google 工程师开发的依赖注入库，该项目 fork 自在 Square 工作的前 Google 工程师开发的 &lt;a href=&quot;https://github.com/square/dagger&quot;&gt;Dagger 1&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果你想了解 Dagger 2 的基本概念和使用方式，推荐看 Codepath 的这篇文章 &lt;a href=&quot;https://github.com/codepath/android_guides/wiki/Dependency-Injection-with-Dagger-2&quot;&gt;Dependency Injection with Dagger 2&lt;/a&gt;。Dagger 2 通过注解 &lt;code&gt;@Module&lt;/code&gt; 和 &lt;code&gt;@Provide&lt;/code&gt; 标注提供依赖的类和方法, 通过 &lt;code&gt;@Inject&lt;/code&gt; 标注请求依赖的实例, 通过 &lt;code&gt;@Component&lt;/code&gt; 将两者连接起来, 而且提供了其他的一些 Feature。看完这些之后，你可能会有两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么要重新开发 Dagger 2, Dagger 1 哪里不好？&lt;/li&gt;
&lt;li&gt;我现在知道怎么用了, 但是它是怎么实现的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个问题，在 Google 开发者大会上，Dagger 2 的开发者的演讲 &lt;a href=&quot;https://www.youtube.com/watch?v=oK_XtfXPkqw&quot;&gt;DAGGER 2 - A New Type of dependency injection&lt;/a&gt; 中，不仅讲了 Dagger 1的优缺点，还讲了依赖注入如何从 Spring -&amp;gt; Guice -&amp;gt; Dagger 1 -&amp;gt; Dagger 2。 Spring 主要的缺点是繁琐, 那段替代复杂的依赖注入的 XML 和原来的 Java 代码一样丑陋；Guice 的缺点是图错误在运行时才能发现，并且开发者难以调试；Dagger 1 的缺点是，生成的代码丑陋，出错难以调试，并且运行时开销不可忽视；Dagger 2在 Dagger 1 的基础上，解决了性能问题，并且生成的代码更加优雅。&lt;/p&gt;
&lt;p&gt;第二个问题，其实在上面提到的 &lt;a href=&quot;https://www.youtube.com/watch?v=oK_XtfXPkqw&quot;&gt;DAGGER 2 - A New Type of dependency injection&lt;/a&gt; 的演讲中，Dagger 2 的开发者已经解释了他们是如何设计 Dagger 2 的。但他使用CoffeeMaker 来举例，而我对 CoffeeMaker 并不熟悉，因此每当看到 Heater 和 Pump 的时候就在想它到底是什么，也许我应该好好玩一下公司的咖啡机。相比之下，我更喜欢 &lt;a href=&quot;http://jakewharton.com&quot;&gt;Jake Wharton&lt;/a&gt;的演讲 &lt;a href=&quot;https://www.youtube.com/watch?v=plK0zyRLIP8&quot;&gt;Jake Wharton’s Devoxx Dagger 2 Talk&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://quqiuzhu.com/categories/android/"/>
    
    
      <category term="android" scheme="http://quqiuzhu.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>2016 年的 JavaScript</title>
    <link href="http://quqiuzhu.com/2016/js-2016/"/>
    <id>http://quqiuzhu.com/2016/js-2016/</id>
    <published>2016-10-04T23:34:02.000Z</published>
    <updated>2016-10-29T18:18:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上看了一篇文章, 名字叫<a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f" title="How it feels to learn JavaScript in 2016" target="_blank" rel="external">How it feels to learn JavaScript in 2016</a> 。模拟一个新加入项目, 了解过一点ES5和前端开发, 但对 2016 年 JavaScript 变化一无所知的人与作者的对话, 介绍了 2016 年 JavaScript 与前端开发的最新情况。<br><a id="more"></a></p>
<p>观整体趋势, JS 和 React 必将成为移动开发和Web前端开发的主流, 如果通过 NodeJs 等框架来写后端, 单单写 JS 就可以成为全栈工程师。 JS 后劲足, 早在 2014 年, 我就听说有人在嵌入式开发中引入了 JS, 因此 JS 变得越来越重要。以下是我看完之后记下的一些点</p>
<ul>
<li>React &amp; React DOM 使用 JSX 语法来写组件, 不再直接使用 HTML</li>
<li>Babel 是将 ES6 或 ES2016+ 语法的 JS 转换为旧版本的 JS, 以便浏览器兼容的库</li>
<li>ES2016+ 在 ES6 的基础上增加了 async, await 等特性</li>
<li>AMD, CommonJS 是 JS 模块化编程的规范, 重点看 <a href="http://justineo.github.io/singles/writing-modular-js/" title="使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript" target="_blank" rel="external">这篇文章</a></li>
<li>npm 是一个共有的模块库(包管理), Browserify 将所有依赖的模块打包在一起使用</li>
<li>Webpack 搞定 JS 模块合并, Babel 等所有事情</li>
<li>HTTP/2 推荐使用多个 HTTP 请求而不是一个, SystemJS 可以将各模块中用到的 JS 分开, 一次请求就会小很多</li>
<li>Typescript 将 JavaScript 用作一种强类型语言, Flow 是一种使用 OCaml 写的检查器</li>
<li>Ramnda 使用 JS 函数式编程, David Chambers, Erik Meijer 等人</li>
<li>Fetch 或者 Fetch polyfill 使用 Promises 做异步编程</li>
<li>需要响应状态变化, 有 <a href="https://github.com/reactjs/redux" title="Redux" target="_blank" rel="external">Redux</a>, Flux, Flummox 等等</li>
</ul>
<p>一个简单的总结就是</p>
<blockquote>
<p>Code everything in Typescript. All modules that use Fetch compile them to target ES6, transpile them with Babel on a stage-3 preset, and load them with SystemJS. If you don’t have Fetch, polyfill it, or use Bluebird, Request or Axios, and handle all your promises with await</p>
</blockquote>
<p>一个项目里面包含了这些的使用, 就是 <a href="https://github.com/vuejs/vue-hackernews-2.0" title="vue-hackernews-2.0" target="_blank" rel="external">vue-hackernews-2.0</a></p>
<p>– end –</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天早上看了一篇文章, 名字叫&lt;a href=&quot;https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f&quot; title=&quot;How it feels to learn JavaScript in 2016&quot;&gt;How it feels to learn JavaScript in 2016&lt;/a&gt; 。模拟一个新加入项目, 了解过一点ES5和前端开发, 但对 2016 年 JavaScript 变化一无所知的人与作者的对话, 介绍了 2016 年 JavaScript 与前端开发的最新情况。&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://quqiuzhu.com/categories/android/"/>
    
    
      <category term="android" scheme="http://quqiuzhu.com/tags/android/"/>
    
      <category term="js" scheme="http://quqiuzhu.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Requests 源代码浅析</title>
    <link href="http://quqiuzhu.com/2016/python-requests/"/>
    <id>http://quqiuzhu.com/2016/python-requests/</id>
    <published>2016-09-04T02:16:10.000Z</published>
    <updated>2016-09-06T00:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Requests是目前最流行的Python HTTP库，使用者众多，包括Amazon, Google, Twitter等大公司和美国国家安全局等政府机构。在<a href="https://github.com/kennethreitz/requests" title="Requests: HTTP for Humans" target="_blank" rel="external">github</a>上有2w多的star。Requests的接口简单，符合人的直觉而且功能强大。比如持久 Cookie 的会话, Keep-Alive &amp; 连接池,文件分块上传, 流下载, SSL 认证等。其大部分功能由其内置的<a href="https://github.com/shazow/urllib3" title="urllib3" target="_blank" rel="external">urllib3</a>库实现。所以Requests最关心的不是如何实现协议，而是如何设计接口，正如作者<a href="https://github.com/kennethreitz" title="kennethreitz" target="_blank" rel="external">github</a>自我介绍，「The only thing I really care about is interface design」。<br><a id="more"></a></p>
<h2 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h2><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>一个统一资源定位符被分为下面的六段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">http://user:passwd@httpbin.org:80/basic-auth/user/passwd?name=quqiuzhu#1</div><div class="line"></div><div class="line">&lt;scheme&gt;://&lt;netloc&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;fragment&gt;</div><div class="line"></div><div class="line">&lt;scheme&gt;    http</div><div class="line">&lt;netloc&gt;    user:passwd@httpbin.org:80</div><div class="line">&lt;path&gt;      basic-auth/user/passwd</div><div class="line">&lt;query&gt;     name=quqiuzhu</div><div class="line">&lt;fragment&gt;  1</div></pre></td></tr></table></figure>
<p>其中<code>&lt;params&gt;</code>叫做matrix parameters，<code>&lt;query&gt;</code>叫query parameters，<code>&lt;params&gt;</code>支持较少，关于这两种参数的讨论，请看<a href="http://stackoverflow.com/questions/2048121/url-matrix-parameters-vs-request-parameters" title="URL matrix parameters vs. request parameters" target="_blank" rel="external">stackoverflow</a>。</p>
<p><code>&lt;netloc&gt;</code> 可继续细分为<code>&lt;auth&gt;</code>, <code>&lt;host&gt;</code>, <code>&lt;port&gt;</code>, 一般情况下，没有<code>&lt;auth&gt;</code>部分，和<code>&lt;port&gt;</code>部分。因为在url中明文传递用户名密码和不安全，而且对外提供服务的网站一般都采用默认端口(HTTP:80, HTTPS:443)。</p>
<p><code>&lt;fragment&gt;</code> 通常用作一个网页的页内分段跳转。</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p><a href="https://github.com/astaxie/bat" title="bat" target="_blank" rel="external">bat</a>是一个类似cUrl的API测试工具，执行命令时，其能完整显示整个HTTP协议的传输过程，比如当我对<a href="http://httpbin.org/ip做一个GET请求时，其命令为" target="_blank" rel="external">http://httpbin.org/ip做一个GET请求时，其命令为</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ bat http://httpbin.org/ip</div></pre></td></tr></table></figure>
<p>其构造的请求(Request)如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /ip HTTP/1.1</div><div class="line">Host: httpbin.org</div><div class="line">Accept: application/json</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">User-Agent: bat/0.1.0</div></pre></td></tr></table></figure>
<p>第一行是请求行，分别是谓词(方法)、路径和协议版本; 其后跟着的是头部信息(Host、Accept、Accept-Encoding 和User-Agent); 如果是POST或者PUT等请求，还可能会有BODY部分。</p>
<p>回复(Response)的文本如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Server : nginx</div><div class="line">Date : Sun, 04 Sep 2016 11:59:35 GMT</div><div class="line">Content-Type : application/json</div><div class="line">Content-Length : 32</div><div class="line">Connection : keep-alive</div><div class="line">Access-Control-Allow-Origin : *</div><div class="line">Access-Control-Allow-Credentials : true</div><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;origin&quot;: &quot;111.0.186.217&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一行是回复行，分别为协议版本，状态码和状态描述; 其后是头部信息; 之后是空行(<code>\r\n</code>);再后面跟着的是BODY信息。</p>
<p>以上是一个HTTP请求的基本框架，是其他所有功能的基础。</p>
<h2 id="urllib3"><a href="#urllib3" class="headerlink" title="urllib3"></a>urllib3</h2><p>Requests大部分HTTP协议功能是urllib3实现的，一直看到最后，会发现urllib3最底层是调用了Python标准库的httplib(Python3 http.client)。它实现下面这些功能</p>
<ul>
<li>Connection pooling</li>
<li>File uploads with multipart encoding</li>
<li>Helpers for retrying requests and dealing with HTTP redirects</li>
<li>Support for gzip and deflate encoding</li>
<li>Proxy support for HTTP and SOCKS</li>
</ul>
<h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>urllib3 对外暴露的结构就两个，PoolManager 和 HTTPConnectionPool(HTTPSConnectionPool)。PoolManager管理了一堆的 ConnectionPool，每一个独立的(scheme, host, port)元祖使用同一个ConnectionPool, (scheme, host, port)是从请求的URL中解析出来的。</p>
<p>PoolManager使用自己实现的RecentlyUsedContainer容器来管理ConnectionPool，一旦<br>ConnectionPool超过限制，则逐出最远使用的ConnectionPool。ConnectionPool内部使用LifoQueue来管理 HTTPConnection，HTTPSConnection和VerifiedHTTPSConnection。XXXXConnection都继承至httplib的httplib.HTTPConnection或者httplib.HTTPSConnection。</p>
<p>典型使用案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; http = urllib3.PoolManager(num_pools=50)</div><div class="line">&gt;&gt;&gt; r = http.request(&apos;GET&apos;, &apos;http://httpbin.org/ip&apos;)</div><div class="line">&gt;&gt;&gt; r.data</div><div class="line">&apos;&#123;\n  &quot;origin&quot;: &quot;111.0.186.217&quot;\n&#125;\n&apos;</div></pre></td></tr></table></figure>
<p>同样可以使用 ConnectionPool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; http = urllib3.HTTPConnectionPool(&apos;httpbin.org&apos;)</div><div class="line">&gt;&gt;&gt; r = http.request(&apos;GET&apos;, &apos;http://httpbin.org/ip&apos;)</div><div class="line">&gt;&gt;&gt; r.data</div><div class="line">&apos;&#123;\n  &quot;origin&quot;: &quot;111.0.186.217&quot;\n&#125;\n&apos;</div></pre></td></tr></table></figure>
<p>PoolManager 与 ConnectionPool有相似的API，是因为它们有共同的父类RequestMethods</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class RequestMethods(object):</div><div class="line">    def urlopen(self, method, url, body=None, headers=None,</div><div class="line">                encode_multipart=True, multipart_boundary=None,</div><div class="line">                **kw)</div><div class="line">    def request(self, method, url, fields=None, headers=None,</div><div class="line">                **urlopen_kw)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<h4 id="multipart编码文件上传"><a href="#multipart编码文件上传" class="headerlink" title="multipart编码文件上传"></a>multipart编码文件上传</h4><p>urllib3 中POST, PUT, PATCH等方法，可以使用两种Content-Type上传数据，一种是application/x-www-form-urlencoded，一般用来传递非文件数据，还有一种就是multipart/form-data，可以传输数据也可以传输文件。</p>
<p>使用bat命令查看Content-Type为application/x-www-form-urlencoded的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ bat -f=true http://httpbin.org/post name=qiuzhu age=18</div></pre></td></tr></table></figure></p>
<p>HTTP请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST /post HTTP/1.1</div><div class="line">Host: httpbin.org</div><div class="line">Accept: application/json</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">User-Agent: bat/0.1.0</div><div class="line"></div><div class="line"></div><div class="line">name=qiuzhu&amp;age=18</div></pre></td></tr></table></figure></p>
<p>使用bat上传文件，其Content-Type为multipart/form-data的请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ bat -f=true http://httpbin.org/post name=qiuzhu f@f.txt</div></pre></td></tr></table></figure></p>
<p>HTTP请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">POST /post HTTP/1.1</div><div class="line">Host: httpbin.org</div><div class="line">Accept: application/json</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Content-Type: multipart/form-data; boundary=386e4e1c64f</div><div class="line">User-Agent: bat/0.1.0</div><div class="line"></div><div class="line"></div><div class="line">--386e4e1c64f</div><div class="line">Content-Disposition: form-data; name=&quot;f&quot;; filename=&quot;f.txt&quot;</div><div class="line">Content-Type: application/octet-stream</div><div class="line"></div><div class="line">text in the f.txt</div><div class="line"></div><div class="line">--386e4e1c64f</div><div class="line">Content-Disposition: form-data; name=&quot;name&quot;</div><div class="line"></div><div class="line">qiuzhu</div><div class="line">--386e4e1c64f--</div></pre></td></tr></table></figure></p>
<p>区别在于，application/x-www-form-urlencoded类型的请求会使用urlencode来编码数据，然而multipart/form-data会使用一个边界字符串来区分每一个数据Item，以及请求的起始和结束位置。</p>
<p>filepost模块中的encode_multipart_formdata和fields模块的RequestField都实现了相关功能。使用方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; file_data = open(&apos;/Users/xshare/Desktop/f.txt&apos;).read()</div><div class="line">&gt;&gt;&gt; http = urllib3.PoolManager()</div><div class="line">&gt;&gt;&gt; r = http.request(</div><div class="line">        &apos;POST&apos;,</div><div class="line">        &apos;http://httpbin.org/post&apos;,</div><div class="line">        fields=&#123;&apos;filefield&apos;: (&apos;f.txt&apos;, file_data)&#125;</div><div class="line">)</div><div class="line">&gt;&gt;&gt; r.data</div></pre></td></tr></table></figure>
<h4 id="自动跳转-与-gzip-deflate编码"><a href="#自动跳转-与-gzip-deflate编码" class="headerlink" title="自动跳转 与 gzip/deflate编码"></a>自动跳转 与 gzip/deflate编码</h4><p>重试和自动跳转的逻辑很简单，就是检测到重定向状态码(303)之后，重试次数加1，如果超过最大重试次数，则抛出异常。</p>
<p>Retry不仅能实现redirects的计数，而且还有Read和Connect的重试。</p>
<p>自动跳转的逻辑实现在 PoolManager 的 urlopen中，值得注意的是，跳转之后，method为变为GET。</p>
<p>当HTTP Response的Content-Type为gzip/deflate时，对该数据进行编码，使用的库为zlib，这部分的逻辑实现在 response模块的 HTTPResponse中。</p>
<h4 id="HTTP-与-SOCKS代理"><a href="#HTTP-与-SOCKS代理" class="headerlink" title="HTTP 与 SOCKS代理"></a>HTTP 与 SOCKS代理</h4><p>ProxyManager</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Requests是目前最流行的Python HTTP库，使用者众多，包括Amazon, Google, Twitter等大公司和美国国家安全局等政府机构。在&lt;a href=&quot;https://github.com/kennethreitz/requests&quot; title=&quot;Requests: HTTP for Humans&quot;&gt;github&lt;/a&gt;上有2w多的star。Requests的接口简单，符合人的直觉而且功能强大。比如持久 Cookie 的会话, Keep-Alive &amp;amp; 连接池,文件分块上传, 流下载, SSL 认证等。其大部分功能由其内置的&lt;a href=&quot;https://github.com/shazow/urllib3&quot; title=&quot;urllib3&quot;&gt;urllib3&lt;/a&gt;库实现。所以Requests最关心的不是如何实现协议，而是如何设计接口，正如作者&lt;a href=&quot;https://github.com/kennethreitz&quot; title=&quot;kennethreitz&quot;&gt;github&lt;/a&gt;自我介绍，「The only thing I really care about is interface design」。&lt;br&gt;
    
    </summary>
    
      <category term="server" scheme="http://quqiuzhu.com/categories/server/"/>
    
    
      <category term="python" scheme="http://quqiuzhu.com/tags/python/"/>
    
      <category term="server" scheme="http://quqiuzhu.com/tags/server/"/>
    
      <category term="http" scheme="http://quqiuzhu.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记 正则表达式</title>
    <link href="http://quqiuzhu.com/2016/python-regexp/"/>
    <id>http://quqiuzhu.com/2016/python-regexp/</id>
    <published>2016-04-27T06:24:46.000Z</published>
    <updated>2016-04-27T07:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.5 版之后，Python 内建支持正则表达式，它提供的正则表达式是 Perl 风格的。</p>
<p>正则表达式（或 RE）是一种小型的、高度专业化的编程语言，经常使用会感受到它的神奇之处。Python 正则表达式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行的。</p>
<p>本文开始给出一个匹配规则的表格，然后谈谈常用的正则表达式。然后讲了 Python 中 re 模块的函数及其相关的使用方式，最后以实例的形式给出了相关函数的用法。<br><a id="more"></a></p>
<h2 id="正则匹配表"><a href="#正则匹配表" class="headerlink" title="正则匹配表"></a>正则匹配表</h2><table>
<thead>
<tr>
<th>记号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>foo</td>
<td>匹配foo这个字符串</td>
</tr>
<tr>
<td>foo<font color="red">I</font>bar</td>
<td>匹配foo 或者 bar</td>
</tr>
<tr>
<td>.</td>
<td>匹配任何字符（除了换行符）</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
</tr>
<tr>
<td>*</td>
<td>匹配 0 次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配 1 次或者更多次</td>
</tr>
<tr>
<td>?</td>
<td>匹配 0 或 1 次</td>
</tr>
<tr>
<td>{N}</td>
<td>匹配 N 次</td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配 M 到 N 次</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配 方括号里面的单个字符，可省略中间部分[a-z]</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配 不在方括号中出现的字符</td>
</tr>
<tr>
<td>(*<font color="red">I</font>+<font color="red">I</font>?<font color="red">I</font>{})?</td>
<td>后面的问号，加在前面任何一个字符上，表示匹配越短越好(非贪婪)</td>
</tr>
<tr>
<td>(…)</td>
<td>匹配括号中的正则表达式，并保存为子组</td>
</tr>
<tr>
<td>\d</td>
<td>匹配 [0-9] <code>\D</code> 相反</td>
</tr>
<tr>
<td>\w</td>
<td>匹配 [A-Za-z0-9_] <code>\W</code> 相反</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白 <code>\S</code> 相反</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界 <code>\B</code> 相反</td>
</tr>
<tr>
<td>\N</td>
<td>N为一个数字，匹配子组 N</td>
</tr>
<tr>
<td>\C</td>
<td>C为特殊字符，匹配特殊字符 <code>\.</code>,<code>\*</code>等</td>
</tr>
<tr>
<td>\A</td>
<td>同 <code>^</code></td>
</tr>
<tr>
<td>\Z</td>
<td>同 <code>$</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>上面的表格中 <code>|</code> 以 <font color="red">I</font> 代替</p>
</blockquote>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul>
<li>中文字符: <code>[\u4e00-\u9fa5]</code></li>
<li>HTML标记: <code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code></li>
<li>Email地址: <code>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</code></li>
<li>国内电话号码: <code>\d{3}-\d{8}|\d{4}-\d{7}</code></li>
<li>HTTP_URL: <code>(https?)://([^/]+)(/?.*)</code></li>
<li>时间(24h制): <code>((1|0?)[0-9]|2[0-3]):([0-5][0-9])</code></li>
<li>URL: <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li>
<li>QQ号: <code>[1-9][0-9]{4,}</code></li>
</ul>
<h2 id="Python-的-re-模块"><a href="#Python-的-re-模块" class="headerlink" title="Python 的 re 模块"></a>Python 的 re 模块</h2><p>使用正则表达式，我们通常有下面的几种需求</p>
<ul>
<li>验证是否匹配字符串</li>
<li>验证字符串中有正则表达式表示的字符</li>
<li>符合正则表达式的字符串提取</li>
<li>正则表达式替换</li>
<li>字符串分割</li>
</ul>
<p>因此从 re 包中可以到处的函数如下</p>
<ul>
<li>compile(pattern, flags=0)</li>
<li>match(pattern, string, flags=0)</li>
<li>search(pattern, string, flags=0)</li>
<li>findall(pattern, string, flags=0)</li>
<li>sub(pattern, repl, string, count=0, flags=0)</li>
<li>subn(pattern, repl, string, count=0, flags=0)</li>
<li>split(pattern, string, maxsplit=0, flags=0)</li>
</ul>
<p>一般的处理流程是编译正则表达式，获取一个 regex 对象，然后使用该对象的方法。每个函数对象里面包含的方法和 re 包中包含的一样(除了 compile 函数)。 实际上是 re 模块里面的函数调用了 regex 对象的相应的方法，下面是 re 包中 match 函数的实现，其他函数也是类似的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(pattern, string, flags=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> _compile(pattern, flags).match(string)</div></pre></td></tr></table></figure>
<p>re 包中的函数是先编译 regex 对象，然后调用其方法的。因为 re 模块有一块缓存区用来保存匹配过的正则表达式，所以速度也不会很慢，但是还是建议使用 regex 对象。</p>
<p>上面的函数都有一个 flags 参数，其实只是用来编译的，因为 re 包中的函数需要先编译再调用其他方法，所以每个函数都有一个 flag 参数。每个 flag 表示的含义如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ignore case</span></div><div class="line">I = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE </div><div class="line"></div><div class="line"><span class="comment"># assume current 8-bit locale</span></div><div class="line">L = LOCALE = sre_compile.SRE_FLAG_LOCALE </div><div class="line"></div><div class="line"><span class="comment"># assume unicode locale</span></div><div class="line">U = UNICODE = sre_compile.SRE_FLAG_UNICODE </div><div class="line"></div><div class="line"><span class="comment"># make anchors look for newline</span></div><div class="line">M = MULTILINE = sre_compile.SRE_FLAG_MULTILINE </div><div class="line"></div><div class="line"><span class="comment"># make dot match newline</span></div><div class="line">S = DOTALL = sre_compile.SRE_FLAG_DOTALL </div><div class="line"></div><div class="line"><span class="comment"># ignore whitespace and comments</span></div><div class="line">X = VERBOSE = sre_compile.SRE_FLAG_VERBOSE</div></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><code>match()</code> 和 <code>search()</code> 如果匹配的话，会返回一个匹配对象，否则会返回 None。匹配对象有 <code>group()</code> 与 <code>groups()</code> 方法。 <code>group()</code> 会返回匹配的字符串， 而<code>groups()</code> 返回存在的子组元组的元组，如果不存在匹配的子组，则返回<code>()</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">g = re.match(<span class="string">'foo'</span>, <span class="string">'foo'</span>) <span class="comment"># 匹配对象</span></div><div class="line">g.group() <span class="comment"># 'foo'</span></div><div class="line">g.groups() <span class="comment"># ()</span></div><div class="line"></div><div class="line">g = re.match(<span class="string">'foo(\d+)'</span>, <span class="string">'foo2033d'</span>) </div><div class="line">g.group() <span class="comment"># 'foo2033'</span></div><div class="line">g.groups() <span class="comment"># ('2033',)</span></div><div class="line"></div><div class="line">g = re.match(<span class="string">'^foo(\d+)'</span>, <span class="string">'foo2033d'</span>) <span class="comment"># 同上</span></div><div class="line">g = re.match(<span class="string">'^foo(\d+)$'</span>, <span class="string">'foo2033d'</span>) <span class="comment"># None</span></div><div class="line">g = re.match(<span class="string">'foo(\d+)'</span>, <span class="string">'dfoo2033d'</span>) <span class="comment"># None</span></div></pre></td></tr></table></figure>
<p>从上面最后一组的值，可以知道，<code>re.match</code> 默认从头开始匹配，但是并不默认一定要完全匹配到字符串末尾，除非使用结束符 <code>$</code> 。</p>
<p><code>re.search</code> 与 <code>re.match</code>的区别正在于此，<code>re.search</code>并不一定要从头开始，比如说上面四组匹配结果如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">g = re.search(<span class="string">'foo(\d+)'</span>, <span class="string">'foo2033d'</span>) <span class="comment"># 匹配成功</span></div><div class="line">g = re.search(<span class="string">'^foo(\d+)'</span>, <span class="string">'foo2033d'</span>) <span class="comment"># 匹配成功</span></div><div class="line">g = re.search(<span class="string">'^foo(\d+)$'</span>, <span class="string">'foo2033d'</span>) <span class="comment"># None</span></div><div class="line">g = re.search(<span class="string">'foo(\d+)'</span>, <span class="string">'dfoo2033d'</span>) <span class="comment"># 匹配成功</span></div></pre></td></tr></table></figure>
<p><code>re.findall</code> 跟 <code>re.search</code> 与 <code>re.match</code> 的区别是什么呢？第一，<code>re.search</code> 与 <code>re.match</code> 只匹配一次。 第二，<code>re.findall</code> 总会返回一个列表，不管匹配不匹配。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">g = re.match(<span class="string">'foo(\d+)'</span>, <span class="string">'foo2033foo9d'</span>)</div><div class="line">g.group() <span class="comment"># 'foo2033'</span></div><div class="line">g.groups() <span class="comment"># ('2033',)</span></div><div class="line"></div><div class="line">l = re.findall(<span class="string">'foo(\d+)'</span>, <span class="string">'foo2033foo9d'</span>)</div><div class="line">l <span class="comment"># ['2033', '9']</span></div><div class="line">l = re.findall(<span class="string">'foo\d+'</span>, <span class="string">'foo2033foo9d'</span>)</div><div class="line">l <span class="comment"># ['foo2033', 'foo9']</span></div></pre></td></tr></table></figure>
<p><code>re.findall</code> 返回的列表，如果正则表达式有子组，则匹配返回的子组列表，否则返回整个正则表达式的匹配列表。</p>
<p><code>re.sub</code> 与 <code>re.subn</code> 是用来做字符串替换的，它们唯一的区别是前面的返回替换了的字符串，后面返回一个替换之后的字符串和替换次数的元组。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">r = re.sub(<span class="string">'foo(\d+)'</span>,<span class="string">'*'</span>, <span class="string">'foo2033foo9d'</span>)</div><div class="line">r <span class="comment"># '**d'</span></div><div class="line"></div><div class="line">r = re.subn(<span class="string">'foo(\d+)'</span>,<span class="string">'*'</span>, <span class="string">'foo2033foo9d'</span>)</div><div class="line">r <span class="comment"># ('**d', 2)</span></div></pre></td></tr></table></figure>
<p><code>re.split</code> 使用正则表达式作为分隔符，但有子组和无子组的情况是不一样的，有子组的会分割字符串，但会留下子组的匹配值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">l = re.split(<span class="string">'foo(\d+)'</span>, <span class="string">'foo2033foo9d'</span>)</div><div class="line">l <span class="comment"># ['', '2033', '', '9', 'd']</span></div><div class="line"></div><div class="line">l = re.split(<span class="string">'foo\d+'</span>, <span class="string">'foo2033foo9d'</span>)</div><div class="line">l <span class="comment"># ['', '', 'd']</span></div></pre></td></tr></table></figure>
<p>– end –</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.5 版之后，Python 内建支持正则表达式，它提供的正则表达式是 Perl 风格的。&lt;/p&gt;
&lt;p&gt;正则表达式（或 RE）是一种小型的、高度专业化的编程语言，经常使用会感受到它的神奇之处。Python 正则表达式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行的。&lt;/p&gt;
&lt;p&gt;本文开始给出一个匹配规则的表格，然后谈谈常用的正则表达式。然后讲了 Python 中 re 模块的函数及其相关的使用方式，最后以实例的形式给出了相关函数的用法。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://quqiuzhu.com/categories/python/"/>
    
    
      <category term="python" scheme="http://quqiuzhu.com/tags/python/"/>
    
      <category term="magic" scheme="http://quqiuzhu.com/tags/magic/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记 描述符</title>
    <link href="http://quqiuzhu.com/2016/python-descriptor/"/>
    <id>http://quqiuzhu.com/2016/python-descriptor/</id>
    <published>2016-04-24T14:21:25.000Z</published>
    <updated>2016-04-24T15:28:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多做 C++ 和 Java 的朋友在看 Python 的时候，或许会问，Python 中没有 <code>private</code>, <code>protected</code>, <code>public</code> 等关键字，是怎么控制变量访问的呢？Python 中有没有静态变量，实例变量呢？ </p>
<p>Python 没有静态变量和实例变量的区别，只有属性。类的属性还是对象的属性没有任何不同，因为类也是一种对象。Python 中类的属性还包含了类中的方法，而控制属性访问的正是描述符。</p>
<p>本文将详细叙述描述符协议、描述符的实现方式、属性及属性访问顺序等主题。<br><a id="more"></a></p>
<h2 id="描述符协议"><a href="#描述符协议" class="headerlink" title="描述符协议"></a>描述符协议</h2><p>一个实例 instance 有一个属性 x，对属性 x 有三种操作。 访问 <code>y = instance.x</code>， 赋值 <code>instance.x = 20</code> 和 删除 <code>del instance.x</code>，描述符正是对这三种操作进行控制。 </p>
<p>描述符协议有 3 个方法，只要实现 <code>__get__</code> 或者 <code>__set__</code> 方法就可以算是一个描述器。实现了 <code>__set__</code> 方法的描述器是数据描述器，实现了 <code>__get__</code> 方法，但是没有实现 <code>__set__</code> 方法的是非数据描述符。两种描述符在属性访问时的优先级不同，后面会讲。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">descr.__get__(self, inst, type=None) --&gt; value</div><div class="line">descr.__set__(self, inst, value) --&gt; None</div><div class="line">descr.__delete__(self, inst) --&gt; None</div></pre></td></tr></table></figure>
<p>描述符协议调用者是属性，所以参数 self 是指属性，inst 指的是实例。</p>
<h2 id="描述符实现方式"><a href="#描述符实现方式" class="headerlink" title="描述符实现方式"></a>描述符实现方式</h2><p>有三种典型的方式来实现描述符，类、property() 和 property 装饰器 </p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameDescripter</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._name = <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, inst_type)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__get__'</span>, self._name</div><div class="line">        <span class="keyword">return</span> self._name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__set__'</span>, self._name</div><div class="line">        self._name = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__delete__'</span>, self._name</div><div class="line">        self._name = <span class="string">''</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></div><div class="line">    name = NameDescripter()</div><div class="line">    </div><div class="line">user = Person()</div><div class="line">user.name = <span class="string">'quqiuzhu'</span> </div><div class="line">out: __set__</div><div class="line">user.name  </div><div class="line">out: __get__ quqiuzhu</div><div class="line"><span class="keyword">del</span> user.name</div><div class="line">out: __delete__ quqiuzhu</div><div class="line">user.name</div><div class="line">out: __get__</div></pre></td></tr></table></figure>
<h3 id="property"><a href="#property" class="headerlink" title="property()"></a>property()</h3><p>property() 定义如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</div></pre></td></tr></table></figure>
<p>用该函数实现上一节的 Person name 属性</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._name = <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get_name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__get__'</span>, self._name</div><div class="line">        <span class="keyword">return</span> self._name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set_name</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__set__'</span>, self._name</div><div class="line">        self._name = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del_name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__delete__'</span>, self._name</div><div class="line">        self._name = <span class="string">''</span></div><div class="line">    name = property(__get_name, __set_name, __del_name)</div></pre></td></tr></table></figure>
<h3 id="property-装饰器"><a href="#property-装饰器" class="headerlink" title="property 装饰器"></a>property 装饰器</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._name = <span class="string">''</span></div><div class="line">        </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__get__'</span>, self._name</div><div class="line">        <span class="keyword">return</span> self._name</div><div class="line"></div><div class="line"><span class="meta">    @name.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__set__'</span>, self._name</div><div class="line">        self._name = value</div><div class="line"></div><div class="line"><span class="meta">    @name.deleter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'__delete__'</span>, self._name</div><div class="line">        self._name = <span class="string">''</span></div></pre></td></tr></table></figure>
<h2 id="方法描述符"><a href="#方法描述符" class="headerlink" title="方法描述符"></a>方法描述符</h2><p>方法是一种特殊的属性，其描述符实现原理如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function</span><span class="params">(object)</span>:</span></div><div class="line">    . . .</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">        <span class="string">"Simulate func_descr_get() in Objects/funcobject.c"</span></div><div class="line">        <span class="keyword">return</span> types.MethodType(self, obj, objtype)</div></pre></td></tr></table></figure>
<p>Python 中 <code>.</code> 是 <code>getattr()</code> 函数的语法糖。所以方法调用 <code>object.func()</code> 相当于 <code>getattr(object, &#39;func&#39;) 然后调用 __call__()</code>。当然，获取属性的方式不只是 <code>getattr(object, &#39;func&#39;)</code> 那么简单，获取属性是一连串的序列的判断和调用，下面会讲。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性的查找遵循LEGB原则：Local，Enclosing，Global以及Builtin。现在实例中找，找不到就去类中找，再去父类中找，一直找到 object 还找不到就去。</p>
<p>上面只是罗列一些点，但并没有展开，强烈推荐三篇参考的文章，比 Python Expert Programming 写得清晰很多。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]  <a href="https://www.ibm.com/developerworks/cn/opensource/os-pythondescriptors/" target="_blank" rel="external">Python 描述符简介</a><br>[2]  <a href="http://pyzh.readthedocs.org/en/latest/Descriptor-HOW-TO-Guide.html" target="_blank" rel="external">Python 描述器引导(翻译)</a><br>[3]  <a href="http://wlwang41.github.io/content/python/python%E4%B8%AD%E7%9A%84attributes.html" target="_blank" rel="external">Python 中的attributes</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多做 C++ 和 Java 的朋友在看 Python 的时候，或许会问，Python 中没有 &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt; 等关键字，是怎么控制变量访问的呢？Python 中有没有静态变量，实例变量呢？ &lt;/p&gt;
&lt;p&gt;Python 没有静态变量和实例变量的区别，只有属性。类的属性还是对象的属性没有任何不同，因为类也是一种对象。Python 中类的属性还包含了类中的方法，而控制属性访问的正是描述符。&lt;/p&gt;
&lt;p&gt;本文将详细叙述描述符协议、描述符的实现方式、属性及属性访问顺序等主题。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://quqiuzhu.com/categories/python/"/>
    
    
      <category term="python" scheme="http://quqiuzhu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记 高性能容器 collections</title>
    <link href="http://quqiuzhu.com/2016/python-collections/"/>
    <id>http://quqiuzhu.com/2016/python-collections/</id>
    <published>2016-04-17T12:54:06.000Z</published>
    <updated>2016-04-24T01:40:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python 支持四种内建的集合类型 dict, list, set 和 tuple, 这些类型覆盖了大多数的使用场景。作为补充，collections 提供了几种高性能容器数据类型，Counter, deque, defaultdict 和 OrderedDict，以及 namedtuple() 函数。<br><a id="more"></a></p>
<h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>先不忙讲 Counter 怎么用，先想想如果你来实现一个计数器，应该怎么实现，有哪些功能。我列一下，至少有 3 个功能。</p>
<ol>
<li>接收要统计的数据</li>
<li>更新统计数据</li>
<li>获取统计结果</li>
</ol>
<p>其中 1 和 3 都涉及和 Python 内建类型之间的转换，2 涉及 Counter 之间的交互。</p>
<h4 id="接收要统计的数据"><a href="#接收要统计的数据" class="headerlink" title="接收要统计的数据"></a>接收要统计的数据</h4><p>数据一般是从构造函数传入，参数可以为 iterable 对象，也可以是 mapping 或者关键字参数。 </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">c = Counter(<span class="string">'quqiuzhu'</span>)</div><div class="line">c = Counter(&#123;<span class="string">'qu'</span>: <span class="number">1</span>, <span class="string">'qiu'</span>: <span class="number">2</span>, <span class="string">'zhu'</span>: <span class="number">3</span>&#125;)</div><div class="line">c = Counter(qu=<span class="number">1</span>, qiu=<span class="number">2</span>, zhu=<span class="number">3</span>)</div><div class="line">``` </div><div class="line">上面的例子看起来好像是 Counter 里面的 key 必须是字符串类型，value 必须是 int 类型的，实际上并没有这样的限制。比如可以像这样</div><div class="line"></div><div class="line">```py</div><div class="line">cc = Counter(&#123;<span class="string">'qu'</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">2</span>, <span class="string">'zhu'</span>: <span class="string">'str'</span>&#125;)</div></pre></td></tr></table></figure>
<p>不过在 Counter 之间计算的时候会有一些问题，比如两个 Counter 相加的时候。</p>
<h4 id="更新统计数据"><a href="#更新统计数据" class="headerlink" title="更新统计数据"></a>更新统计数据</h4><p>单个数据的更新和访问，支持下标访问，如果 Counter 中没有该记录，则返回 0。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">c[<span class="string">'quqiuzhu.com'</span>] <span class="comment"># 0</span></div><div class="line">c[<span class="string">'quqiuzhu.com'</span>] = <span class="number">10</span> <span class="comment"># 10</span></div></pre></td></tr></table></figure>
<p>批量更新有两个方法，<code>subtract([iterable-or-mapping])</code> 和 <code>update([iterable-or-mapping])</code>，参数可以是 iterable, dict, 关键字参数或者 Counter 对象。 <code>subtract</code> 方法对 key 相同的 value 简单的应用减法运算，如果 value 不支持减法运算的话，就会出错，比如上面提到的，value 为 字符串的情况。</p>
<p>Counter 之间也可以进行 +, -, |, &amp; 运算，和你想象中的一样，都是相同 key 的 value 值之间的运算。</p>
<h4 id="获取统计结果"><a href="#获取统计结果" class="headerlink" title="获取统计结果"></a>获取统计结果</h4><p><code>most_common([n])</code> 获取计数最多的 n 个 (key, value)的列表，<code>items()</code> 返回所有的，<code>elements()</code> 获取统计计数大于等于 2 的。</p>
<p>可以使用 set, list, dict 转为相应类型。 </p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>实现了双端队列的 API, 当队列为定长队列时，如果队列 isFull，则丢弃另一端的 items。</p>
<ul>
<li>append(x)</li>
<li>appendleft(x)</li>
<li>extend(iterable)</li>
<li>extendleft(iterable) 其中 iterable item 顺序会反过来</li>
<li>pop()</li>
<li>popleft()</li>
<li>clear()</li>
<li>count(x)</li>
<li>remove(x)</li>
<li>reverse() 原地反转, 返回None</li>
<li>rotate(n)</li>
</ul>
<p>支持随机访问，但性能不是很好。有只读属性 maxlen, 支持函数操作 len(d), reversed(d), copy.copy(d), copy.deepcopy(d)</p>
<h2 id="defaultdict-与-OrderedDict"><a href="#defaultdict-与-OrderedDict" class="headerlink" title="defaultdict 与 OrderedDict"></a>defaultdict 与 OrderedDict</h2><p>该结构扩展自内建类型 dict 。给所有新的 key 一个默认值，该默认值来自于参数 default_factory。<br>用法如下:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = defaultdict(list)</div><div class="line">d[<span class="string">'k'</span>] <span class="comment"># []</span></div></pre></td></tr></table></figure>
<p>由于当前没有 key ‘k’, 所以 defaultdict 调用 default_factory 函数，创建了一个默认值。 这里的 default_factory 是 list 函数。</p>
<p>OrderedDict items 是按照顺序存放的，用来做相等性检测是很好的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = &#123;<span class="string">'banana'</span>: <span class="number">3</span>, <span class="string">'apple'</span>:<span class="number">4</span>, <span class="string">'pear'</span>: <span class="number">1</span>, <span class="string">'orange'</span>: <span class="number">2</span>&#125;</div><div class="line">OrderedDict(sorted(d.items(), key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>]))</div></pre></td></tr></table></figure>
<p>可以指定排序函数</p>
<h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple()"></a>namedtuple()</h2><p>这是非常经典，非常有意思的一个函数，其简单用法如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</div></pre></td></tr></table></figure>
<p>这个 Point 是一个类，该类增强了内建的 tuple 类型。 使其支持一般的 tuple操作，也同时支持名称访问，上面的代码，其实现为</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(tuple)</span>:</span></div><div class="line">    <span class="string">'Point(x, y)'</span></div><div class="line"></div><div class="line">    __slots__ = ()</div><div class="line"></div><div class="line">    _fields = (<span class="string">'x'</span>, <span class="string">'y'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(_cls, x, y)</span>:</span></div><div class="line">        <span class="string">'Create a new instance of Point(x, y)'</span></div><div class="line">        <span class="keyword">return</span> _tuple.__new__(_cls, (x, y))</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make</span><span class="params">(cls, iterable, new=tuple.__new__, len=len)</span>:</span></div><div class="line">        <span class="string">'Make a new Point object from a sequence or iterable'</span></div><div class="line">        result = new(cls, iterable)</div><div class="line">        <span class="keyword">if</span> len(result) != <span class="number">2</span>:</div><div class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected 2 arguments, got %d'</span> % len(result))</div><div class="line">        <span class="keyword">return</span> result</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">'Return a nicely formatted representation string'</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'Point(x=%r, y=%r)'</span> % self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_asdict</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">'Return a new OrderedDict which maps field names to their values'</span></div><div class="line">        <span class="keyword">return</span> OrderedDict(zip(self._fields, self))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_replace</span><span class="params">(_self, **kwds)</span>:</span></div><div class="line">        <span class="string">'Return a new Point object replacing specified fields with new values'</span></div><div class="line">        result = _self._make(map(kwds.pop, (<span class="string">'x'</span>, <span class="string">'y'</span>), _self))</div><div class="line">        <span class="keyword">if</span> kwds:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Got unexpected field names: %r'</span> % kwds.keys())</div><div class="line">        <span class="keyword">return</span> result</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getnewargs__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">'Return self as a plain tuple.   Used by copy and pickle.'</span></div><div class="line">        <span class="keyword">return</span> tuple(self)</div><div class="line"></div><div class="line">    __dict__ = _property(_asdict)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">'Exclude the OrderedDict from pickling'</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    x = _property(_itemgetter(<span class="number">0</span>), doc=<span class="string">'Alias for field number 0'</span>)</div><div class="line"></div><div class="line">    y = _property(_itemgetter(<span class="number">1</span>), doc=<span class="string">'Alias for field number 1'</span>)</div></pre></td></tr></table></figure>
<p>其内部实现为 String 定义模板加上 <code>exec class_definition in namespace</code> 来实现。有兴趣的可以查看其源代码。</p>
<p>新建一个 namedtuple 条目</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = Point(<span class="number">11</span>, <span class="number">22</span>)</div><div class="line">p.x <span class="comment"># 11</span></div></pre></td></tr></table></figure>
<p>总结以上，其 API 列表为</p>
<ul>
<li>somenamedtuple._make(iterable)</li>
<li>somenamedtuple._asdict()</li>
<li>somenamedtuple._replace(kwargs)</li>
</ul>
<h2 id="ABC-集合抽象基类"><a href="#ABC-集合抽象基类" class="headerlink" title="ABC 集合抽象基类"></a>ABC 集合抽象基类</h2><p>下面的表格摘自 <a href="https://docs.python.org/2/library/collections.html" target="_blank" rel="external">Python 官方文档</a></p>
<p><img src="http://quqiuzhu.com/images/python_abc.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 支持四种内建的集合类型 dict, list, set 和 tuple, 这些类型覆盖了大多数的使用场景。作为补充，collections 提供了几种高性能容器数据类型，Counter, deque, defaultdict 和 OrderedDict，以及 namedtuple() 函数。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://quqiuzhu.com/categories/python/"/>
    
    
      <category term="python" scheme="http://quqiuzhu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记 多进程 multiprocessing</title>
    <link href="http://quqiuzhu.com/2016/python-multiprocessing/"/>
    <id>http://quqiuzhu.com/2016/python-multiprocessing/</id>
    <published>2016-04-14T05:13:04.000Z</published>
    <updated>2016-04-24T01:41:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python 解释器有一个全局解释器锁(PIL)，导致每个 Python 进程中最多同时运行一个线程，因此 Python 多线程程序并不能改善程序性能，不能发挥多核系统的优势，可以通过<a href="http://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="external">这篇文章</a>了解。</p>
<p>但是多进程程序不受此影响， Python 2.6 引入了 multiprocessing 来解决这个问题。这里介绍 multiprocessing 模块下的进程，进程同步，进程间通信和进程管理四个方面的内容。 这里主要讲解多进程的典型使用，multiprocessing 的 API 几乎是完复制了 threading 的API， 因此只需花少量的时间就可以熟悉 threading 编程了。<br><a id="more"></a></p>
<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>先来看一段代码</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, current_process</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    proc = current_process()</div><div class="line">    proc.name, proc.pid</div><div class="line"></div><div class="line">sub_proc = Process(target=func, args=())</div><div class="line">sub_proc.start()</div><div class="line">sub_proc.join()</div><div class="line">proc = current_process()</div><div class="line">proc.name, proc.pid</div></pre></td></tr></table></figure>
<p>这是在主进程中创建子进程，然后启动(start) 子进程，等待(join) 子进程执行完，再继续执行主进程的整个的执行流程。</p>
<p>那么，一个进程应该是用来做什么的，它应该保存一些什么状态，它的生命周期是什么样的呢？</p>
<p>一个进程需要处理一些不同任务，或者处理不同的对象。创建进程需要一个 function 和相关参数，参数可以是dict <code>Process(target=func, args=(), kwargs = {})</code>，<code>name</code> 可以用来标识进程。</p>
<p>控制子进程进入不同阶段的是 <code>start()</code>, <code>join()</code>, <code>is_alive()</code>, <code>terminate()</code>, <code>exitcode</code> 方法。这些方法只能在创建子进程的进程中执行。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>锁是为了确保数据一致性，比如读写锁，每个进程给一个变量增加 1 ，但是如果在一个进程读取但还没有写入的时候，另外的进程也同时读取了，并写入该值，则最后写入的值是错误的，这时候就需要锁。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(lock)</span>:</span></div><div class="line">    lock.acquire()</div><div class="line">    <span class="comment"># do mysql query select update ...</span></div><div class="line">    lock.release()</div><div class="line">       </div><div class="line">lock = Lock()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">4</span>):</div><div class="line">    proc = Process(target=func, args=(lock))</div><div class="line">    proc.start()</div></pre></td></tr></table></figure>
<p>Lock 同时也实现了 ContextManager API, 可以结合 with 语句使用, 关于 ContextManager, 请移步 <a href="http://quqiuzhu.com/2016/python-decorator-and-context">Python 学习实践笔记 装饰器 与 context</a> 查看。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore 和 Lock 稍有不同，Semaphore 相当于 N 把锁，获取其中一把就可以执行了。 信号量的总数 N 在构造时传入，<code>s = Semaphore(N)</code>。 和 Lock 一样，如果信号量为0，则进程堵塞，直到信号大于0。</p>
<h3 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h3><p>Pipe 是在两个进程之间通信的工具，Pipe Constructor 会返回两个端</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conn1, conn2 = Pipe(<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>如果是全双工的(构造函数参数为True)，则双端口都可接收发送，否则前面的端口用于接收，后面的端口用于发送。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span><span class="params">(pipe)</span>:</span></div><div class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10000</span>):</div><div class="line">       pipe.send(i)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span><span class="params">(pipe)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"proc2 rev:"</span>, pipe.recv()</div><div class="line"></div><div class="line">pipe = Pipe()</div><div class="line">Process(target=proc1, args=(pipe[<span class="number">0</span>],)).start()</div><div class="line">Process(target=proc2, args=(pipe[<span class="number">1</span>],)).start()</div></pre></td></tr></table></figure>
<p>Pipe 的每个端口同时最多一个进程读写，否则数据会出各种问题</p>
<h3 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h3><p>multiprocessing.Queue 与 Queue.Queue 非常相似。其 API 列表如下</p>
<ul>
<li>qsize()</li>
<li>empty()</li>
<li>full()</li>
<li>put()</li>
<li>put_nowait()</li>
<li>get()</li>
<li>get_nowait()</li>
<li>close()</li>
<li>join_thread()</li>
<li>cancel_join_thread()</li>
</ul>
<p>当 Queue 为 Queue.Full 状态时，再 put() 会堵塞，当状态为 Queue.Empty 时，再 get() 也是。当 put() 或 get() 设置了超时参数，而超时的时候，会抛出异常。</p>
<p>Queue 主要用于多个进程产生和消费，一般使用情况如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</div><div class="line">        q.put(i)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"consumer"</span>, q.get()</div><div class="line"></div><div class="line">q = Queue(<span class="number">40</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</div><div class="line">    Process(target=producer, args=(q,)).start()</div><div class="line">Process(target=consumer, args=(q,)).start()</div></pre></td></tr></table></figure>
<p>十个生产者进程，一个消费者进程，共用同一个队列进行同步。</p>
<p>有一个简化版本的 multiprocessing.queues.SimpleQueue, 只支持3个方法 empty(), get(), put()。</p>
<p>也有一个强化版本的 JoinableQueue, 新增两个方法 task_done() 和 join()。 task_done() 是给消费者使用的，每完成队列中的一个任务，调用一次该方法。当所有的 tasks 都完成之后，交给调用 join() 的进程执行。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"consumer"</span>, q.get()</div><div class="line">        q.task_done()</div><div class="line"></div><div class="line">jobs = JoinableQueue()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</div><div class="line">        jobs.put(i)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</div><div class="line">    p = Process(target=consumer, args=(jobs,))</div><div class="line">    p.daemon = <span class="keyword">True</span></div><div class="line">    p.start()</div><div class="line"></div><div class="line">jobs.join()</div></pre></td></tr></table></figure>
<p>这个 join 函数等待 JoinableQueue 为空的时候，等待就结束，外面的进程可以继续执行了，但是那10个进程干嘛去了呢，他们还在等待呀，上面是设置了 <code>p.daemon = True</code>, 子进程才随着主进程结束的，如果没有设置，它们还是会一直等待的呢。</p>
<p>Lock、Pipe、Queue 和 Pipe 需要注意的是：尽量避免使用 Process.terminate 来终止程序，否则将会导致很多问题, 详情请移步<a href="https://docs.python.org/2/library/multiprocessing.html" target="_blank" rel="external">python 官方文档</a>查看。</p>
<h2 id="进程间数据共享"><a href="#进程间数据共享" class="headerlink" title="进程间数据共享"></a>进程间数据共享</h2><p>前一节中, Pipe、Queue 都有一定数据共享的功能，但是他们会堵塞进程, 这里介绍的两种数据共享方式都不会堵塞进程, 而且都是多进程安全的。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存有两个结构，一个是 <code>Value</code>, 一个是 <code>Array</code>，这两个结构内部都实现了锁机制，因此是多进程安全的。 用法如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n, a)</span>:</span></div><div class="line">    n.value = <span class="number">50</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</div><div class="line">        a[i] += <span class="number">10</span></div><div class="line"></div><div class="line">num = Value(<span class="string">'d'</span>, <span class="number">0.0</span>)</div><div class="line">ints= Array(<span class="string">'i'</span>, range(<span class="number">10</span>))</div><div class="line"></div><div class="line">p = Process(target=func, args=(num, ints))</div><div class="line">p.start()</div><div class="line">p.join()</div></pre></td></tr></table></figure>
<p>Value 和 Array 都需要设置其中存放值的类型，d 是 double 类型，i 是 int 类型，具体的对应关系在Python 标准库的 sharedctypes 模块中查看。</p>
<h3 id="服务进程-Manager"><a href="#服务进程-Manager" class="headerlink" title="服务进程 Manager"></a>服务进程 Manager</h3><p>上面的共享内存支持两种结构 Value 和 Array, 这些值在主进程中管理，很分散。 Python 中还有一统天下，无所不能的 Server process，专门用来做数据共享。 其支持的类型非常多，比如list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value 和 Array 用法如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(dct, lst)</span>:</span></div><div class="line">    dct[<span class="number">88</span>] = <span class="number">88</span></div><div class="line">    lst.reverse()</div><div class="line"></div><div class="line">manager = Manager()</div><div class="line">dct = manager.dict()</div><div class="line">lst = manager.list(range(<span class="number">5</span>,<span class="number">10</span>))</div><div class="line"></div><div class="line">p = Process(target=func, args=(dct, lst))</div><div class="line">p.start()</div><div class="line">p.join()</div><div class="line"><span class="keyword">print</span> dct, <span class="string">'|'</span>, lst</div><div class="line">Out: &#123;<span class="number">88</span>: <span class="number">88</span>&#125; | [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure>
<p>一个 Manager 对象是一个服务进程，推荐多进程程序中，数据共享就用一个 manager 管理。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>如果有50个任务要执行, 但是 CPU 只有4核, 你可以创建50个进程来做这个事情。但是大可不必，徒增管理开销。如果你只想创建4个进程，让他们轮流替你完成任务，不用自己去管理具体的进程的创建销毁，那 Pool 是非常有用的。</p>
<p>Pool 是进程池，进程池能够管理一定的进程，当有空闲进程时，则利用空闲进程完成任务，直到所有任务完成为止，用法如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x*x</div><div class="line"></div><div class="line">pool = Pool(processes=<span class="number">4</span>)</div><div class="line"><span class="keyword">print</span> pool.map(func, range(<span class="number">8</span>))</div></pre></td></tr></table></figure>
<p>Pool 进程池创建4个进程，不管有没有任务，都一直在进程池中等候，等到有数据的时候就开始执行。<br>Pool 的 API 列表如下：</p>
<ul>
<li>apply(func[, args[, kwds]]) </li>
<li>apply_async(func[, args[, kwds[, callback]]])</li>
<li>map(func, iterable[, chunksize])</li>
<li>map_async(func, iterable[, chunksize[, callback]])</li>
<li>imap(func, iterable[, chunksize])</li>
<li>imap_unordered(func, iterable[, chunksize])</li>
<li>close()</li>
<li>terminate()</li>
<li>join()</li>
</ul>
<h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><p>apply_async 和 map_async 执行之后立即返回，然后异步返回结果。 使用方法如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x*x</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">print</span> x, <span class="string">'in callback'</span></div><div class="line">    </div><div class="line">pool = Pool(processes=<span class="number">4</span>)</div><div class="line">result = pool.map_async(func, range(<span class="number">8</span>), <span class="number">8</span>, callback)</div><div class="line"><span class="keyword">print</span> result.get(), <span class="string">'in main'</span></div><div class="line">Out:</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>] <span class="keyword">in</span> callback</div><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>] <span class="keyword">in</span> main</div></pre></td></tr></table></figure>
<p>有两个值得提到的，一个是 callback，另外一个是 multiprocessing.pool.AsyncResult。 callback 是在结果返回之前，调用的一个函数，这个函数必须只有一个参数，它会首先接收到结果。callback 不能有耗时操作，因为它会阻塞主线程。</p>
<p>AsyncResult 是获取结果的对象，其 API 如下</p>
<ul>
<li>get([timeout])</li>
<li>wait([timeout])</li>
<li>ready()</li>
<li>successful()</li>
</ul>
<p>如果设置了 timeout 时间，超时会抛出 multiprocessing.TimeoutError 异常。wait 是等待执行完成。 ready 测试是否已经完成，successful 是在确定已经 ready 的情况下，如果执行中没有抛出异常，则成功，如果没有ready 就调用该函数，会得到一个 AssertionError 异常。</p>
<h3 id="Pool-管理"><a href="#Pool-管理" class="headerlink" title="Pool 管理"></a>Pool 管理</h3><p>这里不再继续讲 map 的各种变体了，因为从上面的 API 一看便知。</p>
<p>然后我们来看看 Pool 的执行流程，有三个阶段。第一、一个进程池接收很多任务，然后分开执行任务；第二、不再接收任务了；第三、等所有任务完成了，回家，不干了。</p>
<p>这就是上面的方法，close 停止接收新的任务，如果还有任务来，就会抛出异常。 join 是等待所有任务完成。 join 必须要在 close 之后调用，否则会抛出异常。terminate 非正常终止，内存不够用时，垃圾回收器调用的就是这个方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 解释器有一个全局解释器锁(PIL)，导致每个 Python 进程中最多同时运行一个线程，因此 Python 多线程程序并不能改善程序性能，不能发挥多核系统的优势，可以通过&lt;a href=&quot;http://www.oschina.net/translate/pythons-hardest-problem&quot;&gt;这篇文章&lt;/a&gt;了解。&lt;/p&gt;
&lt;p&gt;但是多进程程序不受此影响， Python 2.6 引入了 multiprocessing 来解决这个问题。这里介绍 multiprocessing 模块下的进程，进程同步，进程间通信和进程管理四个方面的内容。 这里主要讲解多进程的典型使用，multiprocessing 的 API 几乎是完复制了 threading 的API， 因此只需花少量的时间就可以熟悉 threading 编程了。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://quqiuzhu.com/categories/python/"/>
    
    
      <category term="python" scheme="http://quqiuzhu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记 装饰器 与 context</title>
    <link href="http://quqiuzhu.com/2016/python-decorator-and-context/"/>
    <id>http://quqiuzhu.com/2016/python-decorator-and-context/</id>
    <published>2016-04-07T04:17:58.000Z</published>
    <updated>2016-04-24T14:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>Python中函数是一等公民，装饰器的作用就是接收一个函数，返回其增强版本的函数。例如:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(function)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_mydecorator</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'do something before'</span></div><div class="line">        res = function(*args, **kw)</div><div class="line">        <span class="keyword">print</span> <span class="string">'do somthing after'</span></div><div class="line">        <span class="keyword">return</span> res</div><div class="line">    <span class="keyword">return</span> _mydecorator</div><div class="line"></div><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'function executing'</span></div><div class="line"></div><div class="line">function()</div><div class="line"></div><div class="line">输出：</div><div class="line">do something before</div><div class="line">function executing</div><div class="line">do somthing after</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>装饰器是语法糖，因此装饰器可以用其他一般的语句来实现，我们将上面例子中的<code>function</code>定义部分作出下面改动<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'function executing'</span></div><div class="line">    </div><div class="line">function = decorator(function)</div></pre></td></tr></table></figure></p>
<p>实现同样的功能，所以装饰器一点也不厉害，就是函数调用加上赋值运算的语法糖。</p>
<p>上面的是无参数的装饰器，如果是有参数的装饰器，则这么来实现<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">otherdecorator</span><span class="params">(args1, args2)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_otherdecorator</span><span class="params">(function)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__otherdecorator</span><span class="params">(*args, **kw)</span>:</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'do something before with args %s, %s'</span> % (args1, args2)</div><div class="line">            res = function(*args, **kw)</div><div class="line">            <span class="keyword">print</span> <span class="string">'do something after with args %s, %s'</span> % (args1, args2)</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">return</span> __otherdecorator</div><div class="line">    <span class="keyword">return</span> _otherdecorator</div><div class="line"></div><div class="line"><span class="meta">@otherdecorator('name', 'age')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'function executing'</span></div><div class="line">    </div><div class="line">function()</div><div class="line">输出：</div><div class="line">do something before <span class="keyword">with</span> args name, age</div><div class="line">function executing</div><div class="line">do something after <span class="keyword">with</span> args name, age</div></pre></td></tr></table></figure></p>
<p>有参数的函数的定义相当于<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'function executing'</span></div><div class="line"></div><div class="line">function = otherdecorator(<span class="string">'name'</span>, <span class="string">'age'</span>)(function)</div></pre></td></tr></table></figure></p>
<p>装饰器还有类的实现方式，类实现<code>__call__</code>方法的时候可以被调用，这里不再多讲。</p>
<p>应用</p>
<ul>
<li>参数检查</li>
<li>缓存</li>
<li>代理</li>
</ul>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><h3 id="with-语句的使用"><a href="#with-语句的使用" class="headerlink" title="with 语句的使用"></a>with 语句的使用</h3><p>python 上下文跟 with 语句的使用有关。一般的用法如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">        <span class="keyword">print</span> line</div><div class="line">        <span class="keyword">raise</span> ValueError()</div></pre></td></tr></table></figure></p>
<p>如果在语句体中发生异常，文件也将正常关闭，主要是因为 with 语句与 context_manager 的交互。 context_manager 是实现了 <code>__enter__()</code> 和 <code>__exit__()</code> 方法的对象。 with 语句保证在语句体重发生异常时，<code>__exit__()</code> 方法 也会被调用，从而使程序正确退出上下文。</p>
<p>上面的代码中，<code>open(filename)</code> 返回的是一个 context_manager， 而  <code>as f</code> 这个 f 被赋值的是 <code>context_manager.__enter__()</code> 的返回结果。</p>
<p>但是有时候又会发现，不用with语句也可以直接使用，比如 <code>f = open(filename)</code> 。这是因为 python 的文件对象实现了 <code>__enter__()</code> 和 <code>__exit__()</code> 方法， 文件对象本身也是 context_manager， 其 <code>__enter__()</code> 返回的是自身。</p>
<h3 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h3><p>有一个装饰器 <code>contexmanager</code>， 一个 <code>closing()</code> 函数和 <code>nested()</code> 函数。</p>
<p><code>contexmanager</code> 是用来帮助我们自定义 contexmanager 的, 其中 yield 语句前一部分在 <code>__enter__()</code> 中执行，yield 语句 执行 with 语句体, yield 语句后的部分在 <code>__exit__()</code> 中执行。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cm</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'do something before'</span></div><div class="line">    <span class="keyword">yield</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'do something after'</span></div></pre></td></tr></table></figure>
<p>很容易想出来 <code>contextmanager</code> 装饰器的实现方式，这里不再多讲。</p>
<p><code>closing(that)</code> 函数是一个 <code>contextmanager</code>，不是装饰器，它的作用就是最终会调用 that 的 close 方法，如果不想自己实现上下文管理器，但是也要支持上下文管理器的功能的话，就只需要实现 close 方法，然后使用 <code>with closing(that) as f</code> 就好了。</p>
<p><code>nested()</code> 函数用来解决嵌套with语句的问题，可以这样使用<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> nested(A(), B(), C()) <span class="keyword">as</span> (X, Y, Z):</div><div class="line">	  <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>如果细节了解不清楚，建议看 IBM 的<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/" target="_blank" rel="external">文章</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;p&gt;Python中函数是一等公民，装饰器的作用就是接收一个函数，返回其增强版本的函数。例如:&lt;br&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;decorator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(function)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_mydecorator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(*args, **kw)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;do something before&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        res = function(*args, **kw)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;do somthing after&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _mydecorator&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@decorator&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;function executing&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;function()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;输出：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;do something before&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;function executing&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;do somthing after&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://quqiuzhu.com/categories/python/"/>
    
    
      <category term="python" scheme="http://quqiuzhu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记 迭代器和生成器</title>
    <link href="http://quqiuzhu.com/2016/python-iterator-and-generator/"/>
    <id>http://quqiuzhu.com/2016/python-iterator-and-generator/</id>
    <published>2016-04-06T15:08:59.000Z</published>
    <updated>2016-04-24T14:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>一个迭代器是一个实现了<code>__iter__()</code>方法和 <code>next()</code>方法的对象，但是我发现这两个并不需要一起实现，就像Java中一样，返回迭代子的对象和迭代子是分离的。 <code>__iter__()</code> 只是返回迭代器，真正进行迭代的是实现了 <code>next()</code>方法的，所以可以在 <code>for i in r</code> 的r中实现一个<code>__iter__()</code>方法，然后返回一个实现了<code>next()</code>方法的对象<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Itrator</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.i = <span class="number">4</span>;</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.i:</div><div class="line">            self.i -= <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> self.i</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> StopIteration</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterable</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> Itrator()</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Iterable():</div><div class="line">    <span class="keyword">print</span> i</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>当然一般上都可以把这两个方法写在同一个类里面，python里和Java是一样的，一个是Iterable，一个是Itrator。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>有两种生成器，第一种是产生值的生成器，像下面这样的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(values)</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'xxxx'</span></div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values:</div><div class="line">        <span class="keyword">yield</span> value</div></pre></td></tr></table></figure></p>
<p>第二种种是作为表达式的生成器，这种生成器需要接受外面的输入，像下面这样的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">psychologist</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'plaese tell me your problem'</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span> :</div><div class="line">        answer = (<span class="keyword">yield</span>)</div><div class="line">        <span class="keyword">if</span> answer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">if</span> answer.endswith(<span class="string">'?'</span>):</div><div class="line">                <span class="keyword">print</span> <span class="string">'what is you question?'</span></div><div class="line">            <span class="keyword">elif</span> <span class="string">'good'</span> <span class="keyword">in</span> ans:</div><div class="line">                <span class="keyword">print</span> <span class="string">'good good'</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">'hahaha'</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> StopIteration</div></pre></td></tr></table></figure></p>
<h3 id="第一种生成器"><a href="#第一种生成器" class="headerlink" title="第一种生成器"></a>第一种生成器</h3><p>这种生成器是可以迭代的，因为生成器函数会返回一个生成器对象，而生成器实现了<code>next</code> 和 <code>__iter__</code>方法，所以是可以迭代的。</p>
<p>另外，由于生成器函数默认会返回一个生成器，所以生成器方法中return 语句不能返回任何东西，否则就会出错。</p>
<p>生成器最重要的一个特性，是可以暂停并保持生成器方法的状态，直到调用下一个生成器方法，这一种特性被用在协同程序中。</p>
<p>一开始调用生成器函数时，除了返回一个生成器对象之外，不会执行任何代码。因此，在上面的power 方法中，即便是 print ‘xxxx’语句在 关键字yield之前，也不会执行。这些代码是初始代码，将会在第一个next方法调用的时候执行。</p>
<h3 id="第二种生成器"><a href="#第二种生成器" class="headerlink" title="第二种生成器"></a>第二种生成器</h3><p>这种生成器需要外面给它传值，有四个方法,分别是 <code>next()</code>, <code>send(val)</code>, <code>throw(err)</code>, <code>close()</code>。</p>
<p><code>send(val)</code> 方法给生成器传值，每一次传值就是一次迭代</p>
<p><code>next()</code> 方法等价于 <code>send(None)</code>， 因此迭代该生成器，就相当于不断发送None 值，直到遇到 StopIteration 异常。</p>
<p><code>close()</code> 相当于做了一个停止的标记，之后不能再调用 send 和 next 方法，否则会得到 StopIteration 异常，但是可以调用throw方法。 </p>
<p><code>throw(err)</code> 方法会向生成器发出异常，而不是向外发出。要理解这一点并不难，因为这样外面调用者就可以随意停止迭代了。</p>
<h3 id="生成器的几个应用"><a href="#生成器的几个应用" class="headerlink" title="生成器的几个应用"></a>生成器的几个应用</h3><ul>
<li>协程</li>
<li>生成器表达式（类似列表推导）</li>
</ul>
<h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><p>这里面的函数一般都以i开头。</p>
<p><code>islice()</code> 窗口迭代，第一个参数是iterable对象，后面如果只有一个参数，则是stop位置，如果两个参数则是start 和 stop，第三个参数是步长<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a = range(<span class="number">10</span>)</div><div class="line">list(itertools.islice(a, <span class="number">4</span>))</div><div class="line">Out: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">list(itertools.islice(a, <span class="number">4</span>, <span class="keyword">None</span>))</div><div class="line">Out: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line">list(itertools.islice(a, <span class="number">4</span>, <span class="keyword">None</span>, <span class="number">2</span>))</div><div class="line">Out: [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure></p>
<p><code>count</code>,<code>cycle</code>,<code>repeat</code> 无限迭代，第一个一段整数不断递增或者递减，第二个传入一个可迭代对象，然后就会得到一个循环迭代。repeat函数会一直重复迭代一个元素。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">list(itertools.islice(itertools.count(<span class="number">20</span>), <span class="number">4</span>))</div><div class="line">Out: [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]</div><div class="line">list(itertools.islice(itertools.count(<span class="number">20</span>,<span class="number">-1</span>), <span class="number">4</span>))</div><div class="line">Out: [<span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>]</div><div class="line">list(itertools.islice(itertools.repeat(<span class="number">-1</span>), <span class="number">4</span>))</div><div class="line">Out: [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]</div><div class="line">list(itertools.islice(itertools.cycle([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]), <span class="number">4</span>))</div><div class="line">Out: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure></p>
<p><code>chain</code>, 传入一组可迭代对象，按顺序迭代，有时候知道是列表等明确的数据类型的时候，是不需要这个函数的，一般也可以先转换，再连接，但又太浪费内存资源了。所以写一个共用库的时候，最后记得用这个。</p>
<p>相似的是<code>tee</code>, 传入一个iterable对象，返回多个iterable对象，默认返回两个<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">l1 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>]</div><div class="line">l2 = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</div><div class="line">list(itertools.chain(l1,l2)))</div><div class="line">Out: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</div><div class="line">i1,i2 = itertools.tee(l1,<span class="number">2</span>)</div><div class="line">i1.next()</div><div class="line">Out: <span class="number">2</span></div><div class="line">i2.next()</div><div class="line">Out: <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p><code>compress</code>,<code>ifilter</code>,<code>ifilterfalse</code> 过滤迭代，<code>compress</code>函数传入iterable数据，第二个iterable选择条件，而<code>ifilter</code>,<code>ifilterfalse</code>，第一个参数是筛选函数，第二个参数是数据。下面是选择征兵青年，输出年龄在18-24岁的人名，用这3个函数分别的完成方式<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">candidates = [</div><div class="line">	(<span class="number">8</span>,<span class="string">'zhangsan'</span>), </div><div class="line">	(<span class="number">21</span>, <span class="string">'lisi'</span>), </div><div class="line">	(<span class="number">19</span>, <span class="string">'wangmazi'</span>),</div><div class="line">	(<span class="number">40</span>, <span class="string">'laozi'</span>)</div><div class="line">]</div><div class="line">list(itertools.compress(</div><div class="line">	 	(c[<span class="number">1</span>] <span class="keyword">for</span> c <span class="keyword">in</span> candidates),</div><div class="line">	 	(<span class="number">18</span> &lt;= c[<span class="number">0</span>] &lt;= <span class="number">22</span> <span class="keyword">for</span> c <span class="keyword">in</span> candidates)</div><div class="line">	 )</div><div class="line">)</div><div class="line">Out: [<span class="string">'lisi'</span>, <span class="string">'wangmazi'</span>]</div><div class="line">list(itertools.ifilter(</div><div class="line">		<span class="keyword">lambda</span> x:<span class="number">18</span> &lt;= x[<span class="number">0</span>] &lt;= <span class="number">22</span>,</div><div class="line">	 	(c <span class="keyword">for</span> c <span class="keyword">in</span> candidates)</div><div class="line">	 )</div><div class="line">)</div><div class="line">Out: [(<span class="number">21</span>, <span class="string">'lisi'</span>), (<span class="number">19</span>, <span class="string">'wangmazi'</span>)]</div></pre></td></tr></table></figure></p>
<p><code>ifilterfalse</code>函数与<code>ifilter</code>只是条件函数不同，就不列举了。这里可以发现一个轻微的不同，我只要输出名字，但是<code>ifilter</code>输出了 candidate 列表。但是如果只传入名字作为参数，又无法判断，只能输入 candidate 列表，因为输入的数据和输出的数据是同源的，返回的就只能是 candidate列表。该例子说明了为什么有了 <code>ifilter</code> 还需要 <code>compress</code> 的原因，当需要返回的数据不足以作为筛选判断条件的时候，<code>compress</code> 就非常有用。</p>
<p><code>takewhile</code>,<code>dropwhile</code> 第一个参数是筛选函数，第二个参数是数据。<code>takewhile</code> 是一开始就拿，直到条件不满足为止；<code>dropwhile</code> 一开始不要，直到条件不满足，然后拿之后的所有数据。所以<code>takewhile</code>倾向于拿前面的数据，<code>dropwhile</code>倾向于拿后半部分的数据。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list(itertools.takewhile(<span class="keyword">lambda</span> x: x&lt;<span class="number">5</span>, [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]))</div><div class="line">Out: [<span class="number">1</span>, <span class="number">4</span>]</div><div class="line">list(itertools.dropwhile(<span class="keyword">lambda</span> x: x&lt;<span class="number">5</span>, [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]))</div><div class="line">Out: [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>]</div></pre></td></tr></table></figure></p>
<p><code>izip()</code>, <code>izip_longest()</code> 装包函数，把几个课迭代的对象组合起来，返回元组迭代<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">list(itertools.izip(<span class="string">'ABCD'</span>, <span class="string">'xy'</span>))</div><div class="line">Out: [(<span class="string">'A'</span>, <span class="string">'x'</span>), (<span class="string">'B'</span>, <span class="string">'y'</span>)]</div><div class="line">list(itertools.izip_longest(<span class="string">'ABCD'</span>, <span class="string">'xy'</span>))</div><div class="line">Out: [(<span class="string">'A'</span>, <span class="string">'x'</span>), (<span class="string">'B'</span>, <span class="string">'y'</span>), (<span class="string">'C'</span>, <span class="keyword">None</span>), (<span class="string">'D'</span>, <span class="keyword">None</span>)]</div><div class="line">list(itertools.izip_longest(<span class="string">'ABCD'</span>, <span class="string">'xy'</span>, fillvalue = <span class="string">'-'</span>))</div><div class="line">Out: [(<span class="string">'A'</span>, <span class="string">'x'</span>), (<span class="string">'B'</span>, <span class="string">'y'</span>), (<span class="string">'C'</span>, <span class="string">'-'</span>), (<span class="string">'D'</span>, <span class="string">'-'</span>)]</div></pre></td></tr></table></figure></p>
<p><code>imap()</code>, <code>starmap()</code> 第一个参数是函数，后面的是传入的数据，返回的是函数的返回值序列 <code>imap()</code> 先把后面的一串可迭代对象装包，<code>starmap()</code>是后面参数已经装包好了的<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list(itertools.imap(operator.add, (<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>), (<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>)))</div><div class="line">Out: [<span class="number">7</span>, <span class="number">5</span>, <span class="number">13</span>]</div><div class="line">list(itertools.imap(operator.add, (<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>), (<span class="number">5</span>,<span class="number">2</span>)))</div><div class="line">Out: [<span class="number">7</span>, <span class="number">5</span>]</div></pre></td></tr></table></figure></p>
<p><code>groupby()</code> 将迭代对象变为按连续的key分组，返回是一个迭代对象，该对象为(key, subgroup) 形式。这里只是让key不连续重复，并不会保证key不重复<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">lst = <span class="string">'get uuuuuuuuuuuuuuupd'</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">group</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="keyword">for</span> k,g <span class="keyword">in</span> itertools.groupby(data):</div><div class="line">        <span class="keyword">print</span> k,list(g)</div><div class="line">group(lst)</div><div class="line">Out: </div><div class="line">g [<span class="string">'g'</span>]</div><div class="line">e [<span class="string">'e'</span>]</div><div class="line">t [<span class="string">'t'</span>]</div><div class="line">  [<span class="string">' '</span>]</div><div class="line">u [<span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>, <span class="string">'u'</span>]</div><div class="line">p [<span class="string">'p'</span>]</div><div class="line">d [<span class="string">'d'</span>]</div></pre></td></tr></table></figure></p>
<p><code>product()</code>, <code>permutations()</code>, <code>combinations()</code> 笛卡尔乘法、排列和组合。笛卡尔乘包含自身与自身的组合，排列不包含，而组合不按顺序来。这个不举例子，可以将一些双重循环变成单循环</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h2&gt;&lt;p&gt;一个迭代器是一个实现了&lt;code&gt;__iter__()&lt;/code&gt;方法和 &lt;code&gt;next()&lt;/code&gt;方法的对象，但是我发现这两个并不需要一起实现，就像Java中一样，返回迭代子的对象和迭代子是分离的。 &lt;code&gt;__iter__()&lt;/code&gt; 只是返回迭代器，真正进行迭代的是实现了 &lt;code&gt;next()&lt;/code&gt;方法的，所以可以在 &lt;code&gt;for i in r&lt;/code&gt; 的r中实现一个&lt;code&gt;__iter__()&lt;/code&gt;方法，然后返回一个实现了&lt;code&gt;next()&lt;/code&gt;方法的对象&lt;br&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Itrator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.i = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self.i:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            self.i -= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.i&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; StopIteration&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__iter__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Itrator()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Iterable():&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; i&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://quqiuzhu.com/categories/python/"/>
    
    
      <category term="python" scheme="http://quqiuzhu.com/tags/python/"/>
    
  </entry>
  
</feed>
